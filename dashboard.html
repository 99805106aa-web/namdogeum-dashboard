<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
<meta name="theme-color" content="#2563EB">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>남도금형 스마트 품질 모니터링</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
:root {
  --primary: #2563EB;
  --danger: #DC2626;
  --success: #16A34A;
  --warning: #F59E0B;
  --gray: #6B7280;
  --bg: #F3F4F6;
  --card: #FFFFFF;
  --border: #E5E7EB;
  --text: #1F2937;
  --text-light: #6B7280;
  --sidebar-w: 320px;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Malgun Gothic', sans-serif;
  background: var(--bg);
  color: var(--text);
  display: flex;
  min-height: 100vh;
  overflow-x: hidden;
  position: relative;
}
body::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(135deg, rgba(27,42,107,0.08) 0%, rgba(180,30,40,0.04) 100%), url('bg-factory.jpg') center/cover no-repeat fixed;
  opacity: 0.12;
  z-index: 0;
  pointer-events: none;
}
body.dark::before {
  background: linear-gradient(135deg, rgba(27,42,107,0.3) 0%, rgba(180,30,40,0.1) 100%), url('bg-factory.jpg') center/cover no-repeat fixed;
  opacity: 0.3;
}

/* ── 햄버거 버튼 (모바일) ── */
.menu-toggle {
  display: none;
  position: fixed;
  top: 12px;
  left: 12px;
  z-index: 1100;
  width: 44px;
  height: 44px;
  border: none;
  border-radius: 10px;
  background: var(--primary);
  color: #fff;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,.2);
  -webkit-tap-highlight-color: transparent;
}

/* ── 오버레이 (모바일) ── */
.sidebar-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.4);
  z-index: 999;
  -webkit-tap-highlight-color: transparent;
}

/* ── 사이드바 ── */
.sidebar {
  width: var(--sidebar-w);
  min-width: var(--sidebar-w);
  background: var(--card);
  border-right: 1px solid var(--border);
  padding: 24px 20px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
  z-index: 1000;
  -webkit-overflow-scrolling: touch;
}
.sidebar h2 { font-size: 18px; color: var(--primary); margin-bottom: 4px; }
.sidebar h3 { font-size: 14px; color: var(--text-light); margin-bottom: 4px; }
.sidebar label { font-size: 13px; font-weight: 600; display: block; margin-bottom: 4px; }

.file-drop {
  border: 2px dashed var(--border);
  border-radius: 12px;
  padding: 28px 16px;
  text-align: center;
  cursor: pointer;
  transition: border-color .2s, background .2s;
  font-size: 14px;
  color: var(--text-light);
  -webkit-tap-highlight-color: transparent;
}
.file-drop:hover, .file-drop.dragover {
  border-color: var(--primary);
  background: #EFF6FF;
}
.file-drop input { display: none; }

select, input[type=date] {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 14px;
  background: #fff;
  -webkit-appearance: none;
  appearance: none;
  min-height: 44px;
}
select[multiple] { height: 130px; min-height: 130px; }

.slider-wrap { display: flex; align-items: center; gap: 8px; }
.slider-wrap input[type=range] { flex: 1; height: 36px; }
.slider-wrap .val { font-weight: 700; color: var(--danger); min-width: 48px; text-align: right; font-size: 14px; }
.slider-wrap .val-input { width: 60px; padding: 2px 4px; border: 1px solid var(--border); border-radius: 4px; font-weight: 700; color: var(--danger); text-align: right; font-size: 14px; background: var(--card-bg); }
.slider-wrap .val-input:focus { outline: 2px solid var(--primary); border-color: var(--primary); }

.btn {
  display: block;
  width: 100%;
  padding: 14px;
  border: none;
  border-radius: 10px;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  transition: opacity .2s;
  -webkit-tap-highlight-color: transparent;
  min-height: 48px;
}
.btn:hover { opacity: .85; }
.btn:active { opacity: .7; }
.btn-primary { background: var(--primary); color: #fff; }
.btn-success { background: var(--success); color: #fff; }
.btn-danger  { background: var(--danger);  color: #fff; }
.btn-sm { padding: 10px 16px; font-size: 13px; width: auto; display: inline-block; min-height: 40px; }

.info-box {
  padding: 10px 14px;
  border-radius: 8px;
  font-size: 13px;
}
.info-box.info    { background: #DBEAFE; color: #1E40AF; }
.info-box.success { background: #D1FAE5; color: #065F46; }
.info-box.warn    { background: #FEF3C7; color: #92400E; }

/* ── 메인 ── */
.main {
  flex: 1;
  padding: 24px 28px;
  overflow-y: auto;
  min-width: 0;
  position: relative;
  z-index: 1;
}
.main h1 {
  font-size: 24px;
  margin-bottom: 20px;
}

/* 탭 */
.tabs {
  display: flex;
  gap: 0;
  border-bottom: 2px solid var(--border);
  margin-bottom: 20px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
}
.tabs::-webkit-scrollbar { display: none; }
.tab-btn {
  padding: 12px 20px;
  border: none;
  background: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: var(--text-light);
  border-bottom: 3px solid transparent;
  margin-bottom: -2px;
  transition: color .2s, border-color .2s;
  white-space: nowrap;
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  min-height: 44px;
}
.tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); }
.tab-btn:hover { color: var(--primary); }
.tab-content { display: none; }
.tab-content.active { display: block; }

/* KPI 카드 */
.kpi-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 14px;
  margin-bottom: 24px;
}
.kpi-grid.kpi-grid-2 { grid-template-columns: repeat(2, 1fr); }
.kpi-card {
  background: var(--card);
  border-radius: 12px;
  padding: 18px 12px;
  text-align: center;
  border: 1px solid var(--border);
  box-shadow: 0 1px 3px rgba(0,0,0,.06);
}
.kpi-card .value { font-size: 28px; font-weight: 800; }
.kpi-card .label { font-size: 12px; color: var(--text-light); margin-top: 4px; }

/* 차트 래퍼 */
.chart-box {
  background: var(--card);
  border-radius: 12px;
  border: 1px solid var(--border);
  padding: 16px;
  margin-bottom: 20px;
  box-shadow: 0 1px 3px rgba(0,0,0,.06);
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
.chart-box h3 { font-size: 15px; margin-bottom: 12px; }

/* 테이블 */
.tbl-wrap {
  overflow-x: auto;
  margin-bottom: 16px;
  -webkit-overflow-scrolling: touch;
}
table.data-tbl {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
  min-width: 500px;
}
table.data-tbl th {
  background: var(--primary);
  color: #fff;
  padding: 10px 10px;
  text-align: left;
  position: sticky;
  top: 0;
  white-space: nowrap;
}
table.data-tbl td {
  padding: 9px 10px;
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
}
table.data-tbl tr:hover td { background: #F0F7FF; }
table.data-tbl tr:active td { background: #DBEAFE; }

.placeholder {
  text-align: center;
  padding: 80px 20px;
  color: var(--text-light);
  font-size: 16px;
}
.placeholder .icon { font-size: 48px; margin-bottom: 12px; }
.placeholder-mobile { display: none; }
.placeholder-pc { display: inline; }

.export-bar { display: flex; gap: 10px; margin-bottom: 16px; flex-wrap: wrap; }

.section-divider {
  border: none;
  border-top: 1px solid var(--border);
  margin: 20px 0;
}

/* ── 터치 스크롤 힌트 ── */
.scroll-hint {
  text-align: center;
  font-size: 11px;
  color: var(--text-light);
  padding: 4px 0;
  display: none;
}

/* ── 하단 고정 액션바 (모바일) ── */
.bottom-bar {
  display: none;
  position: fixed;
  bottom: 0; left: 0; right: 0;
  z-index: 1050;
  background: var(--card);
  border-top: 1px solid var(--border);
  padding: 8px 12px;
  padding-bottom: max(8px, env(safe-area-inset-bottom));
  box-shadow: 0 -2px 10px rgba(0,0,0,.1);
  gap: 8px;
  justify-content: space-around;
}
.bottom-bar button {
  flex: 1;
  padding: 10px 6px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  min-height: 44px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  background: var(--bg);
  color: var(--text);
}
.bottom-bar button .bar-icon { font-size: 18px; }
.bottom-bar button:active { background: var(--primary); color: #fff; }

/* ── 모바일 분석시작 플로팅 버튼 ── */
.mobile-analyze-fab {
  display: none;
  position: fixed;
  bottom: 76px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1060;
  padding: 14px 36px;
  border: none;
  border-radius: 50px;
  background: linear-gradient(135deg, #2563EB 0%, #1D4ED8 100%);
  color: #fff;
  font-size: 16px;
  font-weight: 800;
  cursor: pointer;
  box-shadow: 0 4px 20px rgba(37, 99, 235, 0.5), 0 2px 8px rgba(0,0,0,.15);
  -webkit-tap-highlight-color: transparent;
  animation: fab-pulse 2s ease-in-out infinite;
  white-space: nowrap;
  min-height: 52px;
  letter-spacing: 0.5px;
}
.mobile-analyze-fab:active {
  transform: translateX(-50%) scale(0.95);
  box-shadow: 0 2px 10px rgba(37, 99, 235, 0.4);
}
@keyframes fab-pulse {
  0%, 100% { box-shadow: 0 4px 20px rgba(37, 99, 235, 0.5), 0 2px 8px rgba(0,0,0,.15); }
  50% { box-shadow: 0 4px 30px rgba(37, 99, 235, 0.7), 0 4px 12px rgba(0,0,0,.2); }
}
body.dark .mobile-analyze-fab {
  background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
  box-shadow: 0 4px 20px rgba(59, 130, 246, 0.5), 0 2px 8px rgba(0,0,0,.3);
}

/* ── 드릴다운 모달 (모바일) ── */
.drill-modal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 2000;
  background: var(--bg);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding: 16px;
  padding-top: 56px;
}
.drill-modal.open { display: block; }
.drill-modal-close {
  position: fixed;
  top: 10px; right: 10px;
  z-index: 2001;
  width: 40px; height: 40px;
  border: none; border-radius: 50%;
  background: var(--danger); color: #fff;
  font-size: 20px; font-weight: 700;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,.2);
}

/* ── 헤더 바 ── */
.header-bar {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 20px;
}
.header-info {
  text-align: right;
  font-size: 12px;
  color: var(--text-light);
  line-height: 1.6;
}
.header-author {
  font-weight: 700;
  color: var(--text);
  font-size: 13px;
}

/* ── 모바일 탭 그리드 ── */
.tabs-mobile-grid {
  display: none;
}

/* ══════════════════════════════════════
   모바일 반응형 (768px 이하)
   ══════════════════════════════════════ */
@media (max-width: 768px) {
  .menu-toggle { display: flex; align-items: center; justify-content: center; }

  .sidebar {
    position: fixed;
    top: 0; left: 0;
    height: 100vh; height: 100dvh;
    transform: translateX(-100%);
    transition: transform .3s ease;
    box-shadow: 2px 0 12px rgba(0,0,0,.15);
    width: 85vw;
    min-width: 280px;
    max-width: 360px;
    padding-top: 64px;
  }
  .sidebar.open { transform: translateX(0); }
  .sidebar-overlay.open { display: block; }

  /* 다크모드 버튼 → 위치 조정 */
  .dark-toggle { top: 12px; right: 56px; }

  .main {
    padding: 60px 10px 80px 10px; /* 하단 액션바 공간 확보 */
    width: 100vw;
  }

  /* 헤더 세로 배치 */
  .header-bar {
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }
  .header-bar h1 { font-size: 18px; margin-bottom: 0; }
  .header-info { text-align: left; font-size: 11px; }

  /* 탭: 가로 스크롤 숨기고 2열 그리드 */
  .tabs { display: none !important; }
  .tabs-mobile-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 6px;
    margin-bottom: 16px;
  }
  .tabs-mobile-grid .tab-m-btn {
    padding: 10px 8px;
    border: 2px solid var(--border);
    border-radius: 10px;
    background: var(--card);
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    text-align: center;
    color: var(--text-light);
    transition: all .2s;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
  }
  .tabs-mobile-grid .tab-m-btn.active {
    border-color: var(--primary);
    color: var(--primary);
    background: #EFF6FF;
  }
  body.dark .tabs-mobile-grid .tab-m-btn.active { background: #1E3A5F; }

  /* KPI */
  .kpi-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
  .kpi-card { padding: 12px 8px; }
  .kpi-card .value { font-size: 20px; }
  .kpi-card .label { font-size: 10px; }

  /* 전주비교 카드 → 1행 가로 */
  .week-compare-grid {
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 6px !important;
  }
  .week-compare-grid .kpi-card { padding: 8px 4px; }
  .week-compare-grid .kpi-card .value { font-size: 14px; }
  .week-compare-grid .kpi-card .label { font-size: 9px; }

  /* 차트 */
  .chart-box { padding: 8px; margin-bottom: 12px; }
  .chart-box h3 { font-size: 13px; margin-bottom: 8px; }
  .chart-box p { font-size: 10px !important; }

  /* Plotly 모드바 모바일 최적화 */
  .modebar-container { top: 0 !important; right: 0 !important; }
  .modebar-group { display: flex !important; }
  .modebar-btn { font-size: 16px !important; padding: 6px !important; }
  .modebar-btn svg { width: 20px !important; height: 20px !important; }

  .placeholder { padding: 50px 16px; font-size: 14px; cursor: pointer; }
  .placeholder-pc { display: none; }
  .placeholder-mobile { display: inline; }
  .scroll-hint { display: block; }

  /* 테이블 첫열 고정 */
  table.data-tbl { font-size: 11px; }
  table.data-tbl th, table.data-tbl td { padding: 6px 7px; }
  table.data-tbl th:first-child,
  table.data-tbl td:first-child {
    position: sticky;
    left: 0;
    z-index: 2;
    background: inherit;
    box-shadow: 2px 0 4px rgba(0,0,0,.08);
    max-width: 140px;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  table.data-tbl th:first-child { background: var(--primary); z-index: 3; }

  /* 하단 고정 액션바 */
  .bottom-bar { display: flex; }

  /* 모바일 분석시작 플로팅 버튼 */
  .mobile-analyze-fab.show { display: block; }

  /* 애니메이션 컨트롤 2행 */
  .anim-controls {
    flex-direction: column !important;
    gap: 8px !important;
  }
  .anim-controls .anim-row1 {
    display: flex; gap: 8px; align-items: center; width: 100%;
  }
  .anim-controls .anim-row2 {
    width: 100%;
  }
  .anim-controls .anim-speed { display: none; }

  /* 기간비교 세로 스택 */
  .cmp-periods {
    flex-direction: column !important;
  }
  .cmp-periods input[type=date] {
    width: 100% !important;
    display: block !important;
    margin-bottom: 6px;
  }

  /* 내보내기 버튼 */
  .export-bar { flex-direction: column; }
  .export-bar button { width: 100% !important; min-width: unset !important; }
}

/* ══════════════════════════════════════
   초소형 모바일 (480px 이하)
   ══════════════════════════════════════ */
@media (max-width: 480px) {
  .kpi-card .value { font-size: 17px; }
  .main { padding: 56px 6px 80px 6px; }
  .sidebar { padding: 56px 12px 20px 12px; }
  .tabs-mobile-grid { grid-template-columns: repeat(2, 1fr); gap: 4px; }
  .tabs-mobile-grid .tab-m-btn { font-size: 11px; padding: 8px 4px; }
  .week-compare-grid .kpi-card .value { font-size: 12px; }
}

/* ══════════════════════════════════════
   PC 대형 화면 (1200px 이상)
   ══════════════════════════════════════ */
@media (min-width: 1200px) {
  .main { padding: 28px 40px; }
  .kpi-grid { grid-template-columns: repeat(3, 1fr); gap: 16px; }
  .kpi-card .value { font-size: 32px; }
  .chart-box { padding: 20px; margin-bottom: 24px; }
  .chart-box h3 { font-size: 16px; }
}

/* ══════════════════════════════════════
   초대형 화면 (1600px 이상)
   ══════════════════════════════════════ */
@media (min-width: 1600px) {
  .main { padding: 32px 60px; max-width: 1500px; }
  .kpi-card .value { font-size: 36px; }
}

/* ── 다크 모드 ── */
.dark-toggle {
  position: fixed; top: 12px; right: 12px; z-index: 1100;
  width: 44px; height: 44px; border: none; border-radius: 10px;
  background: var(--card); color: var(--text); font-size: 20px;
  cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,.15);
  border: 1px solid var(--border);
}

body.dark {
  --primary: #60A5FA; --danger: #F87171; --success: #4ADE80;
  --warning: #FBBF24; --gray: #9CA3AF; --bg: #111827;
  --card: #1F2937; --border: #374151; --text: #F9FAFB; --text-light: #9CA3AF;
}
body.dark .header-logo { filter: none !important; }
body.dark .file-drop { border-color: #4B5563; }
body.dark .file-drop:hover { background: #1E3A5F; border-color: var(--primary); }
body.dark select, body.dark input[type=date], body.dark input[type=text] {
  background: #374151; color: #F9FAFB; border-color: #4B5563;
}
body.dark table.data-tbl th { background: #1E40AF; }
body.dark table.data-tbl tr:hover td { background: #1E3A5F; }
body.dark .info-box.info { background: #1E3A5F; color: #93C5FD; }
body.dark .info-box.success { background: #064E3B; color: #6EE7B7; }
body.dark .info-box.warn { background: #78350F; color: #FCD34D; }

/* ── 다중파일 표시 ── */
.file-list { font-size: 12px; margin-top: 6px; }
.file-list .file-tag {
  display: inline-block; padding: 3px 8px; margin: 2px;
  background: #DBEAFE; color: #1E40AF; border-radius: 6px; font-size: 11px;
}
body.dark .file-list .file-tag { background: #1E3A5F; color: #93C5FD; }

/* ── 전체 요약 (Tab1) 개선 ── */
.t1-status-banner {
  display: flex; align-items: center; gap: 16px;
  padding: 16px 20px; border-radius: 12px; margin-bottom: 16px;
  font-weight: 700; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,.06);
}
.t1-status-banner.safe { background: #D1FAE5; color: #065F46; border: 1px solid #6EE7B7; }
.t1-status-banner.warn { background: #FEF3C7; color: #92400E; border: 1px solid #FCD34D; }
.t1-status-banner.danger { background: #FEE2E2; color: #991B1B; border: 1px solid #FCA5A5; }
body.dark .t1-status-banner.safe { background: #064E3B; color: #A7F3D0; border-color: #34D399; }
body.dark .t1-status-banner.warn { background: #78350F; color: #FDE68A; border-color: #F59E0B; }
body.dark .t1-status-banner.danger { background: #7F1D1D; color: #FCA5A5; border-color: #F87171; }
.t1-status-banner .t1-sb-score { font-size: 28px; font-weight: 900; }
.t1-status-banner .t1-sb-text { flex: 1; }
.t1-status-banner .t1-sb-sub { font-size: 12px; font-weight: 400; opacity: .8; margin-top: 2px; }
.t1-kpi-groups { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
.t1-kpi-group-title { font-size: 12px; color: var(--text-light); font-weight: 700; margin: 0 2px 6px; }
.t1-kpi-groups .kpi-grid { margin-bottom: 0; }

.t1-top5-bar { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px solid var(--border); }
.t1-top5-bar:last-child { border-bottom: none; }
.t1-top5-rank { width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 800; color: #fff; flex-shrink: 0; }
.t1-top5-name { flex: 1; font-size: 13px; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; }
.t1-top5-rate { font-size: 13px; font-weight: 800; min-width: 55px; text-align: right; }
.t1-top5-barwrap { width: 100px; height: 10px; background: var(--border); border-radius: 5px; overflow: hidden; flex-shrink: 0; }
.t1-top5-fill { height: 100%; border-radius: 5px; }

.t1-chart-row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px; }

.t1-mini-scroll { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 8px; margin-bottom: 16px; -webkit-overflow-scrolling: touch; }
.t1-mini-card { flex-shrink: 0; width: 130px; background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 10px; text-align: center; }
.t1-mini-card .t1-mc-date { font-size: 11px; color: var(--text-light); margin-bottom: 4px; }
.t1-mini-card .t1-mc-rate { font-size: 20px; font-weight: 800; }
.t1-mini-card .t1-mc-detail { font-size: 10px; color: var(--text-light); margin-top: 4px; }
.t1-mini-card .t1-mc-change { font-size: 11px; font-weight: 700; margin-top: 2px; }
.t1-mini-card .t1-mc-bar { height: 4px; border-radius: 2px; margin-top: 6px; }

.t1-insight-box {
  background: linear-gradient(135deg, #EFF6FF 0%, #F5F3FF 100%);
  border: 1px solid var(--border); border-radius: 12px;
  padding: 16px 20px; line-height: 1.7; font-size: 14px;
}
body.dark .t1-insight-box { background: linear-gradient(135deg, #1E293B 0%, #1E1B4B 100%); }
.t1-insight-box .t1-ins-item { padding: 3px 0; }
.t1-insight-box .t1-ins-item::before { content: '💡 '; }

@media (max-width: 768px) {
  .t1-chart-row { grid-template-columns: 1fr; }
  .t1-top5-barwrap { width: 60px; }
  .t1-mini-card { width: 110px; }
  .t1-mini-card .t1-mc-rate { font-size: 16px; }
  .t1-status-banner { flex-wrap: wrap; font-size: 14px; }
  .t1-status-banner .t1-sb-score { font-size: 22px; }
  .t1-kpi-group-title { font-size: 11px; margin-bottom: 4px; }
  /* 3개 카드 그룹에서 마지막 카드가 한쪽으로 치우치지 않게 전체 폭 사용 */
  .t1-kpi-group .kpi-grid:not(.kpi-grid-2) .kpi-card:last-child:nth-child(odd) {
    grid-column: 1 / -1;
  }
}

/* ── AI 품질진단 (Tab9) ── */
.ai-risk-badge {
  display: inline-flex; align-items: center; gap: 10px;
  padding: 16px 28px; border-radius: 16px; font-size: 22px; font-weight: 800;
  margin-bottom: 20px; box-shadow: 0 2px 12px rgba(0,0,0,.1);
}
.ai-risk-badge.safe   { background: #D1FAE5; color: #065F46; border: 2px solid #16A34A; }
.ai-risk-badge.warn   { background: #FEF3C7; color: #92400E; border: 2px solid #F59E0B; }
.ai-risk-badge.danger { background: #FEE2E2; color: #991B1B; border: 2px solid #DC2626; }
body.dark .ai-risk-badge.safe   { background: #064E3B; color: #6EE7B7; border-color: #4ADE80; }
body.dark .ai-risk-badge.warn   { background: #78350F; color: #FCD34D; border-color: #FBBF24; }
body.dark .ai-risk-badge.danger { background: #7F1D1D; color: #FCA5A5; border-color: #F87171; }

.ai-kpi-grid { display: grid; grid-template-columns: repeat(4,1fr); gap: 12px; margin-bottom: 20px; }
.ai-kpi-card {
  background: var(--card); border-radius: 12px; padding: 16px 12px; text-align: center;
  border: 1px solid var(--border); box-shadow: 0 1px 3px rgba(0,0,0,.06);
}
.ai-kpi-card .ai-kpi-val { font-size: 26px; font-weight: 800; }
.ai-kpi-card .ai-kpi-sub { font-size: 11px; color: var(--text-light); margin-top: 2px; }
.ai-kpi-card .ai-kpi-lbl { font-size: 12px; color: var(--text-light); margin-top: 4px; }

.ai-diagnosis-box {
  background: var(--card); border-radius: 12px; border: 1px solid var(--border);
  padding: 20px; margin-bottom: 20px; box-shadow: 0 1px 3px rgba(0,0,0,.06);
}
.ai-diagnosis-box h3 { font-size: 15px; margin-bottom: 14px; }
.ai-diagnosis-section { margin-bottom: 16px; line-height: 1.8; font-size: 14px; padding: 12px 14px; border-radius: 8px; background: var(--bg); }
.ai-diagnosis-section .ai-ds-title { font-weight: 700; color: var(--primary); font-size: 13px; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
.ai-diagnosis-section .ai-ds-body { color: var(--text); }
.ai-diagnosis-section .ai-ds-detail { font-size: 12px; color: var(--text-light); margin-top: 4px; line-height: 1.6; }
.ai-diagnosis-section.ai-ds-danger { border-left: 4px solid #DC2626; }
.ai-diagnosis-section.ai-ds-warn { border-left: 4px solid #F59E0B; }
.ai-diagnosis-section.ai-ds-safe { border-left: 4px solid #16A34A; }
.ai-diagnosis-section.ai-ds-info { border-left: 4px solid #2563EB; }

.ai-stat-grid { display: grid; grid-template-columns: repeat(3,1fr); gap: 10px; margin-bottom: 20px; }
.ai-stat-card {
  background: var(--card); border-radius: 10px; padding: 14px 10px; text-align: center;
  border: 1px solid var(--border);
}
.ai-stat-card .ai-st-val { font-size: 20px; font-weight: 800; }
.ai-stat-card .ai-st-lbl { font-size: 11px; color: var(--text-light); margin-top: 3px; }
.ai-stat-card .ai-st-sub { font-size: 10px; color: var(--text-light); margin-top: 2px; }

.ai-warning-card {
  background: var(--card); border-radius: 12px; border-left: 5px solid;
  padding: 14px 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 14px;
  box-shadow: 0 1px 3px rgba(0,0,0,.06);
}
.ai-warning-card.danger { border-left-color: #DC2626; }
.ai-warning-card.warn   { border-left-color: #F59E0B; }
.ai-warning-card .ai-wc-info { flex: 1; }
.ai-warning-card .ai-wc-title { font-weight: 700; font-size: 14px; margin-bottom: 4px; }
.ai-warning-card .ai-wc-desc  { font-size: 12px; color: var(--text-light); line-height: 1.5; }
.ai-warning-card .ai-wc-score { font-size: 11px; font-weight: 700; margin-top: 4px; }
.ai-warning-card .ai-wc-spark { width: 100px; height: 32px; flex-shrink: 0; }

.ai-item-detail { background: var(--card); border-radius: 12px; border: 1px solid var(--border); padding: 16px; margin-bottom: 20px; }
.ai-item-detail h3 { font-size: 15px; margin-bottom: 12px; }
.ai-item-row { display: flex; gap: 8px; align-items: center; padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
.ai-item-row:last-child { border-bottom: none; }
.ai-item-rank { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; font-size: 12px; color: #fff; flex-shrink: 0; }
.ai-item-name-wrap { flex: 1; min-width: 0; }
.ai-item-name { font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.ai-item-meta { font-size: 11px; color: var(--text-light); margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.ai-item-tags { display: flex; gap: 4px; margin-top: 4px; }
.ai-item-tag {
  display: inline-block; padding: 1px 6px; border-radius: 999px; font-size: 10px; font-weight: 700;
  background: var(--bg); color: var(--text-light); border: 1px solid var(--border);
}
.ai-item-tag.danger { background: #FEE2E2; color: #991B1B; border-color: #FECACA; }
.ai-item-tag.warn { background: #FEF3C7; color: #92400E; border-color: #FDE68A; }
.ai-item-tag.info { background: #DBEAFE; color: #1E40AF; border-color: #BFDBFE; }
.ai-item-bars { display: flex; gap: 4px; align-items: center; flex-shrink: 0; }
.ai-item-bar { height: 8px; border-radius: 4px; }
.ai-item-score { min-width: 45px; text-align: right; font-weight: 700; font-size: 12px; flex-shrink: 0; }

.ai-timeline {
  background: var(--card); border-radius: 12px; border: 1px solid var(--border);
  padding: 20px; margin-bottom: 20px; box-shadow: 0 1px 3px rgba(0,0,0,.06);
}
.ai-timeline h3 { font-size: 15px; margin-bottom: 14px; }
.ai-tl-item {
  display: flex; gap: 12px; padding: 8px 0; border-bottom: 1px solid var(--border);
  font-size: 13px; align-items: flex-start;
}
.ai-tl-item:last-child { border-bottom: none; }
.ai-tl-date { min-width: 60px; color: var(--text-light); font-weight: 600; flex-shrink: 0; }
.ai-tl-badge {
  display: inline-block; padding: 2px 8px; border-radius: 6px; font-size: 11px; font-weight: 700;
  flex-shrink: 0;
}
.ai-tl-badge.danger { background: #FEE2E2; color: #991B1B; }
.ai-tl-badge.warn   { background: #FEF3C7; color: #92400E; }
body.dark .ai-tl-badge.danger { background: #7F1D1D; color: #FCA5A5; }
body.dark .ai-tl-badge.warn   { background: #78350F; color: #FCD34D; }
.ai-tl-text { flex: 1; }

.ai-defect-summary { display: grid; grid-template-columns: repeat(2,1fr); gap: 10px; margin-bottom: 20px; }
.ai-defect-card {
  background: var(--card); border-radius: 10px; padding: 12px; border: 1px solid var(--border);
}
.ai-defect-card .ai-dc-name { font-weight: 700; font-size: 13px; margin-bottom: 4px; }
.ai-defect-card .ai-dc-val { font-size: 11px; color: var(--text-light); }
.ai-defect-card .ai-dc-bar { height: 6px; border-radius: 3px; background: var(--border); margin-top: 6px; overflow: hidden; }
.ai-defect-card .ai-dc-fill { height: 100%; border-radius: 3px; }

@media (max-width: 768px) {
  .ai-risk-badge { font-size: 17px; padding: 12px 18px; }
  .ai-kpi-grid { grid-template-columns: repeat(2,1fr); gap: 8px; }
  .ai-kpi-card .ai-kpi-val { font-size: 20px; }
  .ai-stat-grid { grid-template-columns: repeat(2,1fr); gap: 8px; }
  .ai-stat-card .ai-st-val { font-size: 16px; }
  .ai-warning-card { flex-wrap: wrap; }
  .ai-warning-card .ai-wc-spark { width: 80px; }
  .ai-defect-summary { grid-template-columns: 1fr; }
  .ai-item-row { font-size: 12px; }
}

/* ── 종합 품질 점수 게이지 ── */
.ai-gauge-section {
  display: flex; align-items: center; gap: 24px;
  background: var(--card); border-radius: 16px; border: 1px solid var(--border);
  padding: 24px; margin-bottom: 20px; box-shadow: 0 2px 12px rgba(0,0,0,.08);
}
.ai-gauge-wrap { flex-shrink: 0; width: 200px; text-align: center; }
.ai-gauge-wrap svg text { fill: var(--text); }
.ai-gauge-verdict { flex: 1; }
.ai-gauge-grade { font-size: 28px; font-weight: 900; margin-bottom: 8px; }
.ai-gauge-text { font-size: 16px; font-weight: 600; color: var(--text); margin-bottom: 6px; line-height: 1.5; }
.ai-gauge-sub { font-size: 12px; color: var(--text-light); }

/* ── 한눈에 보는 요약 ── */
.ai-summary-box {
  background: linear-gradient(135deg, #EFF6FF 0%, #F0FDF4 100%);
  border: 1px solid var(--border); border-radius: 16px;
  padding: 20px; margin-bottom: 20px;
}
body.dark .ai-summary-box { background: linear-gradient(135deg, #1E293B 0%, #1A2E1A 100%); }
.ai-summary-hero { display: flex; align-items: center; gap: 14px; margin-bottom: 16px; }
.ai-summary-icon { font-size: 40px; }
.ai-summary-main { font-size: 18px; line-height: 1.5; }
.ai-summary-stats { display: grid; grid-template-columns: repeat(4,1fr); gap: 12px; }
.ai-ss-item { text-align: center; background: var(--card); border-radius: 10px; padding: 12px 8px; border: 1px solid var(--border); }
.ai-ss-label { font-size: 11px; color: var(--text-light); display: block; margin-bottom: 4px; }
.ai-ss-val { font-size: 18px; font-weight: 800; display: block; }
.ai-ss-sub { font-size: 10px; color: var(--text-light); display: block; margin-top: 2px; }

/* ── 품질 건강 체크리스트 ── */
.ai-checklist-box {
  background: var(--card); border-radius: 12px; border: 1px solid var(--border);
  padding: 20px; margin-bottom: 20px;
}
.ai-checklist-box h3 { font-size: 15px; margin-bottom: 14px; }
.ai-checklist { display: flex; flex-direction: column; gap: 8px; }
.ai-check-item {
  display: flex; align-items: center; gap: 12px;
  padding: 12px 14px; border-radius: 10px;
  border: 1px solid var(--border); transition: background .15s;
}
.ai-check-item.pass { background: #F0FDF4; border-color: #BBF7D0; }
.ai-check-item.fail { background: #FEF2F2; border-color: #FECACA; }
body.dark .ai-check-item.pass { background: rgba(20,83,45,.2); border-color: rgba(74,222,128,.3); }
body.dark .ai-check-item.fail { background: rgba(127,29,29,.2); border-color: rgba(248,113,113,.3); }
.ai-check-icon { font-size: 20px; flex-shrink: 0; }
.ai-check-content { flex: 1; }
.ai-check-label { font-size: 14px; font-weight: 700; margin-bottom: 2px; }
.ai-check-detail { font-size: 12px; color: var(--text-light); line-height: 1.4; }
.ai-check-badge { font-size: 11px; color: var(--text-light); text-align: right; min-width: 120px; flex-shrink: 0; }

/* ── 간소화 통계 카드 ── */
.ai-simple-stat-grid { display: grid; grid-template-columns: repeat(3,1fr); gap: 12px; margin-bottom: 20px; }
.ai-simple-stat-card {
  background: var(--card); border-radius: 12px; border: 1px solid var(--border);
  padding: 18px 12px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,.06);
}
.ai-ssc-icon { font-size: 24px; margin-bottom: 6px; }
.ai-ssc-val { font-size: 26px; font-weight: 800; display: block; }
.ai-ssc-lbl { font-size: 12px; color: var(--text-light); margin-top: 2px; }
.ai-ssc-tip { font-size: 11px; color: var(--text-light); margin-top: 4px; padding: 3px 6px; background: var(--bg); border-radius: 6px; display: inline-block; }

/* ── 상세 분석 토글 ── */
.ai-expand-toggle {
  display: flex; align-items: center; justify-content: center; gap: 10px;
  background: var(--card); border: 2px dashed var(--border); border-radius: 10px;
  padding: 14px 20px; margin-bottom: 16px; cursor: pointer;
  font-weight: 700; font-size: 14px; transition: all .15s;
  -webkit-tap-highlight-color: transparent; user-select: none;
}
.ai-expand-toggle:hover { background: var(--bg); border-color: var(--primary); color: var(--primary); }
.ai-expand-hint { font-size: 12px; color: var(--text-light); font-weight: 400; }

@media (max-width: 768px) {
  .ai-gauge-section { flex-direction: column; gap: 12px; padding: 16px; text-align: center; }
  .ai-gauge-wrap { width: 160px; }
  .ai-gauge-grade { font-size: 22px; }
  .ai-gauge-text { font-size: 14px; }
  .ai-summary-stats { grid-template-columns: repeat(2,1fr); gap: 6px; }
  .ai-summary-main { font-size: 15px; }
  .ai-ss-val { font-size: 15px; }
  .ai-simple-stat-grid { grid-template-columns: repeat(3,1fr); gap: 8px; }
  .ai-ssc-val { font-size: 20px; }
  .ai-check-badge { display: none; }
}

/* ── TAB2: 요일별 불량률 패턴 ── */
.weekday-chart-box { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
@media (max-width: 768px) { .weekday-chart-box { grid-template-columns: 1fr; } }

/* ── TAB3: 품목 추세 배지 ── */
.trend-badge { display:inline-block; padding:2px 8px; border-radius:10px; font-size:11px; font-weight:700; margin-left:6px; vertical-align:middle; }
.trend-badge.up { background:#FEE2E2; color:#DC2626; }
.trend-badge.down { background:#D1FAE5; color:#16A34A; }
.trend-badge.stable { background:#F3F4F6; color:#6B7280; }
body.dark .trend-badge.up { background:#7F1D1D; color:#FCA5A5; }
body.dark .trend-badge.down { background:#064E3B; color:#6EE7B7; }
body.dark .trend-badge.stable { background:#374151; color:#9CA3AF; }

/* ── TAB6: 수율 목표/분포 ── */
.yield-target-summary { display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin-bottom:16px; }
.yield-target-card { background:var(--white); border:1px solid var(--border); border-radius:12px; padding:16px; text-align:center; }
body.dark .yield-target-card { background:var(--card-dark); }
.yield-target-card .ytc-label { font-size:12px; color:var(--text-light); margin-bottom:4px; }
.yield-target-card .ytc-value { font-size:28px; font-weight:800; }
.yield-target-card .ytc-sub { font-size:11px; color:var(--text-light); margin-top:4px; }
.yield-target-card.pass .ytc-value { color:#16A34A; }
.yield-target-card.fail .ytc-value { color:#DC2626; }
.yield-target-card.total .ytc-value { color:#2563EB; }
@media (max-width: 768px) { .yield-target-summary { grid-template-columns: 1fr; } }

/* ── 로딩 오버레이 ── */
.loading-overlay { position:fixed; inset:0; background:rgba(255,255,255,0.85); z-index:99999; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; }
body.dark .loading-overlay { background:rgba(15,23,42,0.9); }
.loading-spinner { width:48px; height:48px; border:4px solid var(--border); border-top-color:var(--primary); border-radius:50%; animation:spin 0.8s linear infinite; }
@keyframes spin { to { transform:rotate(360deg); } }
.loading-text { font-size:15px; font-weight:600; color:var(--text); }

/* ── 토스트 알림 ── */
.toast-container { position:fixed; top:20px; right:20px; z-index:100000; display:flex; flex-direction:column; gap:8px; pointer-events:none; }
.toast { pointer-events:auto; padding:12px 20px; border-radius:10px; font-size:13px; font-weight:500; color:#fff; box-shadow:0 4px 12px rgba(0,0,0,0.15); opacity:0; transform:translateX(60px); transition:all 0.3s ease; max-width:360px; line-height:1.4; }
.toast.show { opacity:1; transform:translateX(0); }
.toast.error { background:#DC2626; }
.toast.success { background:#16A34A; }
.toast.warn { background:#F59E0B; color:#1F2937; }
.toast.info { background:#2563EB; }
@media (max-width: 768px) { .toast-container { top:10px; right:10px; left:10px; } .toast { max-width:100%; } }

/* ── 필터 데이터 범위 라벨 ── */
.filter-range-label { font-size:11px; color:var(--text-light); margin-top:2px; margin-bottom:6px; }

/* ── 정렬 표시 ── */
th[data-sort="asc"] { background:rgba(37,99,235,0.08); }
th[data-sort="desc"] { background:rgba(37,99,235,0.08); }
body.dark th[data-sort="asc"], body.dark th[data-sort="desc"] { background:rgba(96,165,250,0.12); }

/* ── 품목 필터 버튼 ── */
.item-filter-actions { display:flex; gap:6px; margin-bottom:4px; }
.item-filter-actions button { flex:1; padding:6px; font-size:11px; border:1px solid var(--border); border-radius:6px; background:var(--white); cursor:pointer; font-weight:600; color:var(--text); }
.item-filter-actions button:hover { background:var(--primary); color:#fff; }
body.dark .item-filter-actions button { background:var(--card-dark); border-color:#475569; }

/* ── 탭 서브필터 바 ── */
.tab-subfilter {
  display: flex; align-items: center; gap: 6px; flex-wrap: nowrap;
  background: var(--bg); border: 1px solid var(--border);
  border-radius: 8px; padding: 6px 12px; margin-bottom: 12px; font-size: 13px;
  overflow: hidden;
}
.tab-subfilter input[type="date"] {
  border: 1px solid var(--border); border-radius: 6px;
  padding: 3px 6px; font-size: 12px; color: var(--text); background: var(--card);
  width: 122px; flex-shrink: 0;
}
.tab-subfilter-label { font-weight: 600; color: var(--text); white-space: nowrap; font-size: 12px; flex-shrink: 0; }
.tab-subfilter-info  { font-size: 11px; color: var(--text-light); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
body.dark .tab-subfilter { background: #1e293b; border-color: #475569; }
body.dark .tab-subfilter input[type="date"] { background: #1e293b; color: #e2e8f0; border-color: #475569; }

/* ── 인쇄 스타일 (주간 보고서 전용) ── */
@media print {
  @page { size: A4 portrait; margin: 10mm 12mm; }

  /* ① 전체 레이아웃 블록 초기화 */
  html, body {
    display: block !important;
    background: #fff !important;
    min-height: auto !important;
    width: 100% !important;
    overflow: visible !important;
    font-size: 11pt !important;
  }
  body::before, body::after { display: none !important; }

  /* ② UI 크롬 전체 숨기기 */
  .sidebar, .menu-toggle, .dark-toggle, .sidebar-overlay,
  #toastContainer, .loading-overlay, .mobile-analyze-fab,
  .header-bar, #placeholder, #tabsBar, #tabsMobile,
  #tab1, #tab2, #tab3, #tab4, #tab5,
  #tab6, #tab7, #tab8, #tab9,
  #weekBtnContainer,
  .tab-subfilter,
  #tab11 > .chart-box > div:first-child,
  #tab11 .btn,
  #weeklyReportText { display: none !important; }

  /* ③ 메인 영역: 전체 너비 */
  .main, #mainArea, .content-area, #dashboard {
    display: block !important;
    width: 100% !important;
    max-width: none !important;
    margin: 0 !important;
    padding: 0 !important;
    box-shadow: none !important;
    overflow: visible !important;
  }

  /* ④ Tab 11: 화면 전체 차지 */
  #tab11 {
    display: block !important;
    width: 100% !important;
    padding: 0 !important;
    margin: 0 !important;
    overflow: visible !important;
  }
  #tab11 .chart-box {
    background: #fff !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    margin: 0 !important;
    border-radius: 0 !important;
    overflow: visible !important;
  }
  #weeklyReportArea {
    width: 100% !important;
    overflow: visible !important;
  }

  /* ⑤ 인쇄 색상 강제 유지 */
  *, #tab11, #tab11 * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
    color-adjust: exact !important;
  }

  /* ⑥ CSS 변수 폴백 */
  #tab11, #weeklyReportArea {
    --white: #ffffff; --bg: #f3f4f6; --bg-dark: #1e293b;
    --text: #1f2937; --text-light: #6b7280;
    --border: #e5e7eb; --primary: #2563eb;
    --card: #ffffff; --gray: #6b7280;
  }

  /* ⑦ 차트 크기 — Plotly SVG가 잘리지 않도록 */
  #chartWeeklyDefect,
  #chartMonthlyPerf { height: 280px !important; min-height: 280px !important; }
  #chartWeeklyDefect .js-plotly-plot,
  #chartMonthlyPerf .js-plotly-plot,
  #chartWeeklyDefect .main-svg,
  #chartMonthlyPerf .main-svg { width: 100% !important; }

  /* ⑧ 스크롤 영역 해제 — 잘림 방지 */
  div[style*="overflow-x:auto"],
  div[style*="overflow-x: auto"] {
    overflow: visible !important;
    overflow-x: visible !important;
  }

  /* ⑨ 페이지 나눔 규칙 */
  /* 차트 박스 */
  #weeklyReportArea > div { page-break-inside: avoid; }
  /* 차트 2열 그리드 */
  #weeklyReportArea > div[style*="grid-template-columns:1fr 1fr"] { page-break-inside: avoid; }
  /* 일별·품목별 테이블은 페이지 넘어가도 허용 */
  table { page-break-inside: auto; border-collapse: collapse !important; width: 100% !important; }
  tr { page-break-inside: avoid; }
  thead { display: table-header-group; }
  tfoot { display: table-footer-group; }

  /* ⑩ 폰트·여백 정리 */
  #weeklyReportArea { font-size: 10pt !important; }
  #weeklyReportArea h3 { font-size: 13pt !important; }
  #weeklyReportArea table { font-size: 9pt !important; }
  #weeklyReportArea td, #weeklyReportArea th { padding: 5px 8px !important; }

  /* ⑪ 보고서 헤더 (파란 배너): 배경색 유지 */
  #weeklyReportArea > div > div:first-child {
    background: #2563eb !important;
    color: #fff !important;
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  /* ⑫ 링크/버튼 밑줄 제거 */
  a { text-decoration: none !important; color: inherit !important; }
  button { display: none !important; }
}
</style>
</head>
<body>
<div class="toast-container" id="toastContainer"></div>

<!-- PDF 내보내기 탭 선택 모달 -->
<div id="pdfExportModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.55);z-index:9999;align-items:center;justify-content:center">
  <div style="background:#fff;border-radius:14px;padding:28px 28px 20px;width:460px;max-width:92vw;max-height:88vh;overflow-y:auto;box-shadow:0 20px 60px rgba(0,0,0,.3)">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:18px">
      <div>
        <div style="font-size:18px;font-weight:800;color:#1e293b">📄 PDF 내보내기</div>
        <div style="font-size:12px;color:#6b7280;margin-top:3px">내보낼 탭을 선택하세요</div>
      </div>
      <button onclick="$('pdfExportModal').style.display='none'" style="background:none;border:none;font-size:20px;cursor:pointer;color:#6b7280;line-height:1">✕</button>
    </div>
    <div style="display:flex;gap:8px;margin-bottom:14px">
      <button onclick="document.querySelectorAll('#pdfTabList input').forEach(c=>c.checked=true)" style="font-size:12px;padding:4px 10px;border:1px solid #e5e7eb;border-radius:6px;background:#f9fafb;cursor:pointer">전체 선택</button>
      <button onclick="document.querySelectorAll('#pdfTabList input').forEach(c=>c.checked=false)" style="font-size:12px;padding:4px 10px;border:1px solid #e5e7eb;border-radius:6px;background:#f9fafb;cursor:pointer">전체 해제</button>
    </div>
    <div id="pdfTabList" style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-bottom:20px"></div>
    <div id="pdfExportProgress" style="display:none;margin-bottom:14px">
      <div style="height:6px;background:#e5e7eb;border-radius:3px;overflow:hidden">
        <div id="pdfProgressBar" style="height:100%;background:#2563eb;width:0%;transition:width .3s;border-radius:3px"></div>
      </div>
      <div id="pdfProgressText" style="font-size:12px;color:#6b7280;margin-top:6px;text-align:center"></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button onclick="$('pdfExportModal').style.display='none'" style="padding:9px 18px;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb;cursor:pointer;font-size:14px">취소</button>
      <button id="btnStartPdfExport" onclick="startPdfExport()" style="padding:9px 22px;border:none;border-radius:8px;background:#2563eb;color:#fff;cursor:pointer;font-size:14px;font-weight:700">📥 내보내기</button>
    </div>
  </div>
</div>

<!-- 햄버거 토글 -->
<button class="menu-toggle" id="menuToggle" aria-label="메뉴 열기">&#9776;</button>
<!-- 다크모드 토글 -->
<button class="dark-toggle" id="darkToggle" aria-label="다크모드 전환">&#9790;</button>

<!-- 오버레이 -->
<div class="sidebar-overlay" id="sidebarOverlay"></div>

<!-- ===== 사이드바 ===== -->
<aside class="sidebar" id="sidebar">
  <h2>남도금형 스마트 품질</h2>

  <div>
    <label>엑셀 파일 업로드</label>
    <div class="file-drop" id="fileDrop">
      <div style="font-size:28px;margin-bottom:6px;">&#128194;</div>
      탭하여 엑셀 파일 업로드
      <input type="file" id="fileInput" accept=".xlsx,.xls" multiple>
    </div>
  </div>

  <div id="sheetArea" style="display:none">
    <label>시트 선택</label>
    <select id="sheetSelect"></select>
  </div>

  <div id="mappingArea" style="display:none">
    <h3>컬럼 매핑</h3>
    <div id="mappingStatus"></div>
    <div id="mappingFields"></div>
  </div>

  <div id="analyzeArea">
    <button class="btn btn-primary" id="btnAnalyze">분석 시작</button>
  </div>

  <div id="filterArea">
    <hr class="section-divider">
    <h3>필터</h3>
    <label>시작일</label>
    <input type="date" id="filterStart">
    <label style="margin-top:8px">종료일</label>
    <input type="date" id="filterEnd">
    <div class="filter-range-label" id="filterDateRange">데이터를 업로드하면 범위가 표시됩니다</div>

    <label style="margin-top:10px">품목 선택</label>
    <div id="itemFilterWrap"></div>

    <label style="margin-top:10px">🎯 목표 불량률</label>
    <div class="slider-wrap">
      <input type="range" id="targetDefectRate" min="0.1" max="5" step="0.1" value="0.8">
      <input type="number" class="val-input" id="targetDefectInput" min="0.1" max="5" step="0.1" value="0.8">
      <span style="font-weight:700;color:var(--danger);font-size:14px">%</span>
    </div>
    <button class="btn btn-primary" id="btnApplyFilter" style="margin-top:12px">필터 적용</button>
  </div>
</aside>

<!-- ===== 메인 ===== -->
<div class="main" id="mainArea">
  <div class="header-bar">
    <div style="display:flex;align-items:center;gap:14px">
      <img src="logo-color.png" alt="남도금형" style="height:48px" class="header-logo">
      <h1 style="margin-bottom:0">남도금형 스마트 품질 모니터링</h1>
    </div>
    <div class="header-info">
      <div class="header-author">품질분석 담당 김준희 차장</div>
      <div id="lastAnalysisDate"></div>
    </div>
  </div>

  <div id="placeholder" class="placeholder" onclick="if(window.innerWidth<=768){openSidebar();}">
    <div class="icon">&#128202;</div>
    <span class="placeholder-pc">엑셀 파일을 업로드하고 분석을 시작하세요.</span>
    <span class="placeholder-mobile">여기를 탭하여 엑셀 파일을 업로드하세요.<br><small style="color:var(--primary);font-weight:600;margin-top:8px;display:inline-block;">또는 좌측 상단 ☰ 메뉴를 탭하세요</small></span>
  </div>

  <div id="dashboard" style="display:none">
    <!-- PC 탭바 -->
    <div class="tabs" id="tabsBar">
      <button class="tab-btn active" data-tab="tab1">전체 요약</button>
      <button class="tab-btn" data-tab="tab2">일자별 분석</button>
      <button class="tab-btn" data-tab="tab3">품목별 분석</button>
      <button class="tab-btn" data-tab="tab4">알림 & 리포트</button>
      <button class="tab-btn" data-tab="tab5">SPC 관리도</button>
      <button class="tab-btn" data-tab="tab6">수율 분석</button>
      <button class="tab-btn" data-tab="tab7">기간 비교</button>
      <button class="tab-btn" data-tab="tab8">품목 심층분석</button>
      <button class="tab-btn" data-tab="tab9">AI 품질진단</button>
      <button class="tab-btn" data-tab="tab11">주간 보고</button>
    </div>
    <!-- 모바일 탭 그리드 -->
    <div class="tabs-mobile-grid" id="tabsMobile">
      <button class="tab-m-btn active" data-tab="tab1">📊 전체 요약</button>
      <button class="tab-m-btn" data-tab="tab2">📅 일자별</button>
      <button class="tab-m-btn" data-tab="tab3">📦 품목별</button>
      <button class="tab-m-btn" data-tab="tab4">🔔 알림</button>
      <button class="tab-m-btn" data-tab="tab5">📈 SPC</button>
      <button class="tab-m-btn" data-tab="tab6">✅ 수율</button>
      <button class="tab-m-btn" data-tab="tab7">🔄 기간비교</button>
      <button class="tab-m-btn" data-tab="tab8">🔍 심층분석</button>
      <button class="tab-m-btn" data-tab="tab9">🤖 AI진단</button>
      <button class="tab-m-btn" data-tab="tab11">📋 주간보고</button>
    </div>

    <div id="tab1" class="tab-content active"></div>
    <div id="tab2" class="tab-content"></div>
    <div id="tab3" class="tab-content"></div>
    <div id="tab4" class="tab-content"></div>
    <div id="tab5" class="tab-content"></div>
    <div id="tab6" class="tab-content"></div>
    <div id="tab7" class="tab-content"></div>
    <div id="tab8" class="tab-content"></div>
    <div id="tab9" class="tab-content"></div>
    <div id="tab11" class="tab-content"></div>
  </div>
</div>

<!-- 모바일 분석시작 플로팅 버튼 -->
<button class="mobile-analyze-fab" id="mobileAnalyzeFab" onclick="document.getElementById('btnAnalyze').click(); this.classList.remove('show');">
  ▶ 분석 시작
</button>

<!-- 하단 고정 액션바 (모바일) -->
<div class="bottom-bar" id="bottomBar">
  <button onclick="openSidebar()"><span class="bar-icon">⚙</span>필터</button>
  <button onclick="document.getElementById('btnExportExcel')&&document.getElementById('btnExportExcel').click()"><span class="bar-icon">📥</span>Excel</button>
  <button onclick="document.getElementById('btnExportPDF')&&document.getElementById('btnExportPDF').click()"><span class="bar-icon">📄</span>PDF</button>
  <button onclick="window.scrollTo({top:0,behavior:'smooth'})"><span class="bar-icon">↑</span>상단</button>
</div>

<!-- 드릴다운 모달 (모바일) -->
<div class="drill-modal" id="drillModal">
  <button class="drill-modal-close" id="drillModalClose">✕</button>
  <div id="drillModalContent"></div>
</div>

<script>
/* ================================================================
   전역 상태
   ================================================================ */
let workbook = null;
let rawData = [];
let columns = [];
let mapping = null;
let cleanedData = [];
let defectCols = [];
let selectedFilterItems = new Set();
let uploadedFiles = []; // 다중 파일 관리

const isMobile = () => window.innerWidth <= 768;

/* ================================================================
   유틸
   ================================================================ */
const $ = id => document.getElementById(id);
const fmt = n => Number(n).toLocaleString('ko-KR');
const pct = (n, d=2) => Number(n).toFixed(d) + '%';
const calcDefectRate = (bad, prod) => prod > 0 ? bad / prod : 0;
const calcPPM = (bad, prod) => calcDefectRate(bad, prod) * 1000000;

const TARGET_DEFECT_RATE_KEY = 'ndm_targetDefectRate';
const DEFAULT_TARGET_DEFECT_RATE = 0.8;
function loadTargetDefectRate() {
  try { const v = localStorage.getItem(TARGET_DEFECT_RATE_KEY); return v !== null ? Number(v) : DEFAULT_TARGET_DEFECT_RATE; } catch(e) { return DEFAULT_TARGET_DEFECT_RATE; }
}
function saveTargetDefectRate(val) {
  try { localStorage.setItem(TARGET_DEFECT_RATE_KEY, val); } catch(e) {}
}
let targetDefectRate = loadTargetDefectRate();

const AI_RISK_SETTINGS_KEY = 'ndm_aiRiskSettings';
const AI_RISK_HISTORY_KEY = 'ndm_aiRiskSettingsHistory';
const DEFAULT_AI_RISK_SETTINGS = Object.freeze({
  dangerRatePct: 10,
  warnRatePct: 5,
  watchRatePct: 3,
  dangerScoreFloor: 70,
  warnScoreFloor: 45,
  gradeDangerCut: 70,
  gradeWarnCut: 40,
  volMinSamples: 5
});

// ── 로딩 오버레이 ──
function showLoading(msg) {
  let el = document.getElementById('loadingOverlay');
  if (!el) {
    el = document.createElement('div');
    el.id = 'loadingOverlay';
    el.className = 'loading-overlay';
    document.body.appendChild(el);
  }
  el.innerHTML = `<div class="loading-spinner"></div><div class="loading-text">${msg || '분석 중...'}</div>`;
  el.style.display = 'flex';
}
function hideLoading() {
  const el = document.getElementById('loadingOverlay');
  if (el) el.style.display = 'none';
}

// ── 토스트 알림 ──
function showToast(message, type, duration) {
  type = type || 'info';
  duration = duration || 4000;
  const container = $('toastContainer');
  const toast = document.createElement('div');
  toast.className = 'toast ' + type;
  toast.textContent = message;
  container.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('show'));
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

function sanitizeAiRiskSettings(raw) {
  const n = (v, d) => {
    const x = Number(v);
    return Number.isFinite(x) ? x : d;
  };
  const next = {
    dangerRatePct: Math.max(0.1, n(raw?.dangerRatePct, DEFAULT_AI_RISK_SETTINGS.dangerRatePct)),
    warnRatePct: Math.max(0, n(raw?.warnRatePct, DEFAULT_AI_RISK_SETTINGS.warnRatePct)),
    watchRatePct: Math.max(0, n(raw?.watchRatePct, DEFAULT_AI_RISK_SETTINGS.watchRatePct)),
    dangerScoreFloor: Math.min(100, Math.max(0, n(raw?.dangerScoreFloor, DEFAULT_AI_RISK_SETTINGS.dangerScoreFloor))),
    warnScoreFloor: Math.min(100, Math.max(0, n(raw?.warnScoreFloor, DEFAULT_AI_RISK_SETTINGS.warnScoreFloor))),
    gradeDangerCut: Math.min(100, Math.max(0, n(raw?.gradeDangerCut, DEFAULT_AI_RISK_SETTINGS.gradeDangerCut))),
    gradeWarnCut: Math.min(100, Math.max(0, n(raw?.gradeWarnCut, DEFAULT_AI_RISK_SETTINGS.gradeWarnCut))),
    volMinSamples: Math.max(3, Math.round(n(raw?.volMinSamples, DEFAULT_AI_RISK_SETTINGS.volMinSamples)))
  };
  if (next.warnRatePct > next.dangerRatePct) next.warnRatePct = next.dangerRatePct;
  if (next.watchRatePct > next.warnRatePct) next.watchRatePct = next.warnRatePct;
  if (next.warnScoreFloor > next.dangerScoreFloor) next.warnScoreFloor = next.dangerScoreFloor;
  if (next.gradeWarnCut > next.gradeDangerCut) next.gradeWarnCut = next.gradeDangerCut;
  return next;
}

function loadAiRiskSettings() {
  try {
    const saved = localStorage.getItem(AI_RISK_SETTINGS_KEY);
    if (!saved) return sanitizeAiRiskSettings(DEFAULT_AI_RISK_SETTINGS);
    return sanitizeAiRiskSettings(JSON.parse(saved));
  } catch (e) {
    return sanitizeAiRiskSettings(DEFAULT_AI_RISK_SETTINGS);
  }
}

function appendAiRiskSettingsHistory(settings) {
  try {
    const prev = JSON.parse(localStorage.getItem(AI_RISK_HISTORY_KEY) || '[]');
    const next = [{ at: new Date().toISOString(), settings }, ...prev].slice(0, 20);
    localStorage.setItem(AI_RISK_HISTORY_KEY, JSON.stringify(next));
  } catch (e) {}
}

function getAiRiskSettingsLastChangedLabel() {
  try {
    const hist = JSON.parse(localStorage.getItem(AI_RISK_HISTORY_KEY) || '[]');
    if (!hist.length || !hist[0].at) return 'default';
    const d = new Date(hist[0].at);
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
  } catch (e) {
    return 'default';
  }
}

function saveAiRiskSettings(settings) {
  aiRiskSettings = sanitizeAiRiskSettings(settings);
  try { localStorage.setItem(AI_RISK_SETTINGS_KEY, JSON.stringify(aiRiskSettings)); } catch (e) {}
  appendAiRiskSettingsHistory(aiRiskSettings);
}

function getRiskRuleLabel(forcedRule) {
  if (forcedRule === 'danger_rate_gate') return 'AbsRate Danger Gate';
  if (forcedRule === 'warn_rate_gate') return 'AbsRate Warn Gate';
  return 'Base Score';
}

let aiRiskSettings = loadAiRiskSettings();
let aiRenderContext = null;

function rerenderAIDiagnosis() {
  if (!aiRenderContext) return;
  renderAIDiagnosis(aiRenderContext.kpi, aiRenderContext.byDate, aiRenderContext.byItem, aiRenderContext.filtered);
}

function dateStr(v) {
  if (v instanceof Date) {
    // toISOString()은 UTC 기준이라 KST에서 하루 밀림 → 로컬 시간 메서드 사용
    return v.getFullYear() + '-' +
      String(v.getMonth() + 1).padStart(2, '0') + '-' +
      String(v.getDate()).padStart(2, '0');
  }
  if (typeof v === 'number') {
    const d = new Date((v - 25569) * 86400000);
    return d.getUTCFullYear() + '-' +
      String(d.getUTCMonth() + 1).padStart(2, '0') + '-' +
      String(d.getUTCDate()).padStart(2, '0');
  }
  return String(v).slice(0,10);
}

/* 한글 날짜 포맷 */
function dateKR(isoStr) {
  // "2024-03-15" → "3/15"
  const parts = isoStr.split('-');
  return Number(parts[1]) + '/' + Number(parts[2]);
}
function dateKRFull(isoStr) {
  // "2024-03-15" → "2024년 3월 15일"
  const parts = isoStr.split('-');
  return parts[0] + '년 ' + Number(parts[1]) + '월 ' + Number(parts[2]) + '일';
}
function dateKRMonth(isoStr) {
  const parts = isoStr.split('-');
  return parts[0] + '년 ' + Number(parts[1]) + '월';
}
function weekLabel(isoStr) {
  const d = new Date(isoStr + 'T00:00:00');
  const dow = (d.getDay() + 6) % 7; // 0=월 ~ 6=일
  const mon = new Date(d);
  mon.setDate(d.getDate() - dow); // 해당 주 월요일
  return mon.getFullYear() + '년 ' + (mon.getMonth()+1) + '/' + mon.getDate() + ' 주';
}

function toDate(v) {
  if (v instanceof Date) return v;
  if (typeof v === 'number') return new Date((v - 25569) * 86400000);
  return new Date(v);
}

function toNum(v) {
  if (v == null || v === '') return 0;
  const n = Number(v);
  return isNaN(n) ? 0 : n;
}

/* ================================================================
   다크모드 토글
   ================================================================ */
const darkToggle = $('darkToggle');
function setDark(on) {
  document.body.classList.toggle('dark', on);
  darkToggle.textContent = on ? '☀' : '☽';
  localStorage.setItem('darkMode', on ? '1' : '0');
  // Plotly 차트 배경 업데이트
  document.querySelectorAll('.js-plotly-plot').forEach(p => {
    Plotly.relayout(p, {
      paper_bgcolor: on ? '#1F2937' : '#FFFFFF',
      plot_bgcolor: on ? '#1F2937' : '#FFFFFF',
      font: { color: on ? '#F9FAFB' : '#1F2937' }
    });
  });
}
darkToggle.addEventListener('click', () => setDark(!document.body.classList.contains('dark')));
if (localStorage.getItem('darkMode') === '1' || (!localStorage.getItem('darkMode') && window.matchMedia('(prefers-color-scheme:dark)').matches)) {
  setDark(true);
}

/* ================================================================
   테이블 정렬/검색 전역 함수
   ================================================================ */
function sortTable(tableId, colIdx) {
  const table = document.getElementById(tableId);
  if (!table) return;
  const tbody = table.querySelector('tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  const th = table.querySelectorAll('th')[colIdx];
  const asc = th.dataset.sort !== 'asc';
  table.querySelectorAll('th').forEach(h => {
    h.dataset.sort = '';
    h.textContent = h.textContent.replace(/ [↕↑↓]$/, '') + ' ↕';
  });
  th.dataset.sort = asc ? 'asc' : 'desc';
  th.textContent = th.textContent.replace(/ [↕↑↓]$/, '') + (asc ? ' ↑' : ' ↓');
  rows.sort((a, b) => {
    // 셀의 첫 번째 텍스트 노드만 추출 (증감 표시 span 제외)
    let va = getCellSortValue(a.cells[colIdx]);
    let vb = getCellSortValue(b.cells[colIdx]);

    // 1) 일별 날짜: YYYY-MM-DD
    if (/^\d{4}-\d{2}-\d{2}/.test(va) && /^\d{4}-\d{2}-\d{2}/.test(vb))
      return asc ? va.localeCompare(vb) : vb.localeCompare(va);

    // 2) 월간: YYYY-MM
    if (/^\d{4}-\d{2}$/.test(va) && /^\d{4}-\d{2}$/.test(vb))
      return asc ? va.localeCompare(vb) : vb.localeCompare(va);

    // 3) 주간: YYYY년 N주차 → 숫자로 변환 (YYYY * 100 + 주차)
    const wkA = va.match(/^(\d{4})년\s*(\d+)주차$/);
    const wkB = vb.match(/^(\d{4})년\s*(\d+)주차$/);
    if (wkA && wkB) {
      const nA = parseInt(wkA[1]) * 100 + parseInt(wkA[2]);
      const nB = parseInt(wkB[1]) * 100 + parseInt(wkB[2]);
      return asc ? nA - nB : nB - nA;
    }

    // 4) 숫자
    const cleanA = va.replace(/[,%▲▼△▽↑↓\s]/g, '');
    const cleanB = vb.replace(/[,%▲▼△▽↑↓\s]/g, '');
    const na = parseFloat(cleanA), nb = parseFloat(cleanB);
    if (!isNaN(na) && !isNaN(nb)) return asc ? na - nb : nb - na;

    // 5) 문자열
    return asc ? va.localeCompare(vb, 'ko') : vb.localeCompare(va, 'ko');
  });
  rows.forEach(r => tbody.appendChild(r));
}
function getCellSortValue(cell) {
  // 첫 번째 텍스트 노드 또는 직접 텍스트만 추출 (span 증감 표시 제외)
  for (const node of cell.childNodes) {
    if (node.nodeType === 3) { // TEXT_NODE
      const t = node.textContent.trim();
      if (t) return t;
    }
  }
  return cell.textContent.trim();
}
function filterTable(tableId, query) {
  const table = document.getElementById(tableId);
  if (!table) return;
  const q = query.toLowerCase();
  table.querySelectorAll('tbody tr').forEach(row => {
    const text = row.textContent.toLowerCase();
    row.style.display = text.includes(q) ? '' : 'none';
  });
}

/* ================================================================
   사이드바 토글 (모바일)
   ================================================================ */
const menuToggle = $('menuToggle');
const sidebar = $('sidebar');
const overlay = $('sidebarOverlay');

function openSidebar() {
  sidebar.classList.add('open');
  overlay.classList.add('open');
  document.body.style.overflow = 'hidden';
}
function closeSidebar() {
  sidebar.classList.remove('open');
  overlay.classList.remove('open');
  document.body.style.overflow = '';
}

menuToggle.addEventListener('click', () => {
  sidebar.classList.contains('open') ? closeSidebar() : openSidebar();
});
overlay.addEventListener('click', closeSidebar);

/* ================================================================
   파일 업로드
   ================================================================ */
const fileDrop = $('fileDrop');
const fileInput = $('fileInput');

fileDrop.addEventListener('click', () => fileInput.click());
fileDrop.addEventListener('dragover', e => { e.preventDefault(); fileDrop.classList.add('dragover'); });
fileDrop.addEventListener('dragleave', () => fileDrop.classList.remove('dragover'));
fileDrop.addEventListener('drop', e => {
  e.preventDefault();
  fileDrop.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', e => {
  if (e.target.files.length) handleFiles(e.target.files);
});

function handleFiles(files) {
  // 기존 차트 메모리 정리
  document.querySelectorAll('#dashboard .js-plotly-plot').forEach(p => {
    try { Plotly.purge(p); } catch(e) {}
  });
  // 대시보드 초기화
  $('dashboard').style.display = 'none';
  $('placeholder').style.display = '';
  const fileArr = Array.from(files);
  uploadedFiles = uploadedFiles.concat(fileArr);
  let tagsHtml = uploadedFiles.map(f => `<span class="file-tag">${f.name} (${(f.size/1024).toFixed(1)}KB)</span>`).join('');
  fileDrop.innerHTML = `<div style="color:var(--primary);font-weight:600;font-size:13px">${uploadedFiles.length}개 파일 업로드됨</div><div class="file-list">${tagsHtml}</div>`;
  // 마지막 파일의 workbook 사용 (시트 선택용)
  const lastFile = fileArr[fileArr.length - 1];
  const reader = new FileReader();
  reader.onload = e => {
    const data = new Uint8Array(e.target.result);
    workbook = XLSX.read(data, { type: 'array', cellDates: true });
    populateSheets();
  };
  reader.readAsArrayBuffer(lastFile);
}

function handleFile(file) { handleFiles([file]); }

function populateSheets() {
  const sel = $('sheetSelect');
  sel.innerHTML = '';
  workbook.SheetNames.forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    sel.appendChild(opt);
  });
  $('sheetArea').style.display = '';
  sel.addEventListener('change', loadSheet);
  loadSheet();
}

/* ================================================================
   시트 로딩 + 헤더 감지
   ================================================================ */
function loadSheet() {
  const name = $('sheetSelect').value;
  const ws = workbook.Sheets[name];
  const allRows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: null, raw: false, dateNF: 'yyyy-mm-dd' });

  let bestRow = 0, bestCount = 0;
  for (let i = 0; i < Math.min(10, allRows.length); i++) {
    const row = allRows[i] || [];
    let strCount = 0;
    for (const v of row) {
      if (v != null && String(v).trim() !== '' && isNaN(Number(v))) strCount++;
    }
    if (strCount > bestCount) { bestCount = strCount; bestRow = i; }
  }

  const headerRow = allRows[bestRow] || [];
  columns = headerRow.map((v, i) => {
    const s = v != null ? String(v).trim() : '';
    return s || `Column_${i}`;
  });

  const validIdx = [];
  const validCols = [];
  columns.forEach((c, i) => {
    if (c && !c.match(/^Column_\d+$/) && c.trim()) {
      validIdx.push(i);
      validCols.push(c);
    }
  });

  rawData = [];
  for (let r = bestRow + 1; r < allRows.length; r++) {
    const row = allRows[r];
    if (!row) continue;
    const obj = {};
    let hasVal = false;
    validIdx.forEach((ci, j) => {
      obj[validCols[j]] = row[ci] != null ? row[ci] : null;
      if (row[ci] != null && String(row[ci]).trim() !== '') hasVal = true;
    });
    if (hasVal) rawData.push(obj);
  }
  columns = validCols;

  autoDetectMapping();
}

/* ================================================================
   자동 컬럼 매핑
   ================================================================ */
const KEYWORDS = {
  '생산일자': ['생산일자','일자','날짜','date'],
  '품명':     ['품명','품목','제품명','item','product'],
  '생산수량': ['생산수량','생산량','계획수량','production'],
  '양품수량': ['양품수량','양품','good'],
  '불량수량': ['불량수량','불량','defect','bad'],
};

function autoDetectMapping() {
  mapping = {};
  const used = new Set();

  for (const [std, kwds] of Object.entries(KEYWORDS)) {
    for (const col of columns) {
      if (used.has(col)) continue;
      const cl = col.toLowerCase();
      if (kwds.some(k => cl.includes(k))) {
        mapping[std] = col;
        used.add(col);
        break;
      }
    }
  }

  const badIdx = columns.indexOf(mapping['불량수량']);
  const dCols = [];
  if (badIdx >= 0) {
    for (let i = badIdx + 1; i < columns.length; i++) {
      const col = columns[i];
      if (used.has(col)) continue;
      if (col.includes('불량률') || col.toUpperCase().includes('PPM')) continue;
      const isNum = rawData.slice(0, 10).some(r => {
        const v = r[col];
        return v != null && !isNaN(Number(v));
      });
      if (isNum) dCols.push(col);
    }
  }
  mapping['불량유형'] = dCols;

  renderMapping();
}

function renderMapping() {
  const status = $('mappingStatus');
  const fields = $('mappingFields');
  const stdKeys = ['생산일자','품명','생산수량','양품수량','불량수량'];
  const allFound = stdKeys.every(k => mapping[k]);

  if (allFound) {
    status.innerHTML = '<div class="info-box success">자동 매핑 완료!</div>';
  } else {
    status.innerHTML = '<div class="info-box warn">일부 컬럼을 수동 매핑해주세요.</div>';
  }

  let html = '';
  for (const std of stdKeys) {
    html += `<div style="margin-top:6px"><label>${std}</label><select id="map_${std}">`;
    html += `<option value="">(선택 안함)</option>`;
    for (const col of columns) {
      const sel = mapping[std] === col ? ' selected' : '';
      html += `<option value="${col}"${sel}>${col}</option>`;
    }
    html += `</select></div>`;
  }
  // 불량유형 체크박스 (모바일 친화)
  html += `<div style="margin-top:8px"><label>불량유형 컬럼</label>
    <div style="max-height:150px;overflow-y:auto;border:1px solid var(--border);border-radius:8px;padding:8px;">`;
  for (const col of columns) {
    if (stdKeys.some(k => mapping[k] === col)) continue;
    html += `<label style="display:flex;align-items:center;gap:6px;padding:4px 0;font-weight:400;cursor:pointer">
      <input type="checkbox" class="defect-chk" value="${col}" checked style="width:18px;height:18px"> ${col}
    </label>`;
  }
  html += `</div></div>`;

  fields.innerHTML = html;

  for (const std of stdKeys) {
    document.getElementById(`map_${std}`).addEventListener('change', e => {
      mapping[std] = e.target.value || undefined;
    });
  }

  $('mappingArea').style.display = '';
  $('analyzeArea').style.display = '';

  // 모바일에서 분석시작 플로팅 버튼 표시
  if (isMobile()) {
    $('mobileAnalyzeFab').classList.add('show');
  }
}

/* ================================================================
   데이터 정제
   ================================================================ */
function cleanData(data) {
  // 체크박스에서 불량유형 읽기
  const checks = document.querySelectorAll('.defect-chk');
  defectCols = Array.from(checks).filter(c => c.checked).map(c => c.value);
  mapping['불량유형'] = defectCols;

  const m = mapping;
  const result = [];

  for (const row of data) {
    const d = toDate(row[m['생산일자']]);
    if (isNaN(d.getTime())) continue;

    const prod = toNum(row[m['생산수량']]);
    if (prod <= 0) continue;

    const obj = {
      생산일자: d,
      품명: String(row[m['품명']] || '').trim(),
      생산수량: prod,
      양품수량: toNum(row[m['양품수량']]),
      불량수량: toNum(row[m['불량수량']]),
    };
    for (const dc of defectCols) {
      obj[dc] = toNum(row[dc]);
    }
    obj['불량률'] = calcDefectRate(obj.불량수량, obj.생산수량);
    obj['PPM'] = calcPPM(obj.불량수량, obj.생산수량);
    result.push(obj);
  }
  return result;
}

/* ================================================================
   집계 함수
   ================================================================ */
function calcKPI(data) {
  let prod=0, good=0, bad=0;
  const items = new Set(), dates = new Set();
  for (const r of data) {
    prod += r.생산수량; good += r.양품수량; bad += r.불량수량;
    items.add(r.품명);
    dates.add(dateStr(r.생산일자));
  }
  return {
    총생산수량: prod, 총양품수량: good, 총불량수량: bad,
    불량률: prod ? (bad/prod*100) : 0,
    PPM: calcPPM(bad, prod),
    품목수: items.size, 생산일수: dates.size,
  };
}

function aggByDate(data) {
  const map = new Map();
  for (const r of data) {
    const key = dateStr(r.생산일자);
    if (!map.has(key)) {
      const o = { 생산일자: key, 생산수량:0, 양품수량:0, 불량수량:0 };
      for (const dc of defectCols) o[dc] = 0;
      map.set(key, o);
    }
    const o = map.get(key);
    o.생산수량 += r.생산수량; o.양품수량 += r.양품수량; o.불량수량 += r.불량수량;
    for (const dc of defectCols) o[dc] += r[dc];
  }
  const arr = [...map.values()].sort((a,b) => a.생산일자.localeCompare(b.생산일자));
  arr.forEach(o => {
    o.불량률 = calcDefectRate(o.불량수량, o.생산수량);
    o.PPM = calcPPM(o.불량수량, o.생산수량);
  });
  return arr;
}

function aggByItem(data) {
  const map = new Map();
  for (const r of data) {
    if (!map.has(r.품명)) {
      const o = { 품명: r.품명, 생산수량:0, 양품수량:0, 불량수량:0 };
      for (const dc of defectCols) o[dc] = 0;
      map.set(r.품명, o);
    }
    const o = map.get(r.품명);
    o.생산수량 += r.생산수량; o.양품수량 += r.양품수량; o.불량수량 += r.불량수량;
    for (const dc of defectCols) o[dc] += r[dc];
  }
  const arr = [...map.values()];
  arr.forEach(o => {
    o.불량률 = calcDefectRate(o.불량수량, o.생산수량);
    o.PPM = calcPPM(o.불량수량, o.생산수량);
  });
  arr.sort((a,b) => b.불량수량 - a.불량수량);
  return arr;
}

function aggDefectTotals(data) {
  const totals = defectCols.map(dc => {
    let sum = 0;
    for (const r of data) sum += r[dc];
    return { 불량유형: dc, 건수: sum };
  });
  totals.sort((a,b) => b.건수 - a.건수);
  return totals;
}

/* ================================================================
   차트 생성 (모바일 최적화)
   ================================================================ */
const PALETTE = ['#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854',
  '#ffd92f','#e5c494','#b3b3b3','#fb9a99','#cab2d6'];

function getPlotCfg() {
  const mb = isMobile();
  return {
    responsive: true,
    displayModeBar: true,
    displaylogo: false,
    scrollZoom: false,
    modeBarButtonsToRemove: mb
      ? ['select2d','lasso2d','autoScale2d','toggleSpikelines','hoverCompareCartesian','hoverClosestCartesian']
      : ['select2d','lasso2d'],
    modeBarButtonsToAdd: [],
  };
}

function chartHeight(desktop, mobile) {
  if (isMobile()) {
    // 화면 높이의 45% 또는 지정값 중 작은 것
    return Math.min(mobile, Math.round(window.innerHeight * 0.45));
  }
  // PC: 1200px+ 화면에서는 약간 키움
  return window.innerWidth >= 1200 ? Math.round(desktop * 1.1) : desktop;
}

function chartKPI(kpi, el) {
  el.innerHTML = '';
  const cards = [
    { label:'총 생산수량', value: fmt(kpi.총생산수량), color:'var(--primary)' },
    { label:'총 양품수량', value: fmt(kpi.총양품수량), color:'var(--success)' },
    { label:'총 불량수량', value: fmt(kpi.총불량수량), color:'var(--danger)' },
    { label:'불량률', value: pct(kpi.불량률), color:'var(--warning)' },
    { label:'PPM', value: fmt(Math.round(kpi.PPM || 0)), color:'var(--warning)' },
    { label:'품목수', value: kpi.품목수 + '개', color:'var(--gray)' },
    { label:'생산일수', value: kpi.생산일수 + '일', color:'var(--gray)' },
  ];
  const grid = document.createElement('div');
  grid.className = 'kpi-grid';
  for (const c of cards) {
    grid.innerHTML += `<div class="kpi-card"><div class="value" style="color:${c.color}">${c.value}</div><div class="label">${c.label}</div></div>`;
  }
  el.appendChild(grid);
}

function chartDailyTrend(byDate, el) {
  const dates = byDate.map(r => dateKR(r.생산일자));
  const mb = isMobile();
  const trace1 = {
    x: dates, y: byDate.map(r => r.생산수량), type:'bar',
    name:'생산수량', marker:{color:'#2563EB', opacity:.75}, yaxis:'y'
  };
  const trace2 = {
    x: dates, y: byDate.map(r => r.불량률*100), type:'scatter', mode:'lines+markers' + (mb ? '' : '+text'),
    name:'불량률(%)', line:{color:'#DC2626', width:2.5}, marker:{size: mb ? 6 : 8},
    text: byDate.map(r => pct(r.불량률*100)), textposition:'top center',
    textfont:{size: mb ? 8 : 10, color:'#DC2626'}, yaxis:'y2'
  };
  const traceTarget = {
    x: [dates[0], dates[dates.length-1]],
    y: [targetDefectRate, targetDefectRate],
    type:'scatter', mode:'lines',
    name:'목표 불량률(' + targetDefectRate.toFixed(1) + '%)',
    line:{color:'#16A34A', width:1.5, dash:'dash'}, yaxis:'y2'
  };
  Plotly.newPlot(el, [trace1, trace2, traceTarget], {
    title: mb ? '' : '일자별 생산수량 및 불량률 추이',
    yaxis:{title: mb ? '' : '생산수량'},
    yaxis2:{title: mb ? '' : '불량률 (%)', overlaying:'y', side:'right'},
    legend:{orientation:'h', y: mb ? 1.15 : 1.12, font:{size: mb ? 10 : 12}},
    height: chartHeight(420, 300),
    margin: mb ? {t:30,b:40,l:40,r:40} : {t:60,b:50,l:60,r:60}
  }, getPlotCfg());
}

function chartPareto(totals, el) {
  const filtered = totals.filter(t => t.건수 > 0);
  if (!filtered.length) { el.innerHTML = '<p>불량 데이터 없음</p>'; return; }
  const total = filtered.reduce((s,t) => s+t.건수, 0);
  let cum = 0;
  const cumPct = filtered.map(t => { cum += t.건수; return cum/total*100; });
  const mb = isMobile();

  const trace1 = {
    x: filtered.map(t=>t.불량유형), y: filtered.map(t=>t.건수), type:'bar',
    name:'불량 건수', marker:{color:'#2563EB', opacity:.85},
    text: filtered.map(t=>fmt(t.건수)), textposition:'outside',
    textfont:{size: mb ? 9 : 12}
  };
  const trace2 = {
    x: filtered.map(t=>t.불량유형), y: cumPct, type:'scatter', mode:'lines+markers' + (mb ? '' : '+text'),
    name:'누적 비율', marker:{size: mb ? 5 : 7, symbol:'diamond'}, line:{color:'#DC2626', width:2.5},
    text: cumPct.map(v=>pct(v,1)), textposition:'top center',
    textfont:{size: mb ? 8 : 10, color:'#DC2626'}, yaxis:'y2'
  };
  Plotly.newPlot(el, [trace1, trace2], {
    title: mb ? '' : '불량 유형별 파레토 분석',
    yaxis:{title: mb ? '' : '불량 건수'},
    yaxis2:{title: mb ? '' : '누적 비율 (%)', overlaying:'y', side:'right', range:[0,110]},
    shapes:[{type:'line',yref:'y2',y0:80,y1:80,x0:0,x1:1,xref:'paper',line:{dash:'dash',color:'#F59E0B'}}],
    legend:{orientation:'h', y: mb ? 1.18 : 1.12, font:{size: mb ? 10 : 12}},
    height: chartHeight(420, 320),
    margin: mb ? {t:30,b:60,l:40,r:40} : {t:60,b:50,l:60,r:60}
  }, getPlotCfg());
}

function chartItemTop15(byItem, el) {
  const filtered = byItem.filter(r => r.생산수량 >= 50)
    .sort((a,b) => b.불량률 - a.불량률).slice(0,15).reverse();
  if (!filtered.length) { el.innerHTML = '<p>데이터 부족 (생산 50개 이상 품목 없음)</p>'; return; }
  const mb = isMobile();

  const labels = filtered.map(r => {
    const maxLen = mb ? 18 : 30;
    return r.품명.length > maxLen ? r.품명.slice(0, maxLen)+'...' : r.품명;
  });
  const rates = filtered.map(r => r.불량률 * 100);
  const maxRate = Math.max(...rates);

  // 텍스트 위치: 막대가 전체의 60% 이상이면 안쪽, 아니면 바깥쪽
  const textPositions = rates.map(v => v > maxRate * 0.5 ? 'inside' : 'outside');
  const textColors = rates.map(v => v > maxRate * 0.5 ? '#FFFFFF' : '#1F2937');
  const texts = filtered.map(r =>
    mb ? `${pct(r.불량률*100,1)} (${fmt(r.불량수량)}/${fmt(r.생산수량)})`
       : `${pct(r.불량률*100,1)}  |  불량 ${fmt(r.불량수량)}개  /  생산 ${fmt(r.생산수량)}개`
  );

  Plotly.newPlot(el, [{
    y: labels, x: rates, type:'bar', orientation:'h',
    marker:{color: rates.map(v => v >= 10 ? '#991B1B' : v >= 5 ? '#DC2626' : '#F87171'), opacity:.9},
    text: texts, textposition: textPositions,
    textfont:{size: mb ? 9 : 12, color: textColors, family:'Malgun Gothic, sans-serif'},
    insidetextanchor: 'end',
    hovertemplate: '<b>%{y}</b><br>불량률: %{x:.1f}%<br>%{text}<extra></extra>'
  }], {
    title: mb ? '' : '품목별 불량률 TOP 15 (생산 50개 이상)',
    xaxis:{title: mb ? '' : '불량률 (%)', range: [0, maxRate * 1.35]},
    yaxis:{tickfont:{size: mb ? 10 : 12}},
    height: Math.max(mb ? 380 : 450, filtered.length * (mb ? 30 : 38) + 80),
    margin: mb ? {l:150, r:30, t:20, b:30} : {l:260, r:30, t:50, b:40}
  }, getPlotCfg());
}

function chartHeatmap(byItem, el) {
  // byItem 기반 (filtered 대신) — localStorage 복원 시에도 동작
  if (!defectCols.length || !byItem.length) {
    el.innerHTML = '<p style="color:var(--text-light);padding:20px">불량유형 컬럼 데이터가 없습니다.</p>';
    return;
  }

  const mb = isMobile();
  const topN = mb ? 10 : 20;
  const sorted = [...byItem].sort((a,b) => b.불량수량 - a.불량수량).slice(0, topN);

  // 건수 행렬: byItem 각 row에 defectCol 합계가 이미 들어있음
  const matrixCount = sorted.map(item => defectCols.map(dc => item[dc] || 0));

  // 불량률 행렬 (해당 품목 생산수량 대비 %)
  const matrixRate = sorted.map((item, idx) => {
    const prod = item.생산수량 || 1;
    return matrixCount[idx].map(v => +(v / prod * 100).toFixed(2));
  });

  // 표시 텍스트: 건수 + 비율
  const textMatrix = matrixCount.map((row, i) =>
    row.map((v, j) => v > 0 ? fmt(v) + '\n(' + pct(matrixRate[i][j], 1) + ')' : '-')
  );

  const maxLen = mb ? 15 : 25;
  const labels = sorted.map(r => r.품명.length > maxLen ? r.품명.slice(0, maxLen)+'...' : r.품명);

  // 불량유형별 합계 (x축)
  const colTotals = defectCols.map((dc, j) => matrixCount.reduce((s, row) => s + row[j], 0));
  const xLabels = defectCols.map((dc, j) => dc + ' (' + fmt(colTotals[j]) + ')');

  // 품목별 합계 (y축)
  const rowTotals = matrixCount.map(row => row.reduce((s, v) => s + v, 0));
  const yLabels = labels.map((l, i) => l + ' [' + fmt(rowTotals[i]) + ']');

  // zmax를 상위 95%ile로 설정하여 극단값이 색상을 지배하지 않도록
  const allRates = matrixRate.flat().filter(v => v > 0).sort((a,b) => a - b);
  const zMax = allRates.length > 2 ? allRates[Math.floor(allRates.length * 0.95)] || 10 : 10;

  Plotly.newPlot(el, [{
    z: matrixRate, x: xLabels, y: yLabels, type: 'heatmap',
    colorscale: [
      [0, '#F0FDF4'], [0.15, '#BBF7D0'], [0.3, '#FEF9C3'],
      [0.5, '#FED7AA'], [0.7, '#FECACA'], [1, '#991B1B']
    ],
    text: textMatrix,
    texttemplate: '%{text}', textfont: {size: mb ? 8 : 11, color: '#1F2937'},
    hovertemplate: '<b>%{y}</b><br>불량유형: %{x}<br>불량률: %{z:.2f}%<extra></extra>',
    colorbar: {title: '불량률(%)', len: 0.8, ticksuffix: '%'},
    zmin: 0, zmax: zMax,
    xgap: 2, ygap: 2
  }], {
    title: mb ? '' : '품목 x 불량유형 히트맵 (색상: 불량률 기준)',
    height: Math.max(mb ? 400 : 580, sorted.length * (mb ? 35 : 38) + 120),
    margin: mb ? {l: 160, r: 40, t: 20, b: 90} : {l: 270, r: 60, t: 50, b: 90},
    yaxis: {autorange: 'reversed', tickfont: {size: mb ? 10 : 12}},
    xaxis: {tickangle: mb ? -45 : -30, tickfont: {size: mb ? 9 : 11}, side: 'bottom'}
  }, getPlotCfg());
}

/* ================================================================
   버블차트 날짜별 애니메이션
   - 누적 방식: 날짜가 진행될수록 데이터가 쌓임
   - 품목별로 생산/불량이 누적되며 버블이 성장
   ================================================================ */
function chartScatterAnimated(data, byDate, el) {
  if (!data || !data.length || !byDate || !byDate.length) {
    el.innerHTML = '<p style="color:var(--text-light);padding:20px">데이터가 부족합니다.</p>';
    return;
  }
  const mb = isMobile();

  // byDate의 생산일자는 이미 ISO문자열 "2024-03-15"
  const dates = byDate.map(r => String(r.생산일자).slice(0,10));

  // data(filtered)의 생산일자를 ISO 문자열로 미리 변환하여 매핑
  const dataWithStr = data.map(r => ({
    품명: r.품명,
    생산수량: toNum(r.생산수량),
    불량수량: toNum(r.불량수량),
    dateKey: dateStr(r.생산일자)
  }));

  // 날짜별로 누적 데이터 계산
  const frames = [];
  const cumMap = {};
  for (let di = 0; di < dates.length; di++) {
    const d = dates[di];
    const dayRows = dataWithStr.filter(r => r.dateKey === d);
    for (const r of dayRows) {
      if (!cumMap[r.품명]) cumMap[r.품명] = {품명: r.품명, 생산수량: 0, 불량수량: 0};
      cumMap[r.품명].생산수량 += r.생산수량;
      cumMap[r.품명].불량수량 += r.불량수량;
    }
    // 현재 스냅샷 깊은 복사
    const snapshot = Object.values(cumMap).map(v => ({
      품명: v.품명,
      생산수량: v.생산수량,
      불량수량: v.불량수량,
      불량률: v.생산수량 > 0 ? v.불량수량 / v.생산수량 : 0
    }));
    frames.push({date: d, items: snapshot});
  }

  // 마지막 프레임에서 전체 범위 결정
  if (!frames.length) {
    el.innerHTML = '<p style="color:var(--text-light);padding:20px">데이터가 부족합니다.</p>';
    return;
  }
  const lastItems = frames[frames.length - 1].items;
  const validItems = lastItems.filter(r => r.생산수량 >= 10);
  if (!validItems.length) {
    el.innerHTML = '<p style="color:var(--text-light);padding:20px">유효 품목이 없습니다.</p>';
    return;
  }
  const maxProd = Math.max(...validItems.map(r => r.생산수량));
  const maxRate = Math.max(...validItems.map(r => r.불량률 * 100), 10);
  const maxBad = Math.max(...validItems.map(r => r.불량수량), 1);

  // UI
  el.innerHTML = `
    <div class="anim-controls" style="display:flex;align-items:center;gap:10px;margin-bottom:12px;flex-wrap:wrap">
      <div class="anim-row1" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <button class="btn btn-sm btn-primary" id="animPlay" style="min-width:70px">▶ 재생</button>
        <button class="btn btn-sm" style="background:var(--gray);color:#fff;min-width:50px" id="animReset">처음</button>
        <span id="animDateLabel" style="font-weight:700;font-size:14px;min-width:100px;text-align:center">
          ${dateKRFull(dates[dates.length-1])}
        </span>
      </div>
      <div class="anim-row2" style="display:flex;align-items:center;gap:8px;flex:1;min-width:120px">
        <input type="range" id="animSlider" min="0" max="${frames.length-1}" value="${frames.length-1}"
          style="flex:1;height:36px">
        <label class="anim-speed" style="font-size:12px;display:flex;align-items:center;gap:4px;white-space:nowrap">
          <input type="range" id="animSpeed" min="100" max="1500" value="500" style="width:70px;height:30px">
          속도
        </label>
      </div>
    </div>
    <div id="animChart" style="width:100%"></div>`;

  const chartEl = document.getElementById('animChart');
  const slider = document.getElementById('animSlider');
  const lblDate = document.getElementById('animDateLabel');
  const btnPlay = document.getElementById('animPlay');
  const btnReset = document.getElementById('animReset');
  const sldSpeed = document.getElementById('animSpeed');
  let timer = null, isPlaying = false;

  function draw(idx) {
    if (idx < 0 || idx >= frames.length) return;
    const frame = frames[idx];
    const items = frame.items.filter(r => r.생산수량 >= 10);
    if (!items.length) return;

    const bubbleSizes = items.map(r => Math.max(r.불량수량 / maxBad * (mb ? 30 : 50), mb ? 5 : 7));
    const bubbleColors = items.map(r => {
      const rt = r.불량률 * 100;
      return rt >= 8 ? '#991B1B' : rt >= 5 ? '#DC2626' : rt >= 3 ? '#F59E0B' : '#2563EB';
    });
    const topN = [...items].sort((a,b) => b.불량수량 - a.불량수량).slice(0, 8).map(r => r.품명);

    const trace = {
      x: items.map(r => r.생산수량),
      y: items.map(r => r.불량률 * 100),
      mode: 'markers+text',
      type: 'scatter',
      marker: {size: bubbleSizes, color: bubbleColors, opacity: 0.85,
        line: {width: 1.5, color: 'rgba(255,255,255,0.8)'}},
      text: items.map(r => topN.includes(r.품명) ? r.품명.slice(0, mb ? 8 : 15) : ''),
      textposition: 'top center',
      textfont: {size: mb ? 7 : 9, color: '#374151'},
      hovertext: items.map(r => r.품명),
      customdata: items.map(r => [r.불량수량, r.생산수량]),
      hovertemplate: '<b>%{hovertext}</b><br>누적생산: %{customdata[1]:,}개<br>누적불량: %{customdata[0]:,}개<br>불량률: %{y:.2f}%<extra></extra>'
    };

    const dateText = dateKRFull(frame.date);
    const layout = {
      xaxis: {title: mb ? '' : '누적 생산수량', range: [Math.log10(5), Math.log10(maxProd * 1.3)], type: 'log',
        gridcolor: '#E5E7EB', zeroline: false},
      yaxis: {title: mb ? '' : '불량률 (%)', range: [-0.5, Math.min(maxRate * 1.3, 100)],
        gridcolor: '#E5E7EB', zeroline: false},
      height: chartHeight(480, 360),
      margin: mb ? {t: 40, b: 40, l: 40, r: 20} : {t: 60, b: 50, l: 60, r: 40},
      annotations: [{
        x: 0.98, y: 0.98, xref: 'paper', yref: 'paper', showarrow: false,
        text: '<b>' + dateText + '</b>',
        font: {size: mb ? 16 : 24, color: '#2563EB'},
        xanchor: 'right', yanchor: 'top',
        bgcolor: 'rgba(255,255,255,0.85)', borderpad: 8,
        bordercolor: '#E5E7EB', borderwidth: 1
      }, {
        x: 0.02, y: 0.98, xref: 'paper', yref: 'paper', showarrow: false,
        text: '품목수: ' + items.length + '개',
        font: {size: mb ? 10 : 12, color: '#6B7280'},
        xanchor: 'left', yanchor: 'top'
      }]
    };

    Plotly.react(chartEl, [trace], layout, getPlotCfg());
  }

  // 초기 렌더: 빈 차트 먼저 생성 후 마지막 프레임
  Plotly.newPlot(chartEl, [{x:[],y:[],type:'scatter',mode:'markers'}], {
    height: chartHeight(480, 360),
    xaxis: {type:'log', range:[Math.log10(5),Math.log10(maxProd*1.3)]},
    yaxis: {range:[-0.5,Math.min(maxRate*1.3,100)]},
    margin: mb?{t:40,b:40,l:40,r:20}:{t:60,b:50,l:60,r:40}
  }, getPlotCfg());
  draw(frames.length - 1);

  slider.addEventListener('input', function() {
    const idx = parseInt(this.value);
    lblDate.textContent = dateKRFull(dates[idx]);
    draw(idx);
  });

  btnPlay.addEventListener('click', function() {
    if (isPlaying) {
      clearInterval(timer); isPlaying = false;
      this.textContent = '▶ 재생';
      return;
    }
    isPlaying = true;
    this.textContent = '⏸ 정지';
    if (parseInt(slider.value) >= frames.length - 1) {
      slider.value = 0;
      draw(0);
    }

    timer = setInterval(function() {
      let idx = parseInt(slider.value) + 1;
      if (idx >= frames.length) {
        clearInterval(timer); isPlaying = false;
        btnPlay.textContent = '▶ 재생';
        return;
      }
      slider.value = idx;
      lblDate.textContent = dateKRFull(dates[idx]);
      draw(idx);
    }, parseInt(sldSpeed.value));
  });

  btnReset.addEventListener('click', function() {
    if (isPlaying) { clearInterval(timer); isPlaying = false; btnPlay.textContent = '▶ 재생'; }
    slider.value = 0;
    lblDate.textContent = dateKRFull(dates[0]);
    draw(0);
  });
}

function chartDailyStack(byDate, el) {
  const active = defectCols.filter(dc => byDate.some(r => r[dc] > 0));
  const dates = byDate.map(r => dateKR(r.생산일자));
  const mb = isMobile();
  const traces = active.map((dc, i) => ({
    x: dates, y: byDate.map(r => r[dc]), type:'bar', name: dc,
    marker:{color: PALETTE[i % PALETTE.length]}
  }));
  Plotly.newPlot(el, traces, {
    barmode:'stack',
    title: mb ? '' : '일자별 불량유형 구성',
    xaxis:{title: mb ? '' : '생산일자'},
    yaxis:{title: mb ? '' : '불량 건수'},
    legend:{orientation:'h', y: mb ? 1.2 : 1.12, font:{size: mb ? 9 : 12}},
    height: chartHeight(420, 300),
    margin: mb ? {t:30,b:40,l:35,r:10} : {t:60,b:50,l:60,r:40}
  }, getPlotCfg());
}

function chartScatter(byItem, el) {
  const df = byItem.filter(r => r.생산수량 >= 50);
  if (!df.length) { el.innerHTML = '<p>데이터 부족 (생산 50개 이상 품목 없음)</p>'; return; }
  const mb = isMobile();

  // 기준선 계산: 생산수량 중앙값, 불량률 중앙값
  const sortedProd = [...df].sort((a,b) => a.생산수량 - b.생산수량);
  const sortedRate = [...df].sort((a,b) => a.불량률 - b.불량률);
  const medProd = sortedProd[Math.floor(sortedProd.length/2)].생산수량;
  const medRate = sortedRate[Math.floor(sortedRate.length/2)].불량률 * 100;

  // 4사분면 색상: 우상(위험-빨강), 좌상(주의-주황), 우하(양호-파랑), 좌하(관심-회색)
  const quadColors = df.map(r => {
    const highProd = r.생산수량 >= medProd;
    const highRate = r.불량률 * 100 >= medRate;
    if (highProd && highRate) return '#DC2626';   // 위험: 대량생산 + 높은불량
    if (!highProd && highRate) return '#F59E0B';  // 주의: 소량이지만 높은불량
    if (highProd && !highRate) return '#2563EB';  // 양호: 대량생산 + 낮은불량
    return '#94A3B8';                              // 관심: 소량 + 낮은불량
  });

  // 버블 크기: 불량수량 비례 (최소~최대 정규화)
  const badArr = df.map(r => r.불량수량);
  const maxBad = Math.max(...badArr, 1);
  const sizes = badArr.map(v => Math.max(v / maxBad * (mb ? 30 : 50), mb ? 6 : 8));

  // 라벨: 상위 불량수량 TOP 10 + 불량률 TOP 5 표시
  const topBad = [...df].sort((a,b) => b.불량수량 - a.불량수량).slice(0, 10).map(r => r.품명);
  const topRate = [...df].sort((a,b) => b.불량률 - a.불량률).slice(0, 5).map(r => r.품명);
  const showLabel = new Set([...topBad, ...topRate]);

  Plotly.newPlot(el, [
    // 4사분면 배경 표시
    { x: df.map(r=>r.생산수량), y: df.map(r=>r.불량률*100), type:'scatter', mode: 'markers' + (mb ? '' : '+text'),
      marker: {size: sizes, color: quadColors, line: {width: 1.5, color: 'white'}, opacity: 0.85},
      text: df.map(r => showLabel.has(r.품명) ? r.품명.slice(0, mb ? 8 : 18) : ''),
      textposition: 'top center', textfont: {size: mb ? 7 : 9, color: '#374151'},
      hovertemplate: '<b>%{hovertext}</b><br>생산: %{x:,}개<br>불량: %{customdata[0]:,}개<br>불량률: %{y:.2f}%<extra></extra>',
      hovertext: df.map(r => r.품명),
      customdata: df.map(r => [r.불량수량]),
    }
  ], {
    title: mb ? '' : '생산수량 vs 불량률 (버블 크기 = 불량수량)',
    xaxis: {title: mb ? '' : '생산수량', type: 'log', gridcolor: '#E5E7EB'},
    yaxis: {title: mb ? '' : '불량률 (%)', gridcolor: '#E5E7EB'},
    height: chartHeight(520, 380),
    margin: mb ? {t: 20, b: 40, l: 40, r: 20} : {t: 50, b: 60, l: 60, r: 60},
    shapes: [
      // 수평 기준선 (불량률 중앙값)
      {type: 'line', x0: 0, x1: 1, xref: 'paper', y0: medRate, y1: medRate,
        line: {color: '#9CA3AF', width: 1.5, dash: 'dot'}},
      // 수직 기준선 (생산수량 중앙값)
      {type: 'line', y0: 0, y1: 1, yref: 'paper', x0: medProd, x1: medProd,
        line: {color: '#9CA3AF', width: 1.5, dash: 'dot'}},
    ],
    annotations: [
      // 4사분면 라벨
      {x: 1, y: 1, xref: 'paper', yref: 'paper', text: '<b>위험</b><br>대량+고불량', showarrow: false,
        font: {color: '#DC2626', size: mb ? 9 : 11}, xanchor: 'right', yanchor: 'top', bgcolor: 'rgba(254,226,226,0.7)', borderpad: 4},
      {x: 0, y: 1, xref: 'paper', yref: 'paper', text: '<b>주의</b><br>소량+고불량', showarrow: false,
        font: {color: '#F59E0B', size: mb ? 9 : 11}, xanchor: 'left', yanchor: 'top', bgcolor: 'rgba(254,243,199,0.7)', borderpad: 4},
      {x: 1, y: 0, xref: 'paper', yref: 'paper', text: '<b>양호</b><br>대량+저불량', showarrow: false,
        font: {color: '#2563EB', size: mb ? 9 : 11}, xanchor: 'right', yanchor: 'bottom', bgcolor: 'rgba(219,234,254,0.7)', borderpad: 4},
      {x: 0, y: 0, xref: 'paper', yref: 'paper', text: '<b>관심</b><br>소량+저불량', showarrow: false,
        font: {color: '#6B7280', size: mb ? 9 : 11}, xanchor: 'left', yanchor: 'bottom', bgcolor: 'rgba(243,244,246,0.7)', borderpad: 4},
      // 기준선 설명
      {x: 0.5, y: medRate, xref: 'paper', yref: 'y', text: '불량률 중앙값 ' + pct(medRate,1), showarrow: false,
        font: {size: mb ? 8 : 10, color: '#6B7280'}, yshift: 12},
    ]
  }, getPlotCfg());
}

/* ================================================================
   테이블 생성
   ================================================================ */
function makeTable(headers, rows) {
  let html = '<div class="scroll-hint">&#8592; 좌우 스크롤 가능 &#8594;</div>';
  html += '<div class="tbl-wrap"><table class="data-tbl"><thead><tr>';
  for (const h of headers) html += `<th>${h}</th>`;
  html += '</tr></thead><tbody>';
  for (const row of rows) {
    html += '<tr>';
    for (const h of headers) {
      let v = row[h];
      if (typeof v === 'number') v = h.includes('률') ? pct(v*100) : fmt(v);
      html += `<td>${v ?? ''}</td>`;
    }
    html += '</tr>';
  }
  html += '</tbody></table></div>';
  return html;
}

/* ================================================================
   엑셀 내보내기
   ================================================================ */
function exportExcel(kpi, byDate, byItem, totals) {
  const wb = XLSX.utils.book_new();

  const kpiData = [
    ['지표','값'],
    ['총 생산수량', kpi.총생산수량], ['총 양품수량', kpi.총양품수량],
    ['총 불량수량', kpi.총불량수량], ['전체 불량률(%)', kpi.불량률.toFixed(2)],
    ['전체 PPM', Math.round(kpi.PPM ?? calcPPM(kpi.총불량수량, kpi.총생산수량))],
    ['품목수', kpi.품목수], ['생산일수', kpi.생산일수],
  ];
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(kpiData), '요약_KPI');

  const dateHeaders = ['생산일자','생산수량','양품수량','불량수량',...defectCols,'불량률(%)','PPM'];
  const dateRows = [dateHeaders, ...byDate.map(r => [
    r.생산일자, r.생산수량, r.양품수량, r.불량수량,
    ...defectCols.map(dc=>r[dc]), (r.불량률*100).toFixed(2), Math.round(r.PPM ?? calcPPM(r.불량수량, r.생산수량))
  ])];
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(dateRows), '일자별_집계');

  const itemHeaders = ['품명','생산수량','양품수량','불량수량',...defectCols,'불량률(%)','PPM'];
  const itemRows = [itemHeaders, ...byItem.map(r => [
    r.품명, r.생산수량, r.양품수량, r.불량수량,
    ...defectCols.map(dc=>r[dc]), (r.불량률*100).toFixed(2), Math.round(r.PPM ?? calcPPM(r.불량수량, r.생산수량))
  ])];
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(itemRows), '품목별_집계');

  const totRows = [['불량유형','건수'], ...totals.map(t=>[t.불량유형, t.건수])];
  XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(totRows), '불량유형별_합계');

  XLSX.writeFile(wb, '생산현황_분석_리포트.xlsx');
}

/* ================================================================
   탭 전환
   ================================================================ */
/* ================================================================
   탭 전환 공통 함수 (PC + 모바일 통합)
   ================================================================ */
function switchTab(tabId) {
  // 모든 탭 버튼 비활성화 (PC + 모바일)
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-m-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
  // 활성화
  document.querySelectorAll(`[data-tab="${tabId}"]`).forEach(b => b.classList.add('active'));
  document.getElementById(tabId).classList.add('active');
  // 모바일: 상단으로 스크롤
  if (isMobile()) {
    window.scrollTo({top: 0, behavior: 'smooth'});
  }
  // Plotly 리사이즈 (모바일에서 display:none→block 전환 후 충분한 시간 확보)
  const resizePlots = () => {
    const tab = document.getElementById(tabId);
    if (tab) tab.querySelectorAll('.js-plotly-plot').forEach(p => {
      try { Plotly.Plots.resize(p); } catch(e) {}
    });
  };
  // 즉시 한번 + 지연 후 한번 더 (모바일 브라우저 렌더링 지연 대응)
  requestAnimationFrame(() => {
    resizePlots();
    setTimeout(resizePlots, 300);
  });
}

// PC 탭바 이벤트
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => switchTab(btn.dataset.tab));
});
// 모바일 탭 그리드 이벤트
document.querySelectorAll('.tab-m-btn').forEach(btn => {
  btn.addEventListener('click', () => switchTab(btn.dataset.tab));
});

/* 드릴다운 모달 닫기 */
$('drillModalClose').addEventListener('click', () => {
  $('drillModal').classList.remove('open');
  document.body.style.overflow = '';
});

/* ================================================================
   품목 필터 (체크박스 검색 방식 - 모바일 친화)
   ================================================================ */
function setupItemFilter(items) {
  selectedFilterItems.clear();
  const wrap = $('itemFilterWrap');
  let html = `<input type="text" id="itemSearch" placeholder="품목 검색..."
    style="width:100%;padding:10px;border:1px solid var(--border);border-radius:8px 8px 0 0;
    font-size:14px;min-height:44px;border-bottom:none;">
    <div class="item-filter-actions">
      <button type="button" onclick="document.querySelectorAll('.item-filter-chk').forEach(c=>{if(c.parentElement.style.display!=='none')c.checked=true})">전체 선택</button>
      <button type="button" onclick="document.querySelectorAll('.item-filter-chk').forEach(c=>c.checked=false)">전체 해제</button>
    </div>
    <div id="itemCheckList" style="max-height:180px;overflow-y:auto;border:1px solid var(--border);
    border-radius:0 0 8px 8px;padding:6px 8px;-webkit-overflow-scrolling:touch;">`;

  for (const item of items) {
    const shortName = item.length > 35 ? item.slice(0,35)+'...' : item;
    html += `<label style="display:flex;align-items:center;gap:6px;padding:5px 0;font-weight:400;
      font-size:13px;cursor:pointer;border-bottom:1px solid #f3f4f6">
      <input type="checkbox" class="item-filter-chk" value="${item}"
        style="width:18px;height:18px;flex-shrink:0"> ${shortName}
    </label>`;
  }
  html += `</div>
    <div style="margin-top:4px;font-size:11px;color:var(--text-light)">
      선택 안하면 전체 품목 표시
    </div>`;
  wrap.innerHTML = html;

  // 검색
  $('itemSearch').addEventListener('input', e => {
    const q = e.target.value.toLowerCase();
    document.querySelectorAll('.item-filter-chk').forEach(chk => {
      const match = chk.value.toLowerCase().includes(q);
      chk.parentElement.style.display = match ? '' : 'none';
    });
  });
}

/* ================================================================
   분석 시작
   ================================================================ */
$('btnAnalyze').addEventListener('click', runAnalysis);

function runAnalysis() {
  // 모바일 분석시작 플로팅 버튼 숨기기
  $('mobileAnalyzeFab').classList.remove('show');

  // 새 파일이 업로드된 경우: 매핑 → cleanData
  if (rawData && rawData.length) {
    const stdKeys = ['생산일자','품명','생산수량','양품수량','불량수량'];
    for (const k of stdKeys) {
      const sel = document.getElementById(`map_${k}`);
      if (sel) mapping[k] = sel.value || undefined;
    }

    const missing = stdKeys.filter(k => !mapping[k]);
    if (missing.length) {
      showToast('필수 컬럼이 매핑되지 않았습니다: ' + missing.join(', '), 'error', 5000);
      return;
    }

    if (uploadedFiles.length > 1) {
      let allRaw = [...rawData];
      rawData = allRaw;
    }

    cleanedData = cleanData(rawData);
  }

  // cleanedData가 없으면 (파일도 없고 저장 데이터도 없음)
  if (!cleanedData || !cleanedData.length) {
    showToast('분석할 데이터가 없습니다. 엑셀 파일을 업로드해주세요.', 'error', 5000);
    return;
  }

  // 로딩 표시 후 분석 실행 (UI 업데이트를 위해 비동기)
  showLoading('데이터 분석 중...');
  setTimeout(() => {
    try {
      setupFilters();
      applyFilterAndRender();
      showToast('분석 완료! ' + cleanedData.length + '건의 데이터를 분석했습니다.', 'success');
    } catch(e) {
      showToast('분석 중 오류가 발생했습니다: ' + e.message, 'error');
    } finally {
      hideLoading();
    }
    if (isMobile()) closeSidebar();
  }, 50);
}

function setupFilters() {
  const dates = cleanedData.map(r => dateStr(r.생산일자)).sort();
  $('filterStart').value = dates[0];
  $('filterEnd').value = dates[dates.length-1];
  $('filterStart').min = dates[0];
  $('filterStart').max = dates[dates.length-1];
  $('filterEnd').min = dates[0];
  $('filterEnd').max = dates[dates.length-1];
  $('filterDateRange').textContent = `데이터 범위: ${dates[0]} ~ ${dates[dates.length-1]} (${dates.length}일)`;

  const items = [...new Set(cleanedData.map(r => r.품명))].sort();
  setupItemFilter(items);

  $('filterArea').style.display = '';
}

// 목표 불량률: 슬라이더 ↔ 입력 필드 양방향 동기화
$('targetDefectRate').value = targetDefectRate;
$('targetDefectInput').value = targetDefectRate.toFixed(1);
$('targetDefectRate').addEventListener('input', e => {
  const val = Number(e.target.value);
  $('targetDefectInput').value = val.toFixed(1);
  targetDefectRate = val;
  saveTargetDefectRate(val);
});
$('targetDefectInput').addEventListener('input', e => {
  let val = Number(e.target.value);
  if (val < 0.1) val = 0.1; if (val > 5) val = 5;
  $('targetDefectRate').value = val;
  targetDefectRate = val;
  saveTargetDefectRate(val);
});
$('btnApplyFilter').addEventListener('click', () => {
  applyFilterAndRender();
  if (isMobile()) closeSidebar();
});

function applyFilterAndRender() {
  // 원본 데이터가 없는 경우 (localStorage 용량 초과로 미저장 등)
  if (!cleanedData || !cleanedData.length) {
    showToast('원본 데이터가 없습니다. 엑셀 파일을 다시 업로드해 주세요.', 'warn', 5000);
    return;
  }

  const start = $('filterStart').value;
  const end = $('filterEnd').value;

  if (!start || !end) {
    showToast('시작일과 종료일을 설정해 주세요.', 'warn', 3000);
    return;
  }

  // 체크박스에서 선택된 품목
  const checkedItems = Array.from(document.querySelectorAll('.item-filter-chk:checked')).map(c => c.value);

  let filtered = cleanedData.filter(r => {
    const d = dateStr(r.생산일자);
    return d >= start && d <= end;
  });
  if (checkedItems.length) {
    filtered = filtered.filter(r => checkedItems.includes(r.품명));
  }

  if (!filtered.length) {
    showToast('선택한 기간에 해당하는 데이터가 없습니다. 날짜 범위를 확인해 주세요.', 'warn', 4000);
    return;
  }

  const kpi = calcKPI(filtered);
  const byDate = aggByDate(filtered);
  const byItem = aggByItem(filtered);
  const totals = aggDefectTotals(filtered);
  const alerts = byItem.filter(r => r.불량률 > targetDefectRate/100)
    .sort((a,b) => b.불량률 - a.불량률);

  renderDashboard(kpi, byDate, byItem, totals, alerts, filtered);

  // localStorage에 마지막 분석 결과 저장 (filtered 원본 포함)
  try {
    const saveData = {
      timestamp: new Date().toISOString(),
      kpi, byDate, byItem, totals, alerts,
      filtered: filtered,
      defectColsSaved: defectCols,
      filterStart: start, filterEnd: end
    };
    localStorage.setItem('ndm_lastAnalysis', JSON.stringify(saveData));
  } catch(e) {
    // 용량 초과 시 filtered 없이 재시도
    try {
      const saveData = {
        timestamp: new Date().toISOString(),
        kpi, byDate, byItem, totals, alerts,
        defectColsSaved: defectCols,
        filterStart: start, filterEnd: end
      };
      localStorage.setItem('ndm_lastAnalysis', JSON.stringify(saveData));
    } catch(e2) { /* 그래도 실패하면 무시 */ }
  }
}

/* ================================================================
   Phase 1: 이동평균 계산
   ================================================================ */
function movingAvg(arr, key, window) {
  return arr.map((_, i) => {
    const start = Math.max(0, i - window + 1);
    const slice = arr.slice(start, i + 1);
    return slice.reduce((s, r) => s + r[key], 0) / slice.length;
  });
}

/* Phase 1: 추세 분석 차트 (이동평균 포함) */
function chartTrendMA(byDate, el) {
  const dates = byDate.map(r => dateKR(r.생산일자));
  const rates = byDate.map(r => r.불량률 * 100);
  const ma7  = movingAvg(byDate, '불량률',  7).map(v => v * 100);
  const ma14 = movingAvg(byDate, '불량률', 14).map(v => v * 100);
  const mb   = isMobile();
  const tgt  = targetDefectRate;

  // 초과/달성 마커 색상 — 날짜 순서는 dates 배열 그대로 유지
  const dotColors = rates.map(v => v > tgt ? '#DC2626' : '#94A3B8');
  const dotSizes  = rates.map(v => v > tgt ? (mb ? 8 : 11) : (mb ? 4 : 6));
  const dotBorder = rates.map(v => v > tgt ? '#fff' : 'rgba(0,0,0,0)');
  const dotText   = rates.map(v => v > tgt ? v.toFixed(2) + '%' : '');

  // Y축 zoom: 데이터 범위 ± 여백
  const rateMin = Math.min(...rates, tgt);
  const rateMax = Math.max(...rates, tgt);
  const pad     = (rateMax - rateMin) * 0.4 || 0.2;
  const yMin    = Math.max(0, rateMin - pad);
  const yMax    = rateMax + pad * 2.5;   // 라벨 공간 확보

  Plotly.newPlot(el, [
    // ① 일별 불량률 (달성=회색, 초과=빨강+라벨) — dates 순서 유지
    { x: dates, y: rates, type:'scatter', mode:'markers+text', name:'일별 불량률',
      marker: { color: dotColors, size: dotSizes,
                line: { color: dotBorder, width: 2 } },
      text: dotText, textposition:'top center',
      textfont: { size: 11, color:'#DC2626' },
      cliponaxis: false,
      hovertemplate: '%{x}<br>%{y:.2f}%<extra></extra>' },
    // ② 목표 초과 범례 전용 (실제 점 없음)
    { x: [null], y: [null], type:'scatter', mode:'markers', name:'목표 초과',
      marker: { color:'#DC2626', size: mb?8:11,
                line: { color:'#fff', width: 2 } },
      showlegend: true },
    // ③ 7일 이동평균
    { x: dates, y: ma7,  type:'scatter', mode:'lines', name:'7일 이동평균',
      line: { color:'#2563EB', width: 2.5 } },
    // ④ 14일 이동평균
    { x: dates, y: ma14, type:'scatter', mode:'lines', name:'14일 이동평균',
      line: { color:'#F97316', width: 2, dash:'dash' } },
    // ⑤ 목표 불량률 선
    { x: [dates[0], dates[dates.length-1]], y: [tgt, tgt],
      type:'scatter', mode:'lines', name:'목표 불량률(' + tgt.toFixed(1) + '%)',
      line: { color:'#16A34A', width: 2, dash:'dot' },
      hoverinfo: 'skip' },
  ], {
    xaxis: { categoryorder:'array', categoryarray: dates,   // 날짜 순서 고정
             tickfont: { size: mb?9:11 } },
    yaxis: { title: mb ? '' : '불량률 (%)', range: [yMin, yMax] },
    legend: { orientation:'h', y: mb?1.18:1.12, font:{size:mb?10:12} },
    height: chartHeight(400, 300),
    margin: mb ? {t:30,b:40,l:40,r:20} : {t:50,b:50,l:60,r:40},
    // 목표 초과 구간 배경 음영
    shapes: [{
      type:'rect', xref:'paper', yref:'y',
      x0:0, x1:1, y0:tgt, y1: yMax,
      fillcolor:'rgba(220,38,38,0.06)', line:{ width:0 }, layer:'below'
    }, {
      type:'rect', xref:'paper', yref:'y',
      x0:0, x1:1, y0:yMin, y1: tgt,
      fillcolor:'rgba(22,163,74,0.06)', line:{ width:0 }, layer:'below'
    }]
  }, getPlotCfg());
}

/* Phase 1: 전주 대비 증감 KPI */
function calcWeekChange(data) {
  if (!data || !data.length) return { 금주: 0, 전주: 0, 변화: 0 };
  const today = data[data.length-1].생산일자;
  const todayMs = toDate(today).getTime();
  const week1 = data.filter(r => { const diff = (todayMs - toDate(r.생산일자).getTime())/86400000; return diff >= 0 && diff < 7; });
  const week2 = data.filter(r => { const diff = (todayMs - toDate(r.생산일자).getTime())/86400000; return diff >= 7 && diff < 14; });
  const r1 = week1.length ? week1.reduce((s,r)=>s+r.불량수량,0)/week1.reduce((s,r)=>s+r.생산수량,0)*100 : 0;
  const r2 = week2.length ? week2.reduce((s,r)=>s+r.불량수량,0)/week2.reduce((s,r)=>s+r.생산수량,0)*100 : 0;
  return { 금주: r1, 전주: r2, 변화: r1 - r2 };
}

/* Phase 1: 주간/월간 집계 */
function aggByWeek(data) {
  const map = new Map();
  for (const r of data) {
    const key = weekLabel(dateStr(r.생산일자));
    if (!map.has(key)) { const o={생산일자:key,생산수량:0,양품수량:0,불량수량:0}; for(const dc of defectCols) o[dc]=0; map.set(key,o); }
    const o=map.get(key); o.생산수량+=r.생산수량; o.양품수량+=r.양품수량; o.불량수량+=r.불량수량;
    for(const dc of defectCols) o[dc]+=r[dc];
  }
  const arr=[...map.values()];
  arr.forEach(o=>{
    o.불량률 = calcDefectRate(o.불량수량, o.생산수량);
    o.PPM = calcPPM(o.불량수량, o.생산수량);
  });
  return arr;
}

function aggByMonth(data) {
  const map = new Map();
  for (const r of data) {
    const key = dateStr(r.생산일자).slice(0,7);
    if (!map.has(key)) { const o={생산일자:key,생산수량:0,양품수량:0,불량수량:0}; for(const dc of defectCols) o[dc]=0; map.set(key,o); }
    const o=map.get(key); o.생산수량+=r.생산수량; o.양품수량+=r.양품수량; o.불량수량+=r.불량수량;
    for(const dc of defectCols) o[dc]+=r[dc];
  }
  const arr=[...map.values()].sort((a,b)=>a.생산일자.localeCompare(b.생산일자));
  arr.forEach(o=>{
    o.불량률 = calcDefectRate(o.불량수량, o.생산수량);
    o.PPM = calcPPM(o.불량수량, o.생산수량);
  });
  return arr;
}

/* ================================================================
   Phase 1: p 관리도 (P-Chart)
   - CL = p̄ = 총불량수 / 총검사수
   - UCLᵢ = p̄ + 3√(p̄(1-p̄)/nᵢ)  (서브그룹별 검사수 nᵢ 반영)
   - LCLᵢ = max(0, p̄ - 3√(p̄(1-p̄)/nᵢ))
   ================================================================ */
function chartSPC(byDate, el) {
  const n = byDate.length;
  if (n < 3) { el.innerHTML = '<p>데이터가 3일 이상 필요합니다.</p>'; return; }

  // p̄ (전체 평균 불량률)
  const totalBad = byDate.reduce((s,r) => s + r.불량수량, 0);
  const totalProd = byDate.reduce((s,r) => s + r.생산수량, 0);
  const pBar = totalProd ? totalBad / totalProd : 0;
  const pBarPct = pBar * 100;

  // 각 서브그룹(일자)별 UCL, LCL 계산 (nᵢ에 따라 변동)
  const rates = byDate.map(r => r.불량률 * 100);
  const uclArr = byDate.map(r => {
    const ni = r.생산수량;
    return ni > 0 ? (pBar + 3 * Math.sqrt(pBar * (1 - pBar) / ni)) * 100 : pBarPct;
  });
  const lclArr = byDate.map(r => {
    const ni = r.생산수량;
    return ni > 0 ? Math.max(0, (pBar - 3 * Math.sqrt(pBar * (1 - pBar) / ni)) * 100) : 0;
  });

  const dates = byDate.map(r => dateKR(r.생산일자));
  const mb = isMobile();

  // 이상점 감지 (관리한계 이탈)
  const outIdx = rates.map((v,i) => (v > uclArr[i] || v < lclArr[i]) ? i : -1).filter(i => i >= 0);

  // 연속 규칙: 7연속 상승/하강, 중심선 한쪽 연속 8점
  const ruleBreaks = new Set();
  for (let i = 6; i < n; i++) {
    let up = true, dn = true;
    for (let j = i - 5; j <= i; j++) { if (rates[j] <= rates[j-1]) up = false; if (rates[j] >= rates[j-1]) dn = false; }
    if (up || dn) ruleBreaks.add(i);
  }
  for (let i = 7; i < n; i++) {
    const above = rates.slice(i-7, i+1).every(v => v > pBarPct);
    const below = rates.slice(i-7, i+1).every(v => v < pBarPct);
    if (above || below) for (let j = i-7; j <= i; j++) ruleBreaks.add(j);
  }

  const colors = rates.map((v,i) => outIdx.includes(i) ? '#DC2626' : ruleBreaks.has(i) ? '#F59E0B' : '#2563EB');

  Plotly.newPlot(el, [
    { x: dates, y: rates, type: 'scatter', mode: 'lines+markers', name: 'p (불량률)',
      marker: {color: colors, size: mb ? 6 : 8, line: {width: 1, color: 'white'}}, line: {color: '#2563EB', width: 1.5} },
    { x: dates, y: uclArr, type: 'scatter', mode: 'lines', name: 'UCL',
      line: {color: '#DC2626', width: 2, dash: 'dash'}, hovertemplate: 'UCL: %{y:.2f}%<extra></extra>' },
    { x: dates, y: Array(n).fill(pBarPct), type: 'scatter', mode: 'lines', name: 'CL (p̄ = ' + pct(pBarPct) + ')',
      line: {color: '#16A34A', width: 2.5} },
    { x: dates, y: lclArr, type: 'scatter', mode: 'lines', name: 'LCL',
      line: {color: '#F59E0B', width: 2, dash: 'dash'}, hovertemplate: 'LCL: %{y:.2f}%<extra></extra>' },
    // UCL~LCL 사이 영역 시각화 (관리 범위)
    { x: dates.concat([...dates].reverse()), y: uclArr.concat([...lclArr].reverse()), type: 'scatter',
      fill: 'toself', fillcolor: 'rgba(37,99,235,0.06)', line: {color: 'transparent'}, showlegend: false, hoverinfo: 'skip' }
  ], {
    title: mb ? '' : 'p 관리도 (불량률)',
    yaxis: {title: mb ? '' : '불량률 (%)'},
    legend: {orientation: 'h', y: mb ? 1.22 : 1.14, font: {size: mb ? 9 : 12}},
    height: chartHeight(450, 340),
    margin: mb ? {t: 30, b: 40, l: 40, r: 20} : {t: 60, b: 50, l: 60, r: 40},
    annotations: outIdx.slice(0, 8).map(i => ({
      x: dates[i], y: rates[i], text: dateKR(byDate[i].생산일자) + '<br>' + pct(rates[i]),
      showarrow: true, arrowhead: 2, ax: 0, ay: -35,
      font: {color: '#DC2626', size: mb ? 8 : 10}, bgcolor: 'rgba(254,226,226,0.85)', borderpad: 3
    }))
  }, getPlotCfg());

  // p 관리도 하단에 서브그룹 크기(nᵢ) 차트 추가
  const niEl = document.createElement('div');
  niEl.style.marginTop = '8px';
  if (!el.parentElement) return;
  el.parentElement.appendChild(niEl);
  Plotly.newPlot(niEl, [{
    x: dates, y: byDate.map(r => r.생산수량), type: 'bar', name: '서브그룹 크기 (nᵢ)',
    marker: {color: '#94A3B8', opacity: 0.7},
    hovertemplate: '%{x}<br>검사수: %{y:,}<extra></extra>'
  }], {
    title: mb ? '' : '서브그룹 크기 (일자별 생산수량)',
    yaxis: {title: mb ? '' : '검사수 (nᵢ)'},
    height: chartHeight(200, 150),
    margin: mb ? {t: 20, b: 30, l: 40, r: 20} : {t: 40, b: 40, l: 60, r: 40}
  }, getPlotCfg());
}

/* ================================================================
   Phase 1: 수율 분석
   ================================================================ */
function chartYieldGauge(kpi, el) {
  const yieldRate = kpi.총생산수량 ? (kpi.총양품수량/kpi.총생산수량*100) : 0;
  Plotly.newPlot(el, [{
    type:'indicator', mode:'gauge+number+delta',
    value: yieldRate, number:{suffix:'%',font:{size:42}},
    title:{text:'전체 수율',font:{size:16}},
    gauge:{
      axis:{range:[80,100],ticksuffix:'%'},
      bar:{color:'#2563EB'},
      steps:[{range:[80,90],color:'#FEE2E2'},{range:[90,95],color:'#FEF3C7'},{range:[95,100],color:'#D1FAE5'}],
      threshold:{line:{color:'#DC2626',width:3},thickness:.75,value:98}
    }
  }], {height:280,margin:{t:40,b:20,l:30,r:30}}, getPlotCfg());
}

function chartYieldByItem(byItem, el) {
  if (!byItem || !byItem.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const sorted = [...byItem].sort((a,b)=>(a.양품수량/a.생산수량)-(b.양품수량/b.생산수량)).slice(0,20);
  const mb=isMobile();
  const labels=sorted.map(r=>r.품명.length>(mb?18:30)?r.품명.slice(0,mb?18:30)+'...':r.품명);
  const yields=sorted.map(r=>r.생산수량?r.양품수량/r.생산수량*100:0);
  const yieldMin = yields.length ? Math.min(...yields) : 0;
  const colors=yields.map(v=>v>=98?'#16A34A':v>=95?'#F59E0B':'#DC2626');
  Plotly.newPlot(el,[{
    y:labels,x:yields,type:'bar',orientation:'h',marker:{color:colors},
    text:yields.map(v=>pct(v,1)),textposition:'outside',textfont:{size:mb?9:11}
  }],{
    title:mb?'':'품목별 수율 하위 20',xaxis:{title:mb?'':'수율 (%)',range:[Math.max(0,yieldMin-5),101]},
    shapes:[{type:'line',x0:98,x1:98,y0:0,y1:1,yref:'paper',line:{dash:'dash',color:'#DC2626',width:2}}],
    height:Math.max(mb?350:450,sorted.length*(mb?25:30)+80),
    margin:mb?{l:140,r:60,t:20,b:30}:{l:240,r:80,t:50,b:40}
  },getPlotCfg());
}

function chartYieldTrend(byDate, el) {
  if (!byDate || !byDate.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const dates=byDate.map(r=>dateKR(r.생산일자));
  const yields=byDate.map(r=>r.생산수량?r.양품수량/r.생산수량*100:0);
  const yieldMin = yields.length ? Math.min(...yields) : 0;
  const mb=isMobile();
  const targetYield = 100 - targetDefectRate;
  Plotly.newPlot(el,[
    {x:dates,y:yields,type:'scatter',mode:'lines+markers',name:'일별 수율',
      line:{color:'#16A34A',width:2},marker:{size:mb?4:6}},
    {x:[dates[0],dates[dates.length-1]],y:[98,98],type:'scatter',mode:'lines',name:'목표 98%',
      line:{color:'#DC2626',width:2,dash:'dash'}},
    {x:[dates[0],dates[dates.length-1]],y:[targetYield,targetYield],type:'scatter',mode:'lines',
      name:'목표 수율('+targetYield.toFixed(1)+'%)',
      line:{color:'#16A34A',width:1.5,dash:'dash'}}
  ],{
    title:mb?'':'일자별 수율 추이',yaxis:{title:mb?'':'수율 (%)',range:[Math.max(0,Math.min(yieldMin,targetYield)-3),101]},
    legend:{orientation:'h',y:mb?1.15:1.12,font:{size:mb?10:12}},
    height:chartHeight(380,280),margin:mb?{t:30,b:40,l:40,r:20}:{t:60,b:50,l:60,r:40}
  },getPlotCfg());
}

/* ================================================================
   Phase 1-B: 추가 차트 함수 (요일별 패턴 / 수율 목표 / 수율 분포)
   ================================================================ */
function chartWeekdayPattern(byDate, el) {
  if (!byDate || !byDate.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const dayNames = ['일','월','화','수','목','금','토'];
  const dayData = {}; // {0:[],1:[],...6:[]}
  byDate.forEach(r => {
    const d = new Date(r.생산일자).getDay();
    if (!dayData[d]) dayData[d] = [];
    dayData[d].push(r.불량률 * 100);
  });
  const labels = [], avgs = [], counts = [], colors = [];
  for (let i = 1; i <= 5; i++) { // 월~금
    labels.push(dayNames[i] + '요일');
    const arr = dayData[i] || [];
    const avg = arr.length ? arr.reduce((s,v) => s+v, 0) / arr.length : 0;
    avgs.push(+avg.toFixed(2));
    counts.push(arr.length);
  }
  // 토/일 데이터가 있으면 추가
  [6, 0].forEach(i => {
    if (dayData[i] && dayData[i].length) {
      labels.push(dayNames[i] + '요일');
      const arr = dayData[i];
      avgs.push(+(arr.reduce((s,v) => s+v, 0) / arr.length).toFixed(2));
      counts.push(arr.length);
    }
  });
  const maxAvg = Math.max(...avgs);
  avgs.forEach(v => colors.push(v >= maxAvg * 0.9 ? '#DC2626' : v >= maxAvg * 0.7 ? '#F59E0B' : '#16A34A'));
  const mb = isMobile();
  Plotly.newPlot(el, [{
    x: labels, y: avgs, type: 'bar',
    marker: { color: colors, opacity: 0.85 },
    text: avgs.map((v, i) => `${pct(v,2)} (${counts[i]}일)`),
    textposition: 'outside', textfont: { size: mb ? 10 : 12 },
    hovertemplate: '<b>%{x}</b><br>평균 불량률: %{y:.2f}%<br>데이터 수: %{text}<extra></extra>'
  }], {
    yaxis: { title: mb ? '' : '평균 불량률 (%)', rangemode: 'tozero' },
    height: chartHeight(350, 260),
    margin: mb ? { t: 20, b: 40, l: 40, r: 20 } : { t: 30, b: 50, l: 60, r: 40 },
    annotations: [{
      text: '🔴 가장 높은 요일에 주목하세요',
      xref: 'paper', yref: 'paper', x: 1, y: 1.05,
      showarrow: false, font: { size: 11, color: '#6B7280' }
    }]
  }, getPlotCfg());
}

function chartWeekdayScatter(byDate, el) {
  if (!byDate || !byDate.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const prods = byDate.map(r => r.생산수량);
  const rates = byDate.map(r => r.불량률 * 100);
  const texts = byDate.map(r => dateKR(r.생산일자));
  const mb = isMobile();
  // 상관계수 계산
  const n = prods.length;
  const avgP = prods.reduce((s,v) => s+v, 0) / n;
  const avgR = rates.reduce((s,v) => s+v, 0) / n;
  let num = 0, denP = 0, denR = 0;
  for (let i = 0; i < n; i++) {
    num += (prods[i] - avgP) * (rates[i] - avgR);
    denP += (prods[i] - avgP) ** 2;
    denR += (rates[i] - avgR) ** 2;
  }
  const corr = (denP && denR) ? (num / Math.sqrt(denP * denR)) : 0;
  const corrText = corr > 0.5 ? '강한 양의 상관 (과부하 가능성)' : corr > 0.2 ? '약한 양의 상관' : corr < -0.2 ? '음의 상관' : '상관 없음';

  Plotly.newPlot(el, [{
    x: prods, y: rates, type: 'scatter', mode: 'markers',
    marker: { size: mb ? 6 : 9, color: rates, colorscale: 'RdYlGn', reversescale: true, showscale: !mb,
      colorbar: { title: '불량률%', thickness: 12 } },
    text: texts, hovertemplate: '<b>%{text}</b><br>생산: %{x:,}개<br>불량률: %{y:.2f}%<extra></extra>'
  }], {
    xaxis: { title: mb ? '' : '일별 생산수량' },
    yaxis: { title: mb ? '' : '불량률 (%)' },
    height: chartHeight(350, 260),
    margin: mb ? { t: 30, b: 40, l: 40, r: 20 } : { t: 40, b: 50, l: 60, r: 60 },
    annotations: [{
      text: `상관계수: ${corr.toFixed(3)} → ${corrText}`,
      xref: 'paper', yref: 'paper', x: 0.5, y: 1.08,
      showarrow: false, font: { size: mb ? 10 : 12, color: Math.abs(corr) > 0.3 ? '#DC2626' : '#6B7280' }
    }]
  }, getPlotCfg());
}

function renderYieldTarget(byItem, kpi, el) {
  if (!byItem || !byItem.length) return;
  const target = 98;
  const passItems = byItem.filter(r => r.생산수량 && (r.양품수량 / r.생산수량 * 100) >= target);
  const failItems = byItem.filter(r => r.생산수량 && (r.양품수량 / r.생산수량 * 100) < target);
  const totalItems = byItem.filter(r => r.생산수량 > 0);
  const achieveRate = totalItems.length ? (passItems.length / totalItems.length * 100).toFixed(1) : 0;
  el.innerHTML = `<div class="yield-target-summary">
    <div class="yield-target-card pass">
      <div class="ytc-label">목표 달성 품목</div>
      <div class="ytc-value">${passItems.length}개</div>
      <div class="ytc-sub">수율 ${target}% 이상</div>
    </div>
    <div class="yield-target-card fail">
      <div class="ytc-label">목표 미달 품목</div>
      <div class="ytc-value">${failItems.length}개</div>
      <div class="ytc-sub">수율 ${target}% 미만</div>
    </div>
    <div class="yield-target-card total">
      <div class="ytc-label">목표 달성률</div>
      <div class="ytc-value">${achieveRate}%</div>
      <div class="ytc-sub">전체 ${totalItems.length}개 품목 중</div>
    </div>
  </div>`;
}

function chartYieldDistribution(byItem, el) {
  if (!byItem || !byItem.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const yields = byItem.filter(r => r.생산수량 > 0).map(r => r.양품수량 / r.생산수량 * 100);
  const bins = [
    { label: '90% 미만', min: 0, max: 90, color: '#DC2626', count: 0 },
    { label: '90~95%', min: 90, max: 95, color: '#F59E0B', count: 0 },
    { label: '95~98%', min: 95, max: 98, color: '#3B82F6', count: 0 },
    { label: '98~100%', min: 98, max: 100.01, color: '#16A34A', count: 0 }
  ];
  yields.forEach(v => {
    for (const b of bins) { if (v >= b.min && v < b.max) { b.count++; break; } }
  });
  const mb = isMobile();
  Plotly.newPlot(el, [{
    x: bins.map(b => b.label),
    y: bins.map(b => b.count),
    type: 'bar',
    marker: { color: bins.map(b => b.color), opacity: 0.85 },
    text: bins.map(b => `${b.count}개 (${(b.count / yields.length * 100).toFixed(1)}%)`),
    textposition: 'outside',
    textfont: { size: mb ? 10 : 12 },
    hovertemplate: '<b>%{x}</b><br>품목 수: %{y}개<br>%{text}<extra></extra>'
  }], {
    yaxis: { title: mb ? '' : '품목 수', dtick: Math.max(1, Math.ceil(Math.max(...bins.map(b => b.count)) / 5)) },
    height: chartHeight(350, 260),
    margin: mb ? { t: 20, b: 50, l: 35, r: 20 } : { t: 30, b: 50, l: 60, r: 40 }
  }, getPlotCfg());
}

function getItemTrendBadge(itemName, filtered) {
  if (!filtered || !filtered.length) return { cls: 'stable', text: '─ 데이터 부족' };
  const rows = filtered.filter(r => r.품명 === itemName).sort((a,b) => new Date(a.생산일자) - new Date(b.생산일자));
  if (rows.length < 4) return { cls: 'stable', text: '─ 데이터 부족' };
  const mid = Math.floor(rows.length / 2);
  const firstHalf = rows.slice(0, mid);
  const secondHalf = rows.slice(mid);
  const avgFirst = firstHalf.reduce((s,r) => s + (r.불량수량 / r.생산수량), 0) / firstHalf.length * 100;
  const avgSecond = secondHalf.reduce((s,r) => s + (r.불량수량 / r.생산수량), 0) / secondHalf.length * 100;
  const diff = avgSecond - avgFirst;
  if (diff > 0.5) return { cls: 'up', text: `▲ 악화 +${diff.toFixed(1)}%p` };
  if (diff < -0.5) return { cls: 'down', text: `▼ 개선 ${diff.toFixed(1)}%p` };
  return { cls: 'stable', text: '─ 안정' };
}

/* ================================================================
   Phase 2: 기간 비교
   ================================================================ */
function renderPeriodComparison(data, el) {
  if (!data || !data.length) {
    el.innerHTML = '<div class="chart-box"><h3>기간 비교 분석</h3><p style="color:var(--text-light);padding:20px">원본 데이터가 필요합니다. 새 파일을 업로드하면 기간 비교가 가능합니다.</p></div>';
    return;
  }
  const dates=data.map(r=>dateStr(r.생산일자)).sort();
  const minD=dates[0], maxD=dates[dates.length-1];
  const mid=dates[Math.floor(dates.length/2)];
  el.innerHTML=`
    <div class="chart-box"><h3>기간 비교 분석</h3>
    <div class="cmp-periods" style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:16px;">
      <div style="flex:1;min-width:200px">
        <label style="font-size:13px;font-weight:600">기간 A (이전)</label>
        <input type="date" id="cmpA1" value="${minD}" min="${minD}" max="${maxD}" style="width:48%;display:inline-block">
        <input type="date" id="cmpA2" value="${mid}" min="${minD}" max="${maxD}" style="width:48%;display:inline-block">
      </div>
      <div style="flex:1;min-width:200px">
        <label style="font-size:13px;font-weight:600">기간 B (이후)</label>
        <input type="date" id="cmpB1" value="${mid}" min="${minD}" max="${maxD}" style="width:48%;display:inline-block">
        <input type="date" id="cmpB2" value="${maxD}" min="${minD}" max="${maxD}" style="width:48%;display:inline-block">
      </div>
      <button class="btn btn-primary btn-sm" id="btnCompare">비교 실행</button>
    </div>
    <div id="cmpResult"></div></div>`;
  $('btnCompare').addEventListener('click',()=>runComparison(data));
}

function runComparison(data) {
  const a1=$('cmpA1').value,a2=$('cmpA2').value,b1=$('cmpB1').value,b2=$('cmpB2').value;
  const allDates = data.map(r=>dateStr(r.생산일자)).sort();
  const dataMin = allDates[0], dataMax = allDates[allDates.length-1];
  if (!a1 || !a2 || !b1 || !b2) {
    $('cmpResult').innerHTML = '<div class="info-box warn">비교 기간을 모두 선택해 주세요.</div>';
    return;
  }
  if (a1 > a2 || b1 > b2) {
    $('cmpResult').innerHTML = '<div class="info-box warn">기간 시작일이 종료일보다 늦을 수 없습니다.</div>';
    return;
  }
  const grpA=data.filter(r=>{const d=dateStr(r.생산일자);return d>=a1&&d<=a2;});
  const grpB=data.filter(r=>{const d=dateStr(r.생산일자);return d>=b1&&d<=b2;});
  if(!grpA.length||!grpB.length){
    $('cmpResult').innerHTML =
      `<div class="info-box warn">
        두 기간 모두 데이터가 있어야 합니다.<br>
        데이터 보유 범위: <b>${dataMin} ~ ${dataMax}</b><br>
        요청 A: ${a1} ~ ${a2} (${grpA.length}건), 요청 B: ${b1} ~ ${b2} (${grpB.length}건)
      </div>`;
    return;
  }

  const datesA = grpA.map(r=>dateStr(r.생산일자)).sort();
  const datesB = grpB.map(r=>dateStr(r.생산일자)).sort();
  const reqA = `${a1} ~ ${a2}`;
  const reqB = `${b1} ~ ${b2}`;
  const actA = `${datesA[0]} ~ ${datesA[datesA.length-1]}`;
  const actB = `${datesB[0]} ~ ${datesB[datesB.length-1]}`;
  const daysA = new Set(datesA).size;
  const daysB = new Set(datesB).size;
  const partialA = (a1 < dataMin || a2 > dataMax || actA !== reqA);
  const partialB = (b1 < dataMin || b2 > dataMax || actB !== reqB);
  const periodBoxClass = (partialA || partialB) ? 'warn' : 'info';
  const periodBoxText = (partialA || partialB)
    ? '<span style="color:var(--danger);font-weight:700">요청 기간과 실제 분석 기간이 다릅니다. (데이터 없는 구간 제외)</span>'
    : '<span style="color:var(--success);font-weight:700">요청 기간과 실제 분석 기간이 동일합니다.</span>';

  const kA=calcKPI(grpA),kB=calcKPI(grpB);
  const items=[
    {label:'생산수량',a:kA.총생산수량,b:kB.총생산수량,fmt:fmt},
    {label:'불량수량',a:kA.총불량수량,b:kB.총불량수량,fmt:fmt},
    {label:'불량률(%)',a:kA.불량률,b:kB.불량률,fmt:v=>pct(v)},
    {label:'불량 PPM',a:kA.PPM,b:kB.PPM,fmt:v=>fmt(Math.round(v))},
  ];
  let html = `<div class="info-box ${periodBoxClass}" style="margin-bottom:12px;line-height:1.7">
    ${periodBoxText}<br>
    데이터 보유 범위: <b>${dataMin} ~ ${dataMax}</b><br>
    기간 A 요청: ${reqA} / 실제 사용: <b>${actA}</b> (${daysA}일, ${grpA.length}건)<br>
    기간 B 요청: ${reqB} / 실제 사용: <b>${actB}</b> (${daysB}일, ${grpB.length}건)
  </div>`;
  html += '<div class="kpi-grid" style="grid-template-columns:repeat(4,1fr);margin-bottom:16px">';
  for(const it of items){
    const diff=it.b-it.a;
    const arrow=it.label.includes('불량')?(diff>0?'▲ 악화':'▼ 개선'):(diff>0?'▲ 증가':'▼ 감소');
    const color=it.label.includes('불량')?(diff>0?'var(--danger)':'var(--success)'):(diff>0?'var(--success)':'var(--warning)');
    html+=`<div class="kpi-card"><div class="label">${it.label}</div>
      <div style="font-size:13px;color:var(--text-light)">A: ${it.fmt(it.a)}</div>
      <div style="font-size:13px;color:var(--text-light)">B: ${it.fmt(it.b)}</div>
      <div class="value" style="font-size:16px;color:${color}">${arrow} ${it.label.includes('률') ? pct(Math.abs(diff)) : (it.label.toUpperCase().includes('PPM') ? fmt(Math.round(Math.abs(diff))) : fmt(Math.abs(diff)))}</div></div>`;
  }
  html+='</div>';

  // 품목별 변화
  const itemA=aggByItem(grpA),itemB=aggByItem(grpB);
  const itemMap=new Map();
  itemA.forEach(r=>itemMap.set(r.품명,{a:r.불량률*100,b:0,aProd:r.생산수량,bProd:0,aDef:r.불량수량,bDef:0}));
  itemB.forEach(r=>{
    if(itemMap.has(r.품명)){const m=itemMap.get(r.품명);m.b=r.불량률*100;m.bProd=r.생산수량;m.bDef=r.불량수량;}
    else itemMap.set(r.품명,{a:0,b:r.불량률*100,aProd:0,bProd:r.생산수량,aDef:0,bDef:r.불량수량});
  });
  const changes=[...itemMap.entries()].map(([k,v])=>({품명:k,...v,변화:v.b-v.a})).sort((a,b)=>a.변화-b.변화);
  const top5=changes.slice(0,5),worst5=changes.slice(-5).reverse();

  // ── 핵심 인사이트 분석 ──
  const diffRate = kB.불량률 - kA.불량률;
  const diffProd = kB.총생산수량 - kA.총생산수량;
  const diffDef = kB.총불량수량 - kA.총불량수량;
  const yieldA = kA.총생산수량 ? (kA.총양품수량 / kA.총생산수량 * 100) : 0;
  const yieldB = kB.총생산수량 ? (kB.총양품수량 / kB.총생산수량 * 100) : 0;
  const diffYield = yieldB - yieldA;
  const improvedItems = changes.filter(r => r.변화 < -0.1).length;
  const worsenedItems = changes.filter(r => r.변화 > 0.1).length;
  const stableItems = changes.length - improvedItems - worsenedItems;
  const newInB = changes.filter(r => r.a === 0 && r.b > 0);
  const removedInB = changes.filter(r => r.a > 0 && r.b === 0);

  // 불량유형별 비교
  let defectTypeInsight = '';
  if (defectCols.length) {
    const dtA = {}, dtB = {};
    defectCols.forEach(dc => { dtA[dc] = grpA.reduce((s,r) => s + (r[dc]||0), 0); dtB[dc] = grpB.reduce((s,r) => s + (r[dc]||0), 0); });
    const dtChanges = defectCols.map(dc => ({ type: dc, a: dtA[dc], b: dtB[dc], diff: dtB[dc] - dtA[dc] })).sort((a,b) => b.diff - a.diff);
    const worstDT = dtChanges.filter(d => d.diff > 0);
    const bestDT = dtChanges.filter(d => d.diff < 0);
    if (worstDT.length) defectTypeInsight += `<span style="color:var(--danger)">증가 불량유형:</span> ${worstDT.slice(0,3).map(d => `${d.type}(+${fmt(d.diff)}건)`).join(', ')}`;
    if (bestDT.length) defectTypeInsight += `${worstDT.length ? ' | ' : ''}<span style="color:var(--success)">감소 불량유형:</span> ${bestDT.slice(0,3).map(d => `${d.type}(${fmt(d.diff)}건)`).join(', ')}`;
  }

  // 종합 판정
  let verdict, verdictColor, verdictIcon;
  if (diffRate < -0.5) { verdict = '품질 대폭 개선'; verdictColor = '#16A34A'; verdictIcon = '🟢'; }
  else if (diffRate < -0.1) { verdict = '품질 소폭 개선'; verdictColor = '#16A34A'; verdictIcon = '🟢'; }
  else if (diffRate <= 0.1) { verdict = '품질 유지 (안정)'; verdictColor = '#F59E0B'; verdictIcon = '🟡'; }
  else if (diffRate <= 0.5) { verdict = '품질 소폭 악화'; verdictColor = '#DC2626'; verdictIcon = '🔴'; }
  else { verdict = '품질 대폭 악화'; verdictColor = '#DC2626'; verdictIcon = '🔴'; }

  html += `<div style="background:var(--card-bg);border:1px solid var(--border);border-radius:12px;padding:16px 20px;margin-bottom:16px">`;
  html += `<h4 style="margin:0 0 12px 0;font-size:15px">📊 핵심 인사이트</h4>`;

  // 종합 판정 배너
  html += `<div style="background:${verdictColor}15;border-left:4px solid ${verdictColor};padding:10px 14px;border-radius:0 8px 8px 0;margin-bottom:12px;font-weight:700;font-size:15px;color:${verdictColor}">`;
  html += `${verdictIcon} 종합 판정: ${verdict} (불량률 ${diffRate > 0 ? '+' : ''}${pct(diffRate)}%p)`;
  html += `</div>`;

  // 핵심 지표 요약
  html += `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px;margin-bottom:12px">`;
  html += `<div style="padding:8px 12px;background:var(--bg);border-radius:8px;font-size:13px">`;
  html += `<span style="color:var(--text-light)">수율 변화</span><br><strong style="color:${diffYield>=0?'var(--success)':'var(--danger)'}">${yieldA.toFixed(2)}% → ${yieldB.toFixed(2)}% (${diffYield>0?'+':''}${diffYield.toFixed(2)}%p)</strong></div>`;
  html += `<div style="padding:8px 12px;background:var(--bg);border-radius:8px;font-size:13px">`;
  html += `<span style="color:var(--text-light)">일평균 생산</span><br><strong>A: ${fmt(Math.round(kA.총생산수량/kA.생산일수))}개 → B: ${fmt(Math.round(kB.총생산수량/kB.생산일수))}개</strong></div>`;
  html += `<div style="padding:8px 12px;background:var(--bg);border-radius:8px;font-size:13px">`;
  html += `<span style="color:var(--text-light)">일평균 불량</span><br><strong style="color:${kB.총불량수량/kB.생산일수 <= kA.총불량수량/kA.생산일수 ? 'var(--success)':'var(--danger)'}">A: ${fmt(Math.round(kA.총불량수량/kA.생산일수))}개 → B: ${fmt(Math.round(kB.총불량수량/kB.생산일수))}개</strong></div>`;
  html += `<div style="padding:8px 12px;background:var(--bg);border-radius:8px;font-size:13px">`;
  html += `<span style="color:var(--text-light)">목표(${targetDefectRate}%) 대비</span><br><strong style="color:${kB.불량률 <= targetDefectRate ? 'var(--success)':'var(--danger)'}">A: ${kA.불량률 <= targetDefectRate ? '달성':'초과'} → B: ${kB.불량률 <= targetDefectRate ? '달성':'초과'}</strong></div>`;
  html += `</div>`;

  // 품목 변화 요약
  html += `<div style="font-size:13px;line-height:1.8;color:var(--text)">`;
  html += `<div>📦 <strong>품목 변화:</strong> 개선 <span style="color:var(--success);font-weight:700">${improvedItems}개</span> | 악화 <span style="color:var(--danger);font-weight:700">${worsenedItems}개</span> | 안정 <span style="color:var(--text-light);font-weight:700">${stableItems}개</span></div>`;
  if (newInB.length) html += `<div>🆕 <strong>B기간 신규 불량 품목:</strong> ${newInB.slice(0,5).map(r => `${r.품명}(${pct(r.b)})`).join(', ')}${newInB.length > 5 ? ` 외 ${newInB.length-5}개` : ''}</div>`;
  if (removedInB.length) html += `<div>✅ <strong>B기간 불량 해소 품목:</strong> ${removedInB.slice(0,5).map(r => r.품명).join(', ')}${removedInB.length > 5 ? ` 외 ${removedInB.length-5}개` : ''}</div>`;
  if (worst5.length && worst5[0].변화 > 0) html += `<div>⚠️ <strong>가장 악화된 품목:</strong> ${worst5[0].품명} (${pct(worst5[0].a)}% → ${pct(worst5[0].b)}%, <span style="color:var(--danger)">+${pct(worst5[0].변화)}%p</span>)</div>`;
  if (top5.length && top5[0].변화 < 0) html += `<div>🏆 <strong>가장 개선된 품목:</strong> ${top5[0].품명} (${pct(top5[0].a)}% → ${pct(top5[0].b)}%, <span style="color:var(--success)">${pct(top5[0].변화)}%p</span>)</div>`;
  if (defectTypeInsight) html += `<div>🔧 <strong>불량유형 변화:</strong> ${defectTypeInsight}</div>`;
  html += `</div></div>`;

  html+='<div style="display:flex;gap:12px;flex-wrap:wrap">';
  html+='<div style="flex:1;min-width:250px"><h4 style="color:var(--success);margin-bottom:8px">개선 TOP 5</h4>';
  html+='<div class="tbl-wrap"><table class="data-tbl"><thead><tr><th>품명</th><th>A 불량률</th><th>B 불량률</th><th>변화</th></tr></thead><tbody>';
  top5.forEach(r=>html+=`<tr><td>${r.품명}</td><td>${pct(r.a)}</td><td>${pct(r.b)}</td><td style="color:var(--success)">${pct(r.변화,2)}</td></tr>`);
  html+='</tbody></table></div></div>';
  html+='<div style="flex:1;min-width:250px"><h4 style="color:var(--danger);margin-bottom:8px">악화 TOP 5</h4>';
  html+='<div class="tbl-wrap"><table class="data-tbl"><thead><tr><th>품명</th><th>A 불량률</th><th>B 불량률</th><th>변화</th></tr></thead><tbody>';
  worst5.forEach(r=>html+=`<tr><td>${r.품명}</td><td>${pct(r.a)}</td><td>${pct(r.b)}</td><td style="color:var(--danger)">+${pct(r.변화,2)}</td></tr>`);
  html+='</tbody></table></div></div></div>';

  $('cmpResult').innerHTML=html;
}

/* ================================================================
   Phase 2: 품목 심층분석 (드릴다운)
   ================================================================ */
function renderDrilldown(data, byItem, el) {
  const hasRawData = data && data.length > 0;
  let html='<div class="chart-box"><h3>품목 심층 분석</h3>';
  if (!hasRawData) {
    html += '<div class="info-box warn" style="margin-bottom:12px">저장된 데이터에서 복원 중입니다. 새 파일을 업로드하면 더 상세한 분석이 가능합니다.</div>';
  }
  html+='<div style="margin-bottom:12px"><label style="font-size:13px;font-weight:600">품목 선택</label>';
  html+='<select id="drillItem" style="width:100%"><option value="">-- 선택하세요 --</option>';
  [...byItem].sort((a,b)=>b.불량률-a.불량률).forEach(r=>html+=`<option value="${r.품명}">${r.품명} (불량률 ${pct(r.불량률*100)})</option>`);
  html+='</select></div><div id="drillResult"></div></div>';
  el.innerHTML=html;
  $('drillItem').addEventListener('change',()=>{
    const item=$('drillItem').value;
    if(!item){$('drillResult').innerHTML='';if(isMobile())$('drillModal').classList.remove('open');return;}

    // 원본 행 데이터가 있으면 필터링, 없으면 byItem 집계로 대체
    let rows, byD;
    if (hasRawData) {
      rows = data.filter(r=>r.품명===item);
      byD = aggByDate(rows);
    } else {
      // byItem에서 해당 품목의 집계 데이터로 대체
      const itemSummary = byItem.find(r => r.품명 === item);
      rows = itemSummary ? [itemSummary] : [];
      byD = itemSummary ? [{
        생산일자: itemSummary.생산일자 || '집계',
        생산수량: itemSummary.생산수량,
        양품수량: itemSummary.양품수량,
        불량수량: itemSummary.불량수량,
        불량률: itemSummary.불량률,
        PPM: Number.isFinite(itemSummary.PPM) ? itemSummary.PPM : calcPPM(itemSummary.불량수량, itemSummary.생산수량),
        ...defectCols.reduce((o, dc) => { o[dc] = itemSummary[dc] || 0; return o; }, {})
      }] : [];
    }
    const mb=isMobile();

    // 모바일: 모달에 표시 / PC: drillResult에 표시
    const targetEl = mb ? $('drillModalContent') : null;

    let rHtml=`<h3 style="margin-bottom:12px;font-size:16px">${item}</h3>`;
    rHtml+='<div class="kpi-grid" style="grid-template-columns:repeat('+( mb?'2':'5')+',1fr);margin:12px 0">';
    const totP=rows.reduce((s,r)=>s+r.생산수량,0), totB=rows.reduce((s,r)=>s+r.불량수량,0);
    rHtml+=`<div class="kpi-card"><div class="value" style="color:var(--primary)">${fmt(totP)}</div><div class="label">총 생산</div></div>`;
    rHtml+=`<div class="kpi-card"><div class="value" style="color:var(--success)">${fmt(totP-totB)}</div><div class="label">양품</div></div>`;
    rHtml+=`<div class="kpi-card"><div class="value" style="color:var(--danger)">${fmt(totB)}</div><div class="label">불량</div></div>`;
    rHtml+=`<div class="kpi-card"><div class="value" style="color:var(--warning)">${pct(totP?totB/totP*100:0)}</div><div class="label">불량률</div></div>`;
    rHtml+=`<div class="kpi-card"><div class="value" style="color:var(--warning)">${fmt(Math.round(calcPPM(totB, totP)))}</div><div class="label">PPM</div></div>`;
    rHtml+='</div>';
    const trendId = mb ? 'drillTrendM' : 'drillTrend';
    const pieId = mb ? 'drillPieM' : 'drillDefectPie';
    rHtml+=`<div id="${trendId}"></div>`;
    if(defectCols.length) rHtml+=`<div id="${pieId}" style="margin-top:16px"></div>`;

    if (mb) {
      targetEl.innerHTML = rHtml;
      $('drillModal').classList.add('open');
      document.body.style.overflow = 'hidden';
    } else {
      $('drillResult').innerHTML = rHtml;
    }

    // 일자별 추이
    const dates=byD.map(r=>dateKR(r.생산일자));
    setTimeout(()=>{
      const tEl = document.getElementById(trendId);
      if(!tEl) return;
      Plotly.newPlot(tEl,[
        {x:dates,y:byD.map(r=>r.생산수량),type:'bar',name:'생산수량',marker:{color:'#2563EB',opacity:.7}},
        {x:dates,y:byD.map(r=>r.불량률*100),type:'scatter',mode:'lines+markers',name:'불량률(%)',
          line:{color:'#DC2626',width:2},marker:{size:mb?5:7},yaxis:'y2'}
      ],{
        yaxis:{title:mb?'':'생산수량'},yaxis2:{title:mb?'':'불량률(%)',overlaying:'y',side:'right'},
        legend:{orientation:'h',y:mb?1.15:1.12},height:chartHeight(350,260),
        margin:mb?{t:20,b:40,l:40,r:40}:{t:40,b:50,l:60,r:60}
      },getPlotCfg());

      // 불량유형 파이
      if(defectCols.length){
        const totals=defectCols.map(dc=>({type:dc,val:rows.reduce((s,r)=>s+r[dc],0)})).filter(t=>t.val>0);
        const pEl = document.getElementById(pieId);
        if(totals.length && pEl){
          Plotly.newPlot(pEl,[{
            labels:totals.map(t=>t.type),values:totals.map(t=>t.val),type:'pie',hole:.4,
            textinfo:'label+percent',textfont:{size:mb?10:12}
          }],{title:mb?'':'불량유형 분포',height:chartHeight(350,280),
            margin:mb?{t:30,b:20,l:20,r:20}:{t:50,b:30,l:40,r:40}},getPlotCfg());
        }
      }
    }, mb ? 300 : 50);
  });
}

/* ================================================================
   Phase 2: 테이블 강화 (정렬 + 검색 + 조건부서식)
   ================================================================ */
function makeTableEnhanced(headers, rows, id) {
  let html='<div class="scroll-hint">&#8592; 좌우 스크롤 가능 &#8594;</div>';
  html+=`<input type="text" placeholder="검색..." style="width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:8px;margin-bottom:8px;font-size:13px;min-height:40px" onInput="filterTable('${id}',this.value)">`;
  html+=`<div class="tbl-wrap"><table class="data-tbl" id="${id}"><thead><tr>`;
  headers.forEach((h,i)=>html+=`<th style="cursor:pointer" onclick="sortTable('${id}',${i})">${h} ↕</th>`);
  html+='</tr></thead><tbody>';

  // 숫자 컬럼 판별 (첫 번째 컬럼 = 날짜/품명이므로 제외)
  const numHeaders = new Set(headers.filter((h,i) => i > 0 && rows.length > 0 && typeof rows[0][h] === 'number'));

  for(let ri=0; ri<rows.length; ri++){
    const row = rows[ri];
    const prev = ri > 0 ? rows[ri-1] : null;
    // 불량률 기준 행 배경색 (전일 대비)
    let rowStyle='';
    const rateH = headers.find(h=>h.includes('률'));
    if(prev && rateH && typeof row[rateH]==='number' && typeof prev[rateH]==='number'){
      const rd=row[rateH]-prev[rateH];
      if(rd>0.0001) rowStyle='background:rgba(220,38,38,0.04)';
      else if(rd<-0.0001) rowStyle='background:rgba(37,99,235,0.04)';
    }
    html+=`<tr style="${rowStyle}">`;
    for(const h of headers){
      let v=row[h];
      let style='';
      let trend='';

      if(h.toUpperCase().includes('PPM') && typeof v==='number'){
        // PPM은 정수 표시가 일반적이라 반올림하여 가독성 확보
        if(prev && typeof prev[h]==='number'){
          const diff = Math.round(v) - Math.round(prev[h]);
          if(diff>0) trend=`<span style="color:#DC2626;font-size:10px;margin-left:3px">▲${fmt(Math.abs(diff))}</span>`;
          else if(diff<0) trend=`<span style="color:#2563EB;font-size:10px;margin-left:3px">▼${fmt(Math.abs(diff))}</span>`;
        }
        v = fmt(Math.round(v));
      } else if(h.includes('률')&&typeof v==='number'){
        const rate=v*100;
        // 전일 대비 증감 (소수점 3자리 + 상대변동률)
        if(prev && typeof prev[h]==='number'){
          const prevRate=prev[h]*100;
          const diff=rate-prevRate;
          const absDiff=Math.abs(diff);
          // 상대 변동률: 전일 대비 몇 % 변했는지
          const relChg = prevRate > 0 ? (diff / prevRate * 100) : 0;
          const absRel = Math.abs(relChg);
          if(diff>0.001){
            const intensity = absRel >= 30 ? 'font-weight:700;font-size:11px' : absRel >= 10 ? 'font-weight:600' : '';
            trend=`<span style="color:#DC2626;font-size:10px;margin-left:3px;${intensity}">▲${absDiff.toFixed(3)}%</span>`;
          } else if(diff<-0.001){
            const intensity = absRel >= 30 ? 'font-weight:700;font-size:11px' : absRel >= 10 ? 'font-weight:600' : '';
            trend=`<span style="color:#2563EB;font-size:10px;margin-left:3px;${intensity}">▼${absDiff.toFixed(3)}%</span>`;
          }
        }
        v=pct(rate);
        if(rate>5)style='background:#FEE2E2;color:#991B1B;font-weight:600';
        else if(rate>3)style='background:#FEF3C7;color:#92400E';
      }else if(numHeaders.has(h)&&typeof v==='number'){
        // 숫자 컬럼 전일 대비 증감
        if(prev && typeof prev[h]==='number'){
          const diff=v-prev[h];
          if(diff>0) trend=`<span style="color:#DC2626;font-size:10px;margin-left:3px">▲${fmt(Math.abs(diff))}</span>`;
          else if(diff<0) trend=`<span style="color:#2563EB;font-size:10px;margin-left:3px">▼${fmt(Math.abs(diff))}</span>`;
        }
        v=fmt(v);
      }
      html+=`<td style="${style}">${(v??'')}${trend}</td>`;
    }
    html+='</tr>';
  }
  html+='</tbody></table></div>';
  return html;
}

/* ================================================================
   AI 품질진단 (Tab9) — 헬퍼 함수
   ================================================================ */

/* 종합 품질 점수 (0~100, 감점 방식) */
function calcQualityScore(kpi, trends, anomalies, riskScores, st, targetRate) {
  if (targetRate === undefined) targetRate = targetDefectRate;
  let score = 100;
  // 1) 불량률 감점 - 목표 불량률 기준 차등 적용 (max -40)
  const dr = kpi.불량률;
  if (dr <= targetRate) {
    // 목표 달성: 목표 대비 사용 비율에 따라 0~-10점
    score -= Math.round(dr / Math.max(targetRate, 0.01) * 10);
  } else {
    // 목표 초과: 기본 -10점 + 초과 비율 추가 감점 (max -40)
    const hardCap = Math.max(targetRate * 3, 3.0);
    const excessRatio = (dr - targetRate) / Math.max(hardCap - targetRate, 0.01);
    score -= Math.min(40, 10 + Math.round(excessRatio * 30));
  }
  // 2) 위험 품목 감점 (max -20)
  score -= Math.min(20, riskScores.filter(r => r.grade === '위험').length * 7);
  // 3) 이상 징후 감점 (max -15)
  score -= Math.min(15, anomalies.filter(a => a.severity === 'danger').length * 5);
  // 4) 추세 감점 (max -15)
  if (trends.direction === '급등') score -= 15;
  else if (trends.direction === '상승') score -= 8;
  else if (trends.direction === '개선') score += 3;
  else if (trends.direction === '급감') score += 5;
  // 5) 공정 불안정 감점 (max -15)
  score -= Math.min(15, anomalies.filter(a => a.type === 'ucl').length * 5);

  score = Math.max(0, Math.min(100, Math.round(score)));
  let letterGrade = score >= 90 ? 'A' : score >= 75 ? 'B' : score >= 60 ? 'C' : score >= 45 ? 'D' : 'F';

  // 불량률 기반 등급 상한 - 목표 불량률 기준 비율로 계산
  const capF = Math.max(targetRate * 3, 3.0);
  const capD = Math.max(targetRate * 1.5, 1.5);
  const capC = Math.max(targetRate, 0.7);
  const capB = Math.max(targetRate * 0.5, 0.3);
  if      (dr >= capF)                               letterGrade = 'F';
  else if (dr >= capD && 'ABC'.includes(letterGrade)) letterGrade = 'D';
  else if (dr >= capC && 'AB'.includes(letterGrade))  letterGrade = 'C';
  else if (dr >= capB && letterGrade === 'A')         letterGrade = 'B';

  const verdicts = {
    A: '품질이 매우 우수합니다. 현재 상태를 유지하세요.',
    B: '품질이 양호합니다. 일부 항목을 모니터링하세요.',
    C: '품질에 주의가 필요합니다. 개선 활동을 시작하세요.',
    D: '품질 문제가 심각합니다. 즉각적인 점검이 필요합니다.',
    F: '긴급 상황입니다. 생산 라인을 점검하고 원인을 파악하세요.'
  };
  const colors = { A:'#16A34A', B:'#22C55E', C:'#F59E0B', D:'#EF4444', F:'#991B1B' };
  return { score, letterGrade, verdict: verdicts[letterGrade], color: colors[letterGrade] };
}

/* SVG 반원 게이지 HTML */
function drawQualityGaugeHTML(score, letterGrade, color) {
  // 0=left(180°), 100=right(0°). Arc: M25,100 A75,75 → semicircle top
  const clampScore = Math.max(0, Math.min(100, score));
  const angle = clampScore / 100 * 180;
  const rad = (180 - angle) * Math.PI / 180;
  const endX = 100 + 75 * Math.cos(rad);
  const endY = 100 - 75 * Math.sin(rad);
  const largeArc = angle > 90 ? 1 : 0;
  // score=0 → no colored arc
  const colorArc = clampScore <= 0 ? ''
    : clampScore >= 100
      ? `<path d="M 25,100 A 75,75 0 1,1 175,100" fill="none" stroke="${color}" stroke-width="16" stroke-linecap="round"/>`
      : `<path d="M 25,100 A 75,75 0 ${largeArc},1 ${endX.toFixed(1)},${endY.toFixed(1)}" fill="none" stroke="${color}" stroke-width="16" stroke-linecap="round"/>`;
  return `<svg viewBox="0 0 200 115" style="width:100%;max-width:240px">
    <path d="M 25,100 A 75,75 0 0,1 175,100" fill="none" stroke="#E5E7EB" stroke-width="16" stroke-linecap="round"/>
    ${colorArc}
    <text x="100" y="60" text-anchor="middle" font-size="14" font-weight="700" fill="${color}">${letterGrade}등급</text>
    <text x="100" y="90" text-anchor="middle" font-size="34" font-weight="900" fill="${color}">${score}</text>
    <text x="100" y="106" text-anchor="middle" font-size="11" fill="#9CA3AF">/ 100점</text>
  </svg>`;
}

/* 상세 분석 토글 */
function toggleAIDetail() {
  const el = document.getElementById('aiDetailSection');
  const lbl = document.getElementById('aiDetailToggleText');
  if (!el) return;
  if (el.style.display === 'none') {
    el.style.display = 'block';
    lbl.textContent = '상세 분석 접기 ▲';
    if (!el.dataset.chartsRendered) {
      el.dataset.chartsRendered = '1';
      const ctx = aiRenderContext;
      if (ctx.byItem) chartRiskMatrix(calcItemRiskScores(ctx.byItem, ctx.filtered, aiRiskSettings).filter(r => r.생산수량 >= 10), $('chartRiskMatrix'));
      if (defectCols.length && ctx.byDate) chartDefectTrends(ctx.byDate, analyzeDefectTypes(ctx.byDate), $('chartDefectTrends'));
    }
  } else {
    el.style.display = 'none';
    lbl.textContent = '상세 분석 보기 ▼';
  }
}

function linearSlope(arr) {
  const n = arr.length;
  if (n < 2) return 0;
  let sx=0, sy=0, sxx=0, sxy=0;
  for (let i=0; i<n; i++) { sx+=i; sy+=arr[i]; sxx+=i*i; sxy+=i*arr[i]; }
  const denom = n*sxx - sx*sx;
  return denom === 0 ? 0 : (n*sxy - sx*sy) / denom;
}

function aggByItemDate(data) {
  const map = new Map();
  for (const r of data) {
    const d = dateStr(r.생산일자);
    const key = r.품명 + '|' + d;
    if (!map.has(key)) {
      const o = { 품명: r.품명, 생산일자: d, 생산수량:0, 양품수량:0, 불량수량:0 };
      for (const dc of defectCols) o[dc] = 0;
      map.set(key, o);
    }
    const o = map.get(key);
    o.생산수량 += r.생산수량; o.양품수량 += r.양품수량; o.불량수량 += r.불량수량;
    for (const dc of defectCols) o[dc] += r[dc];
  }
  const arr = [...map.values()];
  arr.forEach(o => o.불량률 = o.생산수량 ? o.불량수량/o.생산수량 : 0);
  return arr;
}

/* ================================================================
   AI 품질진단 — 1. 추세 분석 (analyzeTrends)
   ================================================================ */
function analyzeTrends(byDate, filtered) {
  const result = { direction: '안정', ma7: [], ma14: [], crossType: null,
    consecutiveWorsen: 0, consecutiveImprove: 0, weekChange: 0, monthChange: 0 };
  if (!byDate || byDate.length < 3) return result;

  const rates = byDate.map(r => r.불량률 * 100);
  result.ma7 = movingAvg(byDate, '불량률', 7).map(v => v*100);
  result.ma14 = movingAvg(byDate, '불량률', 14).map(v => v*100);

  // 골든/데드 크로스 감지 (마지막 3일 내)
  const len = result.ma7.length;
  for (let i = Math.max(1, len-3); i < len; i++) {
    const prev7 = result.ma7[i-1], cur7 = result.ma7[i];
    const prev14 = result.ma14[i-1], cur14 = result.ma14[i];
    if (prev7 <= prev14 && cur7 > cur14) result.crossType = 'dead';
    if (prev7 >= prev14 && cur7 < cur14) result.crossType = 'golden';
  }

  // 연속 악화/개선
  let worsen = 0, improve = 0;
  for (let i = rates.length-1; i > 0; i--) {
    if (rates[i] > rates[i-1] + 0.001) { worsen++; if (improve > 0) break; }
    else if (rates[i] < rates[i-1] - 0.001) { improve++; if (worsen > 0) break; }
    else break;
  }
  result.consecutiveWorsen = worsen;
  result.consecutiveImprove = improve;

  // 전주/전월 대비
  const wc = calcWeekChange(filtered || byDate);
  result.weekChange = wc.변화;

  const monthly = aggByMonth(filtered || byDate);
  if (monthly.length >= 2) {
    const cur = monthly[monthly.length-1].불량률 * 100;
    const prev = monthly[monthly.length-2].불량률 * 100;
    result.monthChange = cur - prev;
  }

  // 방향 분류
  const slope = linearSlope(rates);
  const lastRate = rates[rates.length-1];
  const avgRate = rates.reduce((a,b)=>a+b,0) / rates.length;
  if (slope > 0.15 && lastRate > avgRate * 1.3) result.direction = '급등';
  else if (slope > 0.05) result.direction = '상승';
  else if (slope < -0.15 && lastRate < avgRate * 0.7) result.direction = '급감';
  else if (slope < -0.05) result.direction = '개선';
  else result.direction = '안정';

  return result;
}

/* ================================================================
   AI 품질진단 — 2. 이상 감지 (detectAnomalies)
   ================================================================ */
function detectAnomalies(byDate) {
  const anomalies = [];
  if (!byDate || byDate.length < 5) return anomalies;

  const rates = byDate.map(r => r.불량률 * 100);
  const mean = rates.reduce((a,b)=>a+b,0) / rates.length;
  const std = Math.sqrt(rates.reduce((s,v)=>s+(v-mean)*(v-mean),0) / rates.length) || 0.001;

  // Z-score 이상치
  rates.forEach((v,i) => {
    const z = (v - mean) / std;
    if (Math.abs(z) > 2.5) {
      anomalies.push({ date: byDate[i].생산일자, type: 'zscore', severity: 'danger',
        desc: `Z-score ${z.toFixed(1)} (불량률 ${pct(v)})` });
    }
  });

  // 일간 급등 (변동 > 2σ)
  for (let i = 1; i < rates.length; i++) {
    const diff = rates[i] - rates[i-1];
    if (diff > 2 * std) {
      anomalies.push({ date: byDate[i].생산일자, type: 'spike', severity: 'danger',
        desc: `일간 급등 +${pct(diff)} (${pct(rates[i-1])} → ${pct(rates[i])})` });
    }
  }

  // SPC 규칙 위반 재활용
  const n = byDate.length;
  const totalBad = byDate.reduce((s,r)=>s+r.불량수량,0);
  const totalProd = byDate.reduce((s,r)=>s+r.생산수량,0);
  const pBar = totalProd ? totalBad/totalProd : 0;
  const pBarPct = pBar * 100;

  // UCL/LCL 이탈
  byDate.forEach((r, i) => {
    const ni = Math.max(r.생산수량, 1);
    const ucl = (pBar + 3*Math.sqrt(pBar*(1-pBar)/ni))*100;
    const lcl = Math.max(0, (pBar - 3*Math.sqrt(pBar*(1-pBar)/ni))*100);
    const pi = r.불량률 * 100;
    if (pi > ucl) {
      anomalies.push({ date: r.생산일자, type: 'ucl', severity: 'danger',
        desc: `UCL 이탈 (${pct(pi)} > ${pct(ucl)})` });
    }
  });

  // 7연속 추세
  for (let i = 6; i < n; i++) {
    let up = true, dn = true;
    for (let j = i-5; j <= i; j++) { if (rates[j] <= rates[j-1]) up=false; if (rates[j] >= rates[j-1]) dn=false; }
    if (up) anomalies.push({ date: byDate[i].생산일자, type: 'trend7', severity: 'warn',
      desc: '7연속 상승 추세 감지' });
  }

  // 8연속 편측
  for (let i = 7; i < n; i++) {
    const above = rates.slice(i-7,i+1).every(v => v > pBarPct);
    if (above) anomalies.push({ date: byDate[i].생산일자, type: 'bias8', severity: 'warn',
      desc: '8연속 중심선 상방 편측' });
  }

  // 중복 제거 (같은 날짜+타입)
  const seen = new Set();
  return anomalies.filter(a => {
    const key = a.date + a.type;
    if (seen.has(key)) return false;
    seen.add(key); return true;
  }).sort((a,b) => String(a.date).localeCompare(String(b.date)));
}

/* ================================================================
   AI 품질진단 — 3. 불량유형 분석 (analyzeDefectTypes)
   ================================================================ */
function analyzeDefectTypes(byDate) {
  const result = { trends: [], hhi: 0, dominant: null, newTypes: [], disappearedTypes: [] };
  if (!defectCols.length || !byDate || byDate.length < 3) return result;

  // 유형별 추세 기울기
  result.trends = defectCols.map(dc => {
    const vals = byDate.map(r => r[dc] || 0);
    const total = vals.reduce((a,b)=>a+b,0);
    const slope = linearSlope(vals);
    return { type: dc, slope, total, direction: slope > 0.5 ? '증가' : slope < -0.5 ? '감소' : '안정' };
  }).sort((a,b) => b.slope - a.slope);

  // HHI 집중도
  const totalAll = result.trends.reduce((s,t)=>s+t.total,0) || 1;
  const shares = result.trends.map(t => t.total / totalAll);
  result.hhi = shares.reduce((s,sh)=>s+sh*sh,0);
  if (result.hhi > 0.5) {
    const top = result.trends.reduce((a,b)=>a.total>b.total?a:b);
    result.dominant = top.type;
  }

  // 신규/소멸 불량유형 (전반부 vs 후반부)
  const half = Math.floor(byDate.length / 2);
  const first = byDate.slice(0, half);
  const second = byDate.slice(half);
  defectCols.forEach(dc => {
    const sumFirst = first.reduce((s,r)=>s+(r[dc]||0),0);
    const sumSecond = second.reduce((s,r)=>s+(r[dc]||0),0);
    if (sumFirst === 0 && sumSecond > 0) result.newTypes.push(dc);
    if (sumFirst > 0 && sumSecond === 0) result.disappearedTypes.push(dc);
  });

  return result;
}

/* ================================================================
   AI 품질진단 — 4. 품목 위험도 (calcItemRiskScores)
   ================================================================ */
function calcItemRiskScores(byItem, filtered, settings = aiRiskSettings) {
  if (!byItem || !byItem.length) return [];

  // 전체 기준값 계산
  const cfg = sanitizeAiRiskSettings(settings);
  const allRates = byItem.map(r => r.불량률 * 100);
  const maxRate = Math.max(...allRates, 0.01);
  const maxProd = Math.max(...byItem.map(r => r.생산수량), 1);

  // 품목별 일별 데이터 (변동성 계산용)
  const itemDaily = new Map();
  if (filtered && filtered.length) {
    for (const r of filtered) {
      if (!itemDaily.has(r.품명)) itemDaily.set(r.품명, []);
      itemDaily.get(r.품명).push(r.불량률 * 100);
    }
  }

  return byItem.map(r => {
    const rate = r.불량률 * 100;

    // 1. 불량률 수준 (25점) - 비선형: 5% 이상이면 거의 만점
    const relativeRateScore = Math.min(25, rate / maxRate * 25 * 1.5);
    const absoluteRateFloor = rate >= cfg.dangerRatePct ? 25
      : rate >= cfg.warnRatePct ? 18
      : rate >= cfg.watchRatePct ? 12 : 0;
    const rateScore = Math.max(relativeRateScore, absoluteRateFloor);

    // 2. 추세 기울기 (25점)
    const daily = itemDaily.get(r.품명) || [];
    const slope = daily.length >= 3 ? linearSlope(daily) : 0;
    const slopeScore = Math.min(25, Math.max(0, slope * 50 + 12.5));

    // 3. 생산량 규모 (25점) - 대량생산일수록 영향 큼
    const prodScore = Math.min(25, r.생산수량 / maxProd * 25);

    // 4. 변동성 (25점)
    let rawVolScore = 0;
    let volScore = 0;
    const sampleConfidence = daily.length >= cfg.volMinSamples ? 1 : (daily.length >= 3 ? daily.length / cfg.volMinSamples : 0);
    if (daily.length >= 3) {
      const mean = daily.reduce((a,b)=>a+b,0) / daily.length;
      const std = Math.sqrt(daily.reduce((s,v)=>s+(v-mean)*(v-mean),0) / daily.length);
      rawVolScore = Math.min(25, std / (mean || 1) * 50);
      volScore = rawVolScore * sampleConfidence;
    }

    let total = Math.round(rateScore + slopeScore + prodScore + volScore);
    let forcedRule = 'none';
    if (rate >= cfg.dangerRatePct) {
      total = Math.max(total, cfg.dangerScoreFloor);
      forcedRule = 'danger_rate_gate';
    } else if (rate >= cfg.warnRatePct) {
      total = Math.max(total, cfg.warnScoreFloor);
      forcedRule = 'warn_rate_gate';
    }

    const grade = rate >= cfg.dangerRatePct
      ? '위험'
      : (total >= cfg.gradeDangerCut ? '위험' : total >= cfg.gradeWarnCut ? '주의' : '안전');
    const color = grade === '위험' ? '#DC2626' : grade === '주의' ? '#F59E0B' : '#16A34A';

    const reasonBits = [];
    if (forcedRule === 'danger_rate_gate') reasonBits.push(`불량률 ${pct(rate)} ≥ 위험 임계치 ${pct(cfg.dangerRatePct)}`);
    else if (forcedRule === 'warn_rate_gate') reasonBits.push(`불량률 ${pct(rate)} ≥ 주의 임계치 ${pct(cfg.warnRatePct)}`);
    if (sampleConfidence < 1) reasonBits.push(`일별표본 ${daily.length}개로 변동성 신뢰도 ${(sampleConfidence*100).toFixed(0)}% 반영`);
    if (reasonBits.length === 0) reasonBits.push(`총점 ${total}점(주의 ${cfg.gradeWarnCut}+ / 위험 ${cfg.gradeDangerCut}+)`);

    return { 품명: r.품명, score: total, grade, color, 불량률: rate,
      생산수량: r.생산수량, 불량수량: r.불량수량, slope,
      rateScore: Math.round(rateScore),
      slopeScore: Math.round(slopeScore),
      prodScore: Math.round(prodScore),
      volScore: Math.round(volScore),
      rawVolScore: Math.round(rawVolScore),
      sampleCount: daily.length,
      sampleConfidence: Math.round(sampleConfidence * 100),
      forcedRule,
      ruleLabel: getRiskRuleLabel(forcedRule),
      reason: reasonBits.join(' / ') };
  }).sort((a,b) => b.score - a.score);
}

/* ================================================================
   AI 품질진단 — 5. 자동 진단 텍스트 (generateDiagnosisText)
   ================================================================ */
function generateDiagnosisText(kpi, trends, anomalies, defectTypes, riskScores, byDate, targetRate) {
  if (targetRate === undefined) targetRate = targetDefectRate;
  const sections = [];
  const dangerItems = riskScores.filter(r => r.grade === '위험');
  const warnItems = riskScores.filter(r => r.grade === '주의');
  const safeItems = riskScores.filter(r => r.grade === '안전');

  // 전체 위험등급
  let overallGrade = '안전';
  if (dangerItems.length >= 3 || trends.direction === '급등' ||
      anomalies.filter(a => a.type === 'ucl').length >= 3) {
    overallGrade = '위험';
  } else if (warnItems.length > 0 || trends.consecutiveWorsen >= 3 || trends.crossType === 'dead') {
    overallGrade = '주의';
  }

  // DPMO, Sigma Level 계산
  const dpmo = kpi.총생산수량 > 0 ? Math.round(kpi.총불량수량 / kpi.총생산수량 * 1000000) : 0;
  const yieldRate = kpi.총생산수량 > 0 ? kpi.총양품수량 / kpi.총생산수량 * 100 : 100;
  // 근사 시그마 수준 (Yield 기반)
  const sigmaTable = [[99.99966,6],[99.9977,5.5],[99.977,5],[99.87,4.5],[99.38,4],[97.73,3.5],[95.45,3],[93.32,2.5],[84.13,2],[69.15,1.5],[50,1]];
  let sigmaLevel = 1;
  for (const [y, s] of sigmaTable) { if (yieldRate >= y) { sigmaLevel = s; break; } }

  // 공정능력 관련
  const rates = byDate ? byDate.map(r => r.불량률 * 100) : [];
  const rateMean = rates.length ? rates.reduce((a,b)=>a+b,0)/rates.length : 0;
  const rateStd = rates.length > 1 ? Math.sqrt(rates.reduce((s,v)=>s+(v-rateMean)*(v-rateMean),0)/(rates.length-1)) : 0;
  const rateMin = rates.length ? Math.min(...rates) : 0;
  const rateMax = rates.length ? Math.max(...rates) : 0;

  // 최근 7일 vs 이전 7일 비교
  const last7 = rates.slice(-7);
  const prev7 = rates.slice(-14, -7);
  const last7Avg = last7.length ? last7.reduce((a,b)=>a+b,0)/last7.length : 0;
  const prev7Avg = prev7.length ? prev7.reduce((a,b)=>a+b,0)/prev7.length : 0;

  // ── 섹션 1: 종합 현황 ──
  const gradeStyle = overallGrade === '위험' ? 'ai-ds-danger' : overallGrade === '주의' ? 'ai-ds-warn' : 'ai-ds-safe';
  let s1 = `<div class="ai-ds-body">`;
  s1 += `전체 불량률 <b>${pct(kpi.불량률)}</b> (목표: ${targetRate.toFixed(1)}%)`;
  if (kpi.불량률 > targetRate * 3) s1 += '로 <span style="color:#DC2626;font-weight:700">목표를 크게 초과</span>하고 있습니다. 즉각적인 개선이 필요합니다.';
  else if (kpi.불량률 > targetRate) s1 += `로 <span style="color:#F59E0B;font-weight:700">목표(${targetRate.toFixed(1)}%) 초과</span> 상태입니다. 개선이 필요합니다.`;
  else s1 += `로 <span style="color:#16A34A;font-weight:700">목표 달성</span> 상태를 유지하고 있습니다.`;
  s1 += `</div>`;
  s1 += `<div class="ai-ds-detail">`;
  s1 += `분석 대상: ${fmt(kpi.품목수)}개 품목 / ${fmt(kpi.생산일수)}일간 / 총 생산 ${fmt(kpi.총생산수량)}개<br>`;
  s1 += `양품 ${fmt(kpi.총양품수량)}개 (수율 ${pct(yieldRate)}) / 불량 ${fmt(kpi.총불량수량)}개<br>`;
  s1 += `백만개당 불량: ${fmt(dpmo)}개 / 품질 수준: ${sigmaLevel.toFixed(1)}σ<br>`;
  s1 += `일별 불량률 범위: ${pct(rateMin)} ~ ${pct(rateMax)} (표준편차 ${pct(rateStd)})`;
  s1 += `</div>`;
  sections.push({ title: '📊 종합 현황', body: s1, style: gradeStyle });

  // ── 섹션 1-B: 목표 불량률 초과 원인 분석 ──
  const isOverTarget = kpi.불량률 > targetRate;
  let sTarget = '';
  if (isOverTarget) {
    const overAmount = kpi.불량률 - targetRate;
    const overDays = byDate ? byDate.filter(r => r.불량률 * 100 > targetRate).length : 0;
    const totalDays = byDate ? byDate.length : 0;
    const last7Over = byDate ? byDate.slice(-7).filter(r => r.불량률 * 100 > targetRate).length : 0;

    sTarget += `<div class="ai-ds-body"><span style="color:#DC2626;font-weight:700">목표 불량률 ${targetRate.toFixed(1)}% 대비 현재 ${pct(kpi.불량률)}로 ${overAmount.toFixed(2)}%p 초과</span>하고 있습니다.</div>`;
    sTarget += `<div class="ai-ds-detail">`;

    // 일별 초과 현황
    sTarget += `<b>📅 일별 초과 현황:</b> 전체 ${totalDays}일 중 <b style="color:#DC2626">${overDays}일</b> 초과 (초과율 ${(overDays/Math.max(totalDays,1)*100).toFixed(0)}%)`;
    sTarget += ` / 최근 7일 중 <b>${last7Over}일</b> 초과<br>`;

    // 품목별 기여도 분석
    if (riskScores.length > 0) {
      const totalDefects = kpi.총불량수량 || 1;
      const totalProd = kpi.총생산수량 || 1;
      const targetDefects = totalProd * targetRate / 100;
      const excessDefects = totalDefects - targetDefects;

      // 불량 기여도가 높은 품목 TOP5
      const topContrib = [...riskScores].sort((a,b) => b.불량수량 - a.불량수량).slice(0, 5);
      sTarget += `<br><b>🏭 목표 초과 주요 원인 품목 (TOP 5):</b><br>`;
      topContrib.forEach((r, i) => {
        const contrib = (r.불량수량 / totalDefects * 100).toFixed(1);
        const itemRate = r.불량률;
        const potential = r.생산수량 > 0 ? ((r.불량수량 - r.생산수량 * targetRate / 100) / totalProd * 100) : 0;
        const potentialText = potential > 0 ? `이 품목을 목표 수준으로 개선하면 전체 불량률 약 ${potential.toFixed(2)}%p 감소` : '';
        sTarget += `&nbsp;&nbsp;${i+1}. <b>${r.품명}</b> — 불량률 ${pct(itemRate)}, 불량 ${fmt(r.불량수량)}개 (전체 불량의 <b>${contrib}%</b>)`;
        if (potentialText) sTarget += `<br>&nbsp;&nbsp;&nbsp;&nbsp;↳ <span style="color:#2563EB">${potentialText}</span>`;
        sTarget += `<br>`;
      });

      // 개선 시뮬레이션
      const top3 = topContrib.slice(0, 3);
      let simDefects = totalDefects;
      top3.forEach(r => {
        if (r.생산수량 > 0) {
          const currentDef = r.불량수량;
          const targetDef = r.생산수량 * targetRate / 100;
          if (currentDef > targetDef) simDefects -= (currentDef - targetDef);
        }
      });
      const simRate = simDefects / totalProd * 100;
      sTarget += `<br><b>📊 개선 시뮬레이션:</b> TOP 3 품목(${top3.map(r=>r.품명).join(', ')})을 목표 수준으로 개선하면<br>`;
      sTarget += `&nbsp;&nbsp;→ 전체 불량률이 <b style="color:${simRate <= targetRate ? '#16A34A' : '#F59E0B'}">${pct(simRate)}</b>로 ${simRate <= targetRate ? '목표 달성 가능' : '개선되나 추가 조치 필요'}<br>`;
    }

    // 불량유형별 기여도
    if (defectTypes.trends && defectTypes.trends.length > 0) {
      const sortedTypes = [...defectTypes.trends].sort((a,b) => b.total - a.total);
      const totalTypeBad = sortedTypes.reduce((s,t) => s + t.total, 0) || 1;
      sTarget += `<br><b>🔍 불량유형별 기여도:</b><br>`;
      sortedTypes.slice(0, 5).forEach(t => {
        const typeContrib = (t.total / totalTypeBad * 100).toFixed(1);
        const trendIcon = t.direction === '증가' ? '🔺' : t.direction === '감소' ? '🔽' : '➡️';
        sTarget += `&nbsp;&nbsp;${trendIcon} ${t.type}: ${fmt(t.total)}건 (${typeContrib}%) — ${t.direction} 추세<br>`;
      });
    }

    sTarget += `</div>`;
    sections.push({ title: '🎯 목표 불량률 초과 원인 분석', body: sTarget, style: 'ai-ds-danger' });
  } else {
    sTarget += `<div class="ai-ds-body"><span style="color:#16A34A;font-weight:700">현재 불량률 ${pct(kpi.불량률)}로 목표(${targetRate.toFixed(1)}%)를 달성하고 있습니다.</span></div>`;
    sTarget += `<div class="ai-ds-detail">목표 대비 여유: ${(targetRate - kpi.불량률).toFixed(2)}%p<br>`;
    const nearItems = riskScores.filter(r => r.불량률 > targetRate);
    if (nearItems.length > 0) {
      sTarget += `단, 개별 품목 중 목표 초과 품목이 <b>${nearItems.length}개</b> 있습니다: ${nearItems.slice(0,3).map(r => r.품명 + '(' + pct(r.불량률) + ')').join(', ')}${nearItems.length>3?' 외 '+(nearItems.length-3)+'건':''}`;
    }
    sTarget += `</div>`;
    sections.push({ title: '🎯 목표 불량률 달성 현황', body: sTarget, style: 'ai-ds-safe' });
  }

  // ── 섹션 2: 품목 위험도 분석 ──
  let s2 = `<div class="ai-ds-body">`;
  s2 += `전체 ${riskScores.length}개 품목 중 `;
  s2 += `<span style="color:#DC2626;font-weight:700">위험 ${dangerItems.length}건</span>, `;
  s2 += `<span style="color:#F59E0B;font-weight:700">주의 ${warnItems.length}건</span>, `;
  s2 += `<span style="color:#16A34A;font-weight:700">안전 ${safeItems.length}건</span>입니다.`;
  s2 += `</div>`;
  s2 += `<div class="ai-ds-detail">`;
  if (dangerItems.length > 0) {
    s2 += `<b style="color:#DC2626">▶ 위험 품목:</b><br>`;
    dangerItems.slice(0, 5).forEach((r, i) => {
      s2 += `&nbsp;&nbsp;${i+1}. <b>${r.품명}</b> — 불량률 ${pct(r.불량률)}, 불량 ${fmt(r.불량수량)}개/생산 ${fmt(r.생산수량)}개, 위험점수 ${r.score}점`;
      s2 += ` (불량률${r.rateScore}+추세${r.slopeScore}+규모${r.prodScore}+변동${r.volScore})`;
      s2 += ` [규칙:${r.ruleLabel}, 신뢰도:${r.sampleConfidence}%]<br>`;
      s2 += `&nbsp;&nbsp;&nbsp;&nbsp;↳ ${r.reason}<br>`;
    });
  }
  if (warnItems.length > 0) {
    s2 += `<b style="color:#F59E0B">▶ 주의 품목:</b> `;
    s2 += warnItems.slice(0,5).map(r => `${r.품명}(${pct(r.불량률)}, ${r.score}점)`).join(', ');
    if (warnItems.length > 5) s2 += ` 외 ${warnItems.length-5}건`;
    s2 += `<br>`;
  }
  if (dangerItems.length === 0 && warnItems.length === 0) {
    s2 += '모든 품목이 안전 등급입니다. 현재 상태를 유지하세요.<br>';
  }
  s2 += `</div>`;
  const s2style = dangerItems.length >= 3 ? 'ai-ds-danger' : dangerItems.length > 0 ? 'ai-ds-warn' : warnItems.length > 0 ? 'ai-ds-warn' : 'ai-ds-safe';
  sections.push({ title: '🎯 품목 위험도 분석', body: s2, style: s2style });

  // ── 섹션 3: 추세 및 변동 분석 ──
  const directionMap = { '급등':'🔺 급등 추세 — 긴급 대응이 필요합니다', '상승':'🔼 상승 추세 — 주의가 필요합니다',
    '안정':'➡️ 안정 추세 — 현재 수준을 유지하고 있습니다', '개선':'🔽 개선 추세 — 불량률이 감소하고 있습니다', '급감':'⏬ 급감 추세 — 빠르게 개선되고 있습니다' };
  let s3 = `<div class="ai-ds-body">${directionMap[trends.direction]}</div>`;
  s3 += `<div class="ai-ds-detail">`;
  if (trends.weekChange !== 0) {
    s3 += `전주 대비: ${trends.weekChange > 0 ? '<span style="color:#DC2626">▲ '+pct(Math.abs(trends.weekChange))+' 악화</span>' : '<span style="color:#16A34A">▼ '+pct(Math.abs(trends.weekChange))+' 개선</span>'}<br>`;
  }
  if (trends.monthChange !== 0) {
    s3 += `전월 대비: ${trends.monthChange > 0 ? '<span style="color:#DC2626">▲ '+pct(Math.abs(trends.monthChange))+' 악화</span>' : '<span style="color:#16A34A">▼ '+pct(Math.abs(trends.monthChange))+' 개선</span>'}<br>`;
  }
  if (last7.length && prev7.length) {
    s3 += `최근 7일 평균: ${pct(last7Avg)} (이전 7일: ${pct(prev7Avg)})<br>`;
  }
  if (trends.crossType === 'dead') s3 += '<span style="color:#DC2626;font-weight:700">⚠ 불량률 악화 신호 감지</span> — 단기 평균이 장기 평균을 넘어섬, 악화 가속 가능<br>';
  if (trends.crossType === 'golden') s3 += '<span style="color:#16A34A;font-weight:700">✓ 불량률 개선 신호 감지</span> — 단기 평균이 장기 평균 아래로 내려감, 개선 진행 중<br>';
  if (trends.consecutiveWorsen >= 3) s3 += `<span style="color:#DC2626">⚠ ${trends.consecutiveWorsen}일 연속 악화 중</span><br>`;
  if (trends.consecutiveImprove >= 3) s3 += `<span style="color:#16A34A">✓ ${trends.consecutiveImprove}일 연속 개선 중</span><br>`;
  s3 += `</div>`;
  const s3style = trends.direction === '급등' || trends.direction === '상승' ? 'ai-ds-warn' : trends.direction === '안정' ? 'ai-ds-info' : 'ai-ds-safe';
  sections.push({ title: '📈 추세 및 변동 분석', body: s3, style: s3style });

  // ── 섹션 4: 이상 징후 분석 ──
  const uclCount = anomalies.filter(a => a.type === 'ucl').length;
  const zCount = anomalies.filter(a => a.type === 'zscore').length;
  const spikeCount = anomalies.filter(a => a.type === 'spike').length;
  const ruleCount = anomalies.filter(a => a.type === 'trend7' || a.type === 'bias8').length;
  let s4 = `<div class="ai-ds-body">총 <b>${anomalies.length}건</b>의 이상 징후가 감지되었습니다.</div>`;
  s4 += `<div class="ai-ds-detail">`;
  if (uclCount > 0) s4 += `관리 허용범위 초과: <b style="color:#DC2626">${uclCount}건</b> — 공정이 정상 범위를 벗어남<br>`;
  if (zCount > 0) s4 += `극단값 발생: <b style="color:#DC2626">${zCount}건</b> — 평균과 크게 다른 이상 값 감지<br>`;
  if (spikeCount > 0) s4 += `일간 급등 (2σ 초과 변동): <b style="color:#F59E0B">${spikeCount}건</b> — 전일 대비 급격한 상승<br>`;
  if (ruleCount > 0) s4 += `SPC 규칙 위반: <b style="color:#F59E0B">${ruleCount}건</b> — 연속 추세/편측 패턴 감지<br>`;
  if (anomalies.length === 0) s4 += '현재 이상 징후가 감지되지 않았습니다. 공정이 안정적입니다.<br>';
  s4 += `</div>`;
  const s4style = uclCount >= 3 || zCount >= 3 ? 'ai-ds-danger' : anomalies.length > 0 ? 'ai-ds-warn' : 'ai-ds-safe';
  sections.push({ title: '⚠️ 이상 징후 분석', body: s4, style: s4style });

  // ── 섹션 5: 불량유형 상세 분석 ──
  if (defectCols.length > 0) {
    let s5 = `<div class="ai-ds-body">`;
    if (defectTypes.dominant) {
      s5 += `불량이 <b>${defectTypes.dominant}</b>에 집중되어 있습니다 (집중도 ${(defectTypes.hhi*100).toFixed(0)}%).`;
    } else {
      s5 += `불량이 여러 유형에 분산되어 있습니다 (집중도 ${(defectTypes.hhi*100).toFixed(0)}%).`;
    }
    s5 += `</div><div class="ai-ds-detail">`;
    if (defectTypes.trends.length > 0) {
      const increasing = defectTypes.trends.filter(t => t.direction === '증가' && t.total > 0);
      const decreasing = defectTypes.trends.filter(t => t.direction === '감소' && t.total > 0);
      if (increasing.length > 0) {
        s5 += `<span style="color:#DC2626">▲ 증가 추세:</span> ${increasing.map(t => `${t.type}(기울기 ${t.slope.toFixed(2)}, 총 ${fmt(t.total)}건)`).join(', ')}<br>`;
      }
      if (decreasing.length > 0) {
        s5 += `<span style="color:#16A34A">▼ 감소 추세:</span> ${decreasing.map(t => `${t.type}(기울기 ${t.slope.toFixed(2)}, 총 ${fmt(t.total)}건)`).join(', ')}<br>`;
      }
      const stable = defectTypes.trends.filter(t => t.direction === '안정' && t.total > 0);
      if (stable.length > 0) {
        s5 += `➡️ 안정: ${stable.map(t => `${t.type}(${fmt(t.total)}건)`).join(', ')}<br>`;
      }
    }
    if (defectTypes.newTypes.length > 0) {
      s5 += `<span style="color:#DC2626;font-weight:700">⚠ 신규 불량유형 발생:</span> ${defectTypes.newTypes.join(', ')} — 후반기에 새로 나타남<br>`;
    }
    if (defectTypes.disappearedTypes.length > 0) {
      s5 += `<span style="color:#16A34A">✓ 소멸 불량유형:</span> ${defectTypes.disappearedTypes.join(', ')} — 후반기에 사라짐<br>`;
    }
    s5 += `</div>`;
    sections.push({ title: '🔬 불량유형 상세 분석', body: s5, style: defectTypes.dominant ? 'ai-ds-warn' : 'ai-ds-info' });
  }

  // ── 섹션 6: 공정 안정성 ──
  const totalBad = byDate ? byDate.reduce((s,r)=>s+r.불량수량,0) : 0;
  const totalProd = byDate ? byDate.reduce((s,r)=>s+r.생산수량,0) : 1;
  const pBar = totalProd ? totalBad/totalProd : 0;
  let s6 = `<div class="ai-ds-body">`;
  if (uclCount === 0 && ruleCount === 0) s6 += `공정이 <b style="color:#16A34A">통계적으로 안정</b> 상태입니다.`;
  else s6 += `공정이 <b style="color:#DC2626">불안정</b> 상태입니다. 특별 원인 조사가 필요합니다.`;
  s6 += `</div><div class="ai-ds-detail">`;
  s6 += `전체 평균 불량률: ${pct(pBar*100)}<br>`;
  s6 += `관리한계 이탈: ${uclCount}건 / SPC 규칙 위반: ${ruleCount}건<br>`;
  s6 += `공정 변동: ${rateMean > 0 && rateStd/rateMean < 0.3 ? '안정적 (일별 편차가 작음)' : '변동이 큼 (일별 편차 주의)'}<br>`;
  s6 += `</div>`;
  sections.push({ title: '🏭 공정 안정성', body: s6, style: uclCount === 0 && ruleCount === 0 ? 'ai-ds-safe' : 'ai-ds-danger' });

  // ── 섹션 7: 권장 조치 ──
  const actions = [];
  if (dangerItems.length > 0) actions.push({ priority: '긴급', text: `위험 품목(${dangerItems.slice(0,3).map(r=>r.품명).join(', ')}) 공정 긴급 점검 및 원인 분석`, detail: '불량률과 위험점수가 높은 품목의 생산 라인을 즉시 점검하세요.' });
  if (trends.direction === '급등') actions.push({ priority: '긴급', text: '불량률 급등 원인 긴급 파악', detail: '설비 이상, 원자재 변경, 작업 조건 변화 등을 즉시 확인하세요.' });
  if (trends.direction === '상승') actions.push({ priority: '높음', text: '불량률 상승 원인 분석 및 대책 수립', detail: '추세가 계속되기 전에 조기 대응이 필요합니다.' });
  if (uclCount > 0) actions.push({ priority: '높음', text: `관리범위 초과(${uclCount}건) 원인 조사`, detail: '이탈 발생일의 작업 일지, 설비 상태, 원자재 로트를 확인하세요.' });
  if (anomalies.filter(a=>a.type==='spike').length > 0) actions.push({ priority: '높음', text: '일간 급등 발생일 원인 조사', detail: '급등 당일의 특이사항(설비 교체, 작업자 변경 등)을 확인하세요.' });
  if (defectTypes.dominant) actions.push({ priority: '중간', text: `집중 불량유형(${defectTypes.dominant}) 개선 활동 추진`, detail: '파레토 원칙에 따라 주요 불량유형 개선이 가장 효과적입니다.' });
  if (defectTypes.newTypes.length > 0) actions.push({ priority: '중간', text: `신규 불량유형(${defectTypes.newTypes.join(', ')}) 원인 파악`, detail: '최근 새로 발생한 불량유형의 발생 원인과 패턴을 분석하세요.' });
  if (trends.consecutiveWorsen >= 3) actions.push({ priority: '중간', text: `${trends.consecutiveWorsen}일 연속 악화 추세 대응`, detail: '체계적인 원인 분석(4M 분석 등)을 통해 근본 원인을 파악하세요.' });
  if (warnItems.length > 3) actions.push({ priority: '보통', text: `주의 품목 ${warnItems.length}건 모니터링 강화`, detail: '위험 등급으로 상승하지 않도록 일별 모니터링을 실시하세요.' });
  if (actions.length === 0) actions.push({ priority: '보통', text: '현재 상태 유지 및 지속적 모니터링', detail: '안정적인 상태이나 정기적 확인을 계속하세요.' });

  let s7 = `<div class="ai-ds-detail">`;
  actions.forEach((a, i) => {
    const pColor = a.priority === '긴급' ? '#DC2626' : a.priority === '높음' ? '#F59E0B' : a.priority === '중간' ? '#2563EB' : '#6B7280';
    s7 += `<div style="margin-bottom:8px"><span style="display:inline-block;padding:1px 8px;border-radius:4px;font-size:11px;font-weight:700;background:${pColor}20;color:${pColor}">${a.priority}</span> `;
    s7 += `<b>${i+1}. ${a.text}</b><br>`;
    s7 += `<span style="margin-left:16px;color:var(--text-light)">${a.detail}</span></div>`;
  });
  s7 += `</div>`;
  sections.push({ title: '✅ 권장 조치', body: s7, style: 'ai-ds-info' });

  return { overallGrade, sections, stats: { dpmo, sigmaLevel, yieldRate, rateStd, rateMean, rateMin, rateMax, last7Avg, prev7Avg } };
}

/* ================================================================
   AI 품질진단 — 시각화: 스파크라인
   ================================================================ */
function renderSparkline(container, values, color) {
  if (!container || !values || values.length < 2) return;
  const w = container.clientWidth || 100, h = container.clientHeight || 32;
  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');
  const min = Math.min(...values), max = Math.max(...values);
  const range = max - min || 1;
  const step = w / (values.length - 1);
  ctx.strokeStyle = color || '#2563EB';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  values.forEach((v, i) => {
    const x = i * step;
    const y = h - 3 - (v - min) / range * (h - 6);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  });
  ctx.stroke();
}

/* ================================================================
   AI 품질진단 — 시각화: 위험도 매트릭스 산점도
   ================================================================ */
function chartRiskMatrix(riskScores, el) {
  if (!riskScores.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const mb = isMobile();
  const maxLen = mb ? 10 : 20;
  Plotly.newPlot(el, [{
    x: riskScores.map(r => r.생산수량),
    y: riskScores.map(r => r.불량률),
    mode: 'markers+text',
    type: 'scatter',
    marker: {
      size: riskScores.map(r => Math.max(r.score / 100 * (mb ? 30 : 50), mb ? 6 : 8)),
      color: riskScores.map(r => r.color),
      opacity: 0.85,
      line: { width: 1.5, color: 'rgba(255,255,255,0.8)' }
    },
    text: riskScores.map(r => r.score >= 40 ? r.품명.slice(0, maxLen) : ''),
    textposition: 'top center',
    textfont: { size: mb ? 7 : 9, color: '#374151' },
    hovertemplate: '<b>%{customdata[0]}</b><br>생산: %{x:,}개<br>불량률: %{y:.2f}%<br>위험점수: %{customdata[1]}점<br>등급: %{customdata[2]}<br>점수분해: 불량률%{customdata[3]} + 추세%{customdata[4]} + 규모%{customdata[5]} + 변동%{customdata[6]}<br>규칙: %{customdata[7]} / 신뢰도: %{customdata[8]}%<br>%{customdata[9]}<extra></extra>',
    customdata: riskScores.map(r => [r.품명, r.score, r.grade, r.rateScore, r.slopeScore, r.prodScore, r.volScore, r.ruleLabel, r.sampleConfidence, r.reason])
  }], {
    xaxis: { title: mb ? '' : '생산수량', type: 'log', gridcolor: '#E5E7EB' },
    yaxis: { title: mb ? '' : '불량률 (%)', gridcolor: '#E5E7EB' },
    height: chartHeight(450, 340),
    margin: mb ? {t:20,b:40,l:40,r:20} : {t:40,b:50,l:60,r:40},
    shapes: [
      { type:'line', x0:0, x1:1, xref:'paper', y0:3, y1:3,
        line:{color:'#F59E0B',width:1.5,dash:'dot'} },
      { type:'line', x0:0, x1:1, xref:'paper', y0:5, y1:5,
        line:{color:'#DC2626',width:1.5,dash:'dot'} }
    ],
    annotations: [
      { x:0.98, y:1, xref:'paper', yref:'paper', text:'크기 = 위험점수', showarrow:false,
        font:{size:mb?9:11,color:'var(--text-light)'}, xanchor:'right', yanchor:'top' }
    ]
  }, getPlotCfg());
}

/* ================================================================
   AI 품질진단 — 시각화: 불량유형별 추세 차트
   ================================================================ */
function chartDefectTrends(byDate, defectTypeAnalysis, el) {
  if (!defectCols.length || !byDate || byDate.length < 2) {
    el.innerHTML='<p style="color:var(--text-light);padding:20px">불량유형 데이터가 부족합니다.</p>'; return;
  }
  const mb = isMobile();
  const dates = byDate.map(r => dateKR(r.생산일자));
  const active = defectCols.filter(dc => byDate.some(r => (r[dc]||0) > 0));
  const traces = active.map((dc, i) => ({
    x: dates, y: byDate.map(r => r[dc] || 0), type:'scatter', mode:'lines+markers',
    name: dc, line: { color: PALETTE[i % PALETTE.length], width: 2 },
    marker: { size: mb ? 3 : 5 }
  }));

  // 기울기 방향 주석
  const annotations = [];
  if (defectTypeAnalysis && defectTypeAnalysis.trends) {
    defectTypeAnalysis.trends.filter(t => t.total > 0).slice(0, 5).forEach((t, i) => {
      const arrow = t.direction === '증가' ? '↑' : t.direction === '감소' ? '↓' : '→';
      const color = t.direction === '증가' ? '#DC2626' : t.direction === '감소' ? '#16A34A' : '#6B7280';
      annotations.push({
        x: 1.02, y: 1 - i * 0.12, xref:'paper', yref:'paper', showarrow: false,
        text: `${arrow} ${t.type}`, font: { size: mb ? 9 : 11, color },
        xanchor: 'left', yanchor: 'top'
      });
    });
  }

  Plotly.newPlot(el, traces, {
    title: mb ? '' : '불량유형별 추세',
    yaxis: { title: mb ? '' : '불량 건수' },
    legend: { orientation:'h', y: mb ? 1.2 : 1.14, font: {size: mb ? 9 : 11} },
    height: chartHeight(420, 300),
    margin: mb ? {t:30,b:40,l:35,r:60} : {t:50,b:50,l:60,r:120},
    annotations
  }, getPlotCfg());
}

/* ================================================================
   AI 품질진단 — 메인 렌더링 함수
   ================================================================ */
function renderAIDiagnosis(kpi, byDate, byItem, filtered) {
  const el = $('tab9');
  if (!el) return;

  if (!byDate || !byDate.length || !byItem || !byItem.length) {
    el.innerHTML = '<div class="ai-diagnosis-box"><h3>AI 품질진단</h3><p style="color:var(--text-light)">분석할 데이터가 없습니다. 엑셀 파일을 업로드하고 분석을 시작하세요.</p></div>';
    return;
  }
  aiRenderContext = { kpi, byDate, byItem, filtered };

  // 5개 분석 엔진 실행
  const trends = analyzeTrends(byDate, filtered);
  const anomalies = detectAnomalies(byDate);
  const defectTypes = analyzeDefectTypes(byDate);
  const riskScores = calcItemRiskScores(byItem, filtered, aiRiskSettings);
  const diagnosis = generateDiagnosisText(kpi, trends, anomalies, defectTypes, riskScores, byDate, targetDefectRate);

  const dangerItems = riskScores.filter(r => r.grade === '위험');
  const warnItems = riskScores.filter(r => r.grade === '주의');
  const safeItems = riskScores.filter(r => r.grade === '안전');
  const dangerAnomalies = anomalies.filter(a => a.severity === 'danger');
  const st = diagnosis.stats;
  const mb = isMobile();

  // 종합 품질 점수
  const qs = calcQualityScore(kpi, trends, anomalies, riskScores, st, targetDefectRate);

  let html = '';

  // ════════════════════════════════════════════
  // ZONE 1: 초보자 영역 (항상 표시)
  // ════════════════════════════════════════════

  // [1] 종합 품질 점수 게이지
  const heroEmoji = qs.score >= 75 ? '🎉' : qs.score >= 60 ? '👀' : qs.score >= 45 ? '⚠️' : '🚨';
  html += `<div class="ai-gauge-section">
    <div class="ai-gauge-wrap">${drawQualityGaugeHTML(qs.score, qs.letterGrade, qs.color)}</div>
    <div class="ai-gauge-verdict">
      <div class="ai-gauge-grade" style="color:${qs.color}">${heroEmoji} 품질 등급 ${qs.letterGrade}</div>
      <div class="ai-gauge-text">${qs.verdict}</div>
      <div class="ai-gauge-sub">분석 기간: ${fmt(kpi.생산일수)}일 / ${fmt(kpi.품목수)}개 품목 / 총 생산 ${fmt(kpi.총생산수량)}개</div>
    </div>
  </div>`;

  // [2] 한눈에 보는 요약
  const per100 = kpi.불량률.toFixed(1);
  const rateColor = kpi.불량률 >= 5 ? '#DC2626' : kpi.불량률 >= 3 ? '#F59E0B' : kpi.불량률 >= 1 ? '#2563EB' : '#16A34A';
  const weekArrow = trends.weekChange > 0 ? '▲' : trends.weekChange < 0 ? '▼' : '─';
  const weekColor = trends.weekChange > 0 ? '#DC2626' : trends.weekChange < 0 ? '#16A34A' : '#6B7280';
  const weekLabel = trends.weekChange > 0 ? '악화' : trends.weekChange < 0 ? '개선' : '변동없음';
  const trendArrow = { '급등':'▲▲', '상승':'▲', '안정':'─', '개선':'▼', '급감':'▼▼' };
  const trendColor = (trends.direction==='급등'||trends.direction==='상승') ? '#DC2626' : (trends.direction==='개선'||trends.direction==='급감') ? '#16A34A' : '#6B7280';
  const trendDesc = trends.consecutiveWorsen >= 3 ? `${trends.consecutiveWorsen}일 연속 악화 중`
    : trends.consecutiveImprove >= 3 ? `${trends.consecutiveImprove}일 연속 개선 중` : '안정적 흐름';

  html += `<div class="ai-summary-box">
    <div class="ai-summary-hero">
      <span class="ai-summary-icon">📦</span>
      <div class="ai-summary-main">제품 <b>100개</b>를 만들면 <b style="color:${rateColor};font-size:24px">${per100}개</b>가 불량입니다</div>
    </div>
    <div class="ai-summary-stats">
      <div class="ai-ss-item">
        <span class="ai-ss-label">전주 대비</span>
        <span class="ai-ss-val" style="color:${weekColor}">${weekArrow} ${pct(Math.abs(trends.weekChange))}</span>
        <span class="ai-ss-sub">${weekLabel}</span>
      </div>
      <div class="ai-ss-item">
        <span class="ai-ss-label">최근 추이</span>
        <span class="ai-ss-val" style="color:${trendColor}">${trendArrow[trends.direction]||'─'} ${trends.direction}</span>
        <span class="ai-ss-sub">${trendDesc}</span>
      </div>
      <div class="ai-ss-item">
        <span class="ai-ss-label">양품률</span>
        <span class="ai-ss-val" style="color:var(--success)">${pct(st.yieldRate)}</span>
        <span class="ai-ss-sub">양품 ${fmt(kpi.총양품수량)}개</span>
      </div>
      <div class="ai-ss-item">
        <span class="ai-ss-label">시그마 수준</span>
        <span class="ai-ss-val" style="color:var(--primary)">${st.sigmaLevel.toFixed(1)}σ</span>
        <span class="ai-ss-sub">${st.sigmaLevel >= 4 ? '우수' : st.sigmaLevel >= 3 ? '양호' : st.sigmaLevel >= 2 ? '보통' : '개선필요'}</span>
      </div>
    </div>
  </div>`;

  // [3] 품질 건강 체크리스트
  const uclCount = anomalies.filter(a => a.type === 'ucl').length;
  const checks = [
    { label: `불량률이 목표(${targetDefectRate.toFixed(1)}%) 이내인가?`,
      pass: kpi.불량률 < targetDefectRate,
      detail: kpi.불량률 < targetDefectRate * 0.5 ? '매우 양호합니다' : kpi.불량률 < targetDefectRate ? '목표 범위 내이나 개선 여지 있음' : `현재 ${pct(kpi.불량률)}로 목표(${targetDefectRate.toFixed(1)}%)를 ${(kpi.불량률 - targetDefectRate).toFixed(2)}%p 초과했습니다`,
      badge: `현재 ${pct(kpi.불량률)}` },
    { label: '불량률이 개선되고 있는가?',
      pass: trends.direction === '개선' || trends.direction === '급감' || trends.direction === '안정',
      detail: trends.consecutiveWorsen >= 3 ? `${trends.consecutiveWorsen}일 연속으로 악화되고 있습니다`
        : trends.consecutiveImprove >= 3 ? `${trends.consecutiveImprove}일 연속으로 개선되고 있습니다` : `추세: ${trends.direction}`,
      badge: `${trends.direction}` },
    { label: '심각한 이상 징후가 없는가?',
      pass: dangerAnomalies.length === 0,
      detail: dangerAnomalies.length === 0 ? '공정이 정상 범위 내에서 운영 중입니다' : `위험 수준 이상 징후 ${dangerAnomalies.length}건 감지`,
      badge: `이상 ${anomalies.length}건` },
    { label: '위험 품목이 없는가?',
      pass: dangerItems.length === 0,
      detail: dangerItems.length > 0 ? `위험: ${dangerItems.slice(0,2).map(r=>r.품명).join(', ')}${dangerItems.length>2?' 외 '+(dangerItems.length-2)+'건':''}`
        : warnItems.length > 0 ? `주의 품목 ${warnItems.length}건 모니터링 필요` : '모든 품목이 안전합니다',
      badge: `위험 ${dangerItems.length} / 주의 ${warnItems.length}` },
    { label: '공정이 안정적인가?',
      pass: uclCount === 0 && anomalies.filter(a=>a.type==='trend7'||a.type==='bias8').length === 0,
      detail: uclCount > 0 ? `관리 허용범위를 벗어난 날이 ${uclCount}일 있습니다` : '공정 변동이 허용 범위 내에 있습니다',
      badge: `이탈 ${uclCount}건` }
  ];
  const passCount = checks.filter(c => c.pass).length;
  html += `<div class="ai-checklist-box"><h3>🩺 품질 건강 체크 (${passCount}/${checks.length} 통과)</h3>`;
  html += '<div class="ai-checklist">';
  checks.forEach(c => {
    html += `<div class="ai-check-item ${c.pass?'pass':'fail'}">
      <span class="ai-check-icon">${c.pass?'✅':'❌'}</span>
      <div class="ai-check-content">
        <div class="ai-check-label">${c.label}</div>
        <div class="ai-check-detail">${c.detail}</div>
      </div>
      <div class="ai-check-badge">${c.badge}</div>
    </div>`;
  });
  html += '</div></div>';

  // [4] 목표 불량률 초과 원인 분석 (Zone 1에 요약 표시)
  const targetSection = diagnosis.sections.find(s => s.title.includes('목표 불량률'));
  if (targetSection) {
    html += `<div class="ai-diagnosis-box"><h3>${targetSection.title}</h3>
      <div class="ai-diagnosis-section ${targetSection.style}">${targetSection.body}</div>
    </div>`;
  }

  // [5] 권장 조치 (기존 진단에서 추출)
  const actionsSection = diagnosis.sections.find(s => s.title.includes('권장 조치'));
  if (actionsSection) {
    html += `<div class="ai-diagnosis-box"><h3>💡 지금 무엇을 해야 할까요?</h3>
      <div class="ai-diagnosis-section ${actionsSection.style}">${actionsSection.body}</div>
    </div>`;
  }

  // ════════════════════════════════════════════
  // ZONE 2: 전문가 영역 (접힌 상태)
  // ════════════════════════════════════════════

  html += `<div class="ai-expand-toggle" onclick="toggleAIDetail()">
    <span id="aiDetailToggleText">📊 상세 분석 보기 ▼</span>
    <span class="ai-expand-hint">전문가용 상세 데이터</span>
  </div>`;
  html += '<div class="ai-detail-section" id="aiDetailSection" style="display:none">';

  // 간소화된 3개 통계 카드
  // 자동차 부품 기준 시그마 등급 (엄격 적용)
  // S: ≥5σ, A: ≥4.5σ(≤0.13%), B: ≥4σ(≤0.62%), C: ≥3.5σ(≤2.27%), D: ≥3σ, F: <3σ
  const sigmaGrade = st.sigmaLevel >= 5 ? 'S' : st.sigmaLevel >= 4.5 ? 'A' : st.sigmaLevel >= 4 ? 'B' : st.sigmaLevel >= 3.5 ? 'C' : st.sigmaLevel >= 3 ? 'D' : 'F';
  const sigmaDesc = { S:'세계 최고 수준', A:'우수한 품질', B:'양호한 품질', C:'개선 필요', D:'집중 관리 필요', F:'긴급 개선 필요' };
  const sigmaColor = { S:'#16A34A', A:'#22C55E', B:'#2563EB', C:'#F59E0B', D:'#DC2626', F:'#991B1B' };
  const weekTrend = st.last7Avg < st.prev7Avg ? '개선중' : st.last7Avg > st.prev7Avg ? '악화중' : '유지';
  const weekTrendColor = st.last7Avg < st.prev7Avg ? 'var(--success)' : st.last7Avg > st.prev7Avg ? 'var(--danger)' : 'var(--gray)';
  const avgDailyBad = byDate.length ? Math.round(byDate.reduce((s,r)=>s+r.불량수량,0)/byDate.length) : 0;
  html += '<div class="ai-simple-stat-grid">';
  html += `<div class="ai-simple-stat-card"><div class="ai-ssc-icon">🏅</div><div class="ai-ssc-val" style="color:${sigmaColor[sigmaGrade]}">${sigmaGrade}등급</div><div class="ai-ssc-lbl">품질 등급</div><div class="ai-ssc-tip">${sigmaDesc[sigmaGrade]} (${st.sigmaLevel.toFixed(1)}σ)</div></div>`;
  html += `<div class="ai-simple-stat-card"><div class="ai-ssc-icon">📅</div><div class="ai-ssc-val" style="color:${weekTrendColor}">${weekTrend}</div><div class="ai-ssc-lbl">최근 7일 추이</div><div class="ai-ssc-tip">이번주 ${pct(st.last7Avg)} / 지난주 ${pct(st.prev7Avg)}</div></div>`;
  html += `<div class="ai-simple-stat-card"><div class="ai-ssc-icon">📈</div><div class="ai-ssc-val" style="color:var(--gray)">${fmt(avgDailyBad)}개</div><div class="ai-ssc-lbl">일평균 불량</div><div class="ai-ssc-tip">총 ${fmt(kpi.총불량수량)}건 / ${kpi.생산일수}일</div></div>`;
  html += '</div>';

  // AI 자동 진단 리포트
  html += '<div class="ai-diagnosis-box"><h3>📋 AI 자동 진단 리포트</h3>';
  for (const sec of diagnosis.sections) {
    if (sec.title.includes('권장 조치')) continue;
    html += `<div class="ai-diagnosis-section ${sec.style}"><div class="ai-ds-title">${sec.title}</div>${sec.body}</div>`;
  }
  html += '</div>';

  // 품목 위험도 순위 (간소화)
  html += '<div class="ai-item-detail"><h3>🏆 품목 위험도 순위 (상위 15)</h3>';
  const maxScore = riskScores.length ? riskScores[0].score : 100;
  riskScores.slice(0, 15).forEach((r, i) => {
    const bgColor = r.grade === '위험' ? '#DC2626' : r.grade === '주의' ? '#F59E0B' : '#16A34A';
    const barW = Math.max(r.score / maxScore * 120, 4);
    const nameLen = mb ? 20 : 40;
    const dispName = r.품명.length > nameLen ? r.품명.slice(0, nameLen) + '...' : r.품명;
    const factors = [
      { name: '불량률', val: r.rateScore, color: '#DC2626' },
      { name: '추세', val: r.slopeScore, color: '#F59E0B' },
      { name: '규모', val: r.prodScore, color: '#2563EB' },
      { name: '변동', val: r.volScore, color: '#8B5CF6' }
    ];
    const dominant = factors.reduce((a, b) => a.val >= b.val ? a : b);
    html += `<div class="ai-item-row">
      <div class="ai-item-rank" style="background:${bgColor}">${i+1}</div>
      <div class="ai-item-name-wrap">
        <div class="ai-item-name" title="${r.품명}">${dispName}</div>
        <div class="ai-item-meta">불량률 ${pct(r.불량률)} | 주요 원인: <span style="color:${dominant.color};font-weight:700">${dominant.name}</span></div>
      </div>
      <div class="ai-item-bars">
        <div class="ai-item-bar" style="width:${barW}px;background:${bgColor}"></div>
      </div>
      <div class="ai-item-score" style="color:${bgColor}">${r.score}점</div>
    </div>`;
  });
  html += '</div>';

  // 불량유형 분포 카드
  if (defectCols.length && defectTypes.trends.length) {
    html += '<div class="chart-box"><h3>🔬 불량유형 분포 및 추세</h3>';
    html += '<div class="ai-defect-summary">';
    const totalDefects = defectTypes.trends.reduce((s,t) => s+t.total, 0) || 1;
    defectTypes.trends.filter(t => t.total > 0).forEach(t => {
      const pctVal = (t.total / totalDefects * 100).toFixed(1);
      const trendColorD = t.direction === '증가' ? '#DC2626' : t.direction === '감소' ? '#16A34A' : '#6B7280';
      const trendIcon = t.direction === '증가' ? '▲' : t.direction === '감소' ? '▼' : '→';
      html += `<div class="ai-defect-card">
        <div class="ai-dc-name">${t.type} <span style="color:${trendColorD};font-size:12px">${trendIcon} ${t.direction}</span></div>
        <div class="ai-dc-val">${fmt(t.total)}건 (${pctVal}%)</div>
        <div class="ai-dc-bar"><div class="ai-dc-fill" style="width:${pctVal}%;background:${trendColorD}"></div></div>
      </div>`;
    });
    html += '</div></div>';
  }

  // 경고 카드 목록
  const warnings = [];
  dangerItems.forEach(r => {
    const slopeText = r.slope > 0.05 ? '상승중' : r.slope < -0.05 ? '개선중' : '안정';
    warnings.push({ severity: 'danger', title: r.품명,
      desc: `불량률 ${pct(r.불량률)} | 불량 ${fmt(r.불량수량)}/${fmt(r.생산수량)}개 | 추세: ${slopeText}`,
      scoreText: `위험 점수 ${r.score}점`, item: r.품명, score: r.score });
  });
  dangerAnomalies.slice(0, 5).forEach(a => {
    warnings.push({ severity: 'danger', title: a.desc,
      desc: `${typeof a.date === 'string' ? a.date : dateStr(a.date)}`,
      scoreText: '', score: 100 });
  });
  warnItems.slice(0, 8).forEach(r => {
    warnings.push({ severity: 'warn', title: r.품명,
      desc: `불량률 ${pct(r.불량률)} | 불량 ${fmt(r.불량수량)}개`,
      scoreText: `점수 ${r.score}점`, item: r.품명, score: r.score });
  });
  if (trends.consecutiveWorsen >= 3) {
    warnings.push({ severity: 'warn', title: `${trends.consecutiveWorsen}일 연속 악화`,
      desc: `불량률이 ${trends.consecutiveWorsen}일 연속으로 상승 중`, scoreText: '', score: 60 });
  }
  if (trends.crossType === 'dead') {
    warnings.push({ severity: 'warn', title: '불량률 악화 신호 감지',
      desc: '단기 평균이 장기 평균을 넘어섬 — 악화 가속 가능성', scoreText: '', score: 55 });
  }
  warnings.sort((a,b) => { if (a.severity !== b.severity) return a.severity === 'danger' ? -1 : 1; return b.score - a.score; });

  if (warnings.length) {
    html += '<div class="chart-box"><h3>⚠️ 경고 목록</h3>';
    warnings.forEach((w, i) => {
      html += `<div class="ai-warning-card ${w.severity}">
        <div class="ai-wc-info">
          <div class="ai-wc-title">${w.severity==='danger'?'🔴':'🟡'} ${w.title}</div>
          <div class="ai-wc-desc">${w.desc}</div>
          ${w.scoreText ? '<div class="ai-wc-score" style="color:var(--text-light)">'+w.scoreText+'</div>' : ''}
        </div>
        <div class="ai-wc-spark" id="aiSpark${i}"></div>
      </div>`;
    });
    html += '</div>';
  }

  // 차트 영역
  html += '<div class="chart-box"><h3>📊 품목 위험도 매트릭스</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:4px">X=생산수량, Y=불량률, 크기=위험점수, 색=등급</p><div id="chartRiskMatrix"></div></div>';
  if (defectCols.length) {
    html += '<div class="chart-box"><h3>📈 불량유형별 추세</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:4px">각 불량유형의 일별 추이</p><div id="chartDefectTrends"></div></div>';
  }

  // 이상 이벤트 타임라인 (용어 간소화)
  if (anomalies.length) {
    const tlUcl = anomalies.filter(a=>a.type==='ucl').length;
    const tlZ = anomalies.filter(a=>a.type==='zscore').length;
    const tlSpike = anomalies.filter(a=>a.type==='spike').length;
    const tlRule = anomalies.filter(a=>a.type==='trend7'||a.type==='bias8').length;
    html += '<div class="ai-timeline"><h3>🕐 이상 이벤트 타임라인</h3>';
    html += `<div style="font-size:12px;color:var(--text-light);margin-bottom:10px">총 ${anomalies.length}건 — 관리범위 초과 ${tlUcl}건, 극단값 ${tlZ}건, 급격한 증가 ${tlSpike}건, 연속 패턴 ${tlRule}건</div>`;
    anomalies.slice(0, 25).forEach(a => {
      const d = typeof a.date === 'string' ? a.date : dateStr(a.date);
      const typeLabel = { ucl:'관리범위 초과', zscore:'극단값', spike:'급격한 증가', trend7:'7일 연속 악화', bias8:'지속 고위험' };
      html += `<div class="ai-tl-item">
        <span class="ai-tl-date">${dateKR(d)}</span>
        <span class="ai-tl-badge ${a.severity}">${a.severity==='danger'?'위험':'주의'}</span>
        <span style="font-size:10px;color:var(--text-light);min-width:65px">${typeLabel[a.type]||a.type}</span>
        <span class="ai-tl-text">${a.desc}</span>
      </div>`;
    });
    html += '</div>';
  }

  html += '</div>'; // close aiDetailSection

  el.innerHTML = html;

  // 스파크라인은 상세 영역 열릴 때 렌더링 (차트는 toggleAIDetail에서 지연 렌더링)
  const origToggle = toggleAIDetail;
  const itemDailyMap = new Map();
  if (filtered && filtered.length) {
    const ibd = aggByItemDate(filtered);
    for (const r of ibd) {
      if (!itemDailyMap.has(r.품명)) itemDailyMap.set(r.품명, []);
      itemDailyMap.get(r.품명).push(r.불량률 * 100);
    }
  }
  // 스파크라인은 상세 섹션 첫 열림 시 렌더링
  const detailEl = document.getElementById('aiDetailSection');
  if (detailEl) {
    const observer = new MutationObserver(() => {
      if (detailEl.style.display !== 'none' && !detailEl.dataset.sparksRendered) {
        detailEl.dataset.sparksRendered = '1';
        warnings.forEach((w, i) => {
          const sparkEl = document.getElementById('aiSpark' + i);
          if (sparkEl && w.item && itemDailyMap.has(w.item)) {
            renderSparkline(sparkEl, itemDailyMap.get(w.item), w.severity === 'danger' ? '#DC2626' : '#F59E0B');
          } else if (sparkEl) {
            renderSparkline(sparkEl, byDate.map(r => r.불량률 * 100), '#6B7280');
          }
        });
      }
    });
    observer.observe(detailEl, { attributes: true, attributeFilter: ['style'] });
  }
}

/* ================================================================
   Phase 3: 다크모드
   ================================================================ */
/* ================================================================
   주간 보고 함수
   ================================================================ */

/* 공통: 양품률 → 시그마 수준 */
function calcSigmaLevel(yieldPct) {
  const tbl = [[99.99966,6],[99.9977,5.5],[99.977,5],[99.87,4.5],[99.38,4],[97.73,3.5],[95.45,3],[93.32,2.5],[84.13,2],[69.15,1.5],[50,1]];
  for (const [y,s] of tbl) { if (yieldPct >= y) return s; }
  return 1;
}

/* ① 시그마 수준 추이 차트 */
function chartSigmaTrend(byDate, el) {
  if (!byDate || !byDate.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터가 없습니다.</p>'; return; }
  const dates = byDate.map(r => dateKR(r.생산일자));
  const sigmas = byDate.map(r => {
    const yld = r.생산수량 > 0 ? r.양품수량 / r.생산수량 * 100 : 100;
    return calcSigmaLevel(yld);
  });
  const mb = isMobile();
  const sigmaColor = s => s >= 5 ? '#16A34A' : s >= 4 ? '#2563EB' : s >= 3 ? '#F59E0B' : '#DC2626';
  const refLines = [
    {y:6, name:'6σ (3.4 PPM)', color:'#16A34A'},
    {y:5, name:'5σ (233 PPM)', color:'#2563EB'},
    {y:4, name:'4σ (6,210 PPM)', color:'#F59E0B'},
    {y:3, name:'3σ (66,807 PPM)', color:'#DC2626'},
  ];
  Plotly.newPlot(el, [
    { x:dates, y:sigmas, type:'scatter', mode:'lines+markers', name:'일별 시그마 수준',
      line:{color:'#7C3AED',width:2.5},
      marker:{size:mb?5:8, color:sigmas.map(sigmaColor)} },
    ...refLines.map(r => ({
      x:[dates[0],dates[dates.length-1]], y:[r.y,r.y],
      type:'scatter', mode:'lines', name:r.name,
      line:{color:r.color, width:1.5, dash:'dot'}, showlegend:true
    }))
  ], {
    yaxis:{title:mb?'':'시그마 수준(σ)', range:[1.5,6.5], dtick:0.5},
    legend:{orientation:'h', y:mb?1.3:1.15, font:{size:mb?9:11}},
    height:chartHeight(400,300),
    margin:mb?{t:30,b:40,l:40,r:20}:{t:30,b:50,l:60,r:40}
  }, getPlotCfg());
}

/* ② PPM 기준 파레토 차트 */
function chartPPMPareto(byItem, el) {
  const data = [...byItem].filter(r => r.생산수량 >= 50 && r.PPM > 0)
    .sort((a,b) => b.PPM - a.PPM).slice(0, 20);
  if (!data.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">데이터 부족 (생산 50개 이상 품목 없음)</p>'; return; }
  const totalPPM = data.reduce((s,r) => s + r.PPM, 0);
  let cum = 0;
  const cumPct = data.map(r => { cum += r.PPM; return cum / totalPPM * 100; });
  const mb = isMobile();
  const tgtPPM = targetDefectRate / 100 * 1000000;
  const names = data.map(r => r.품명.length > 12 ? r.품명.slice(0,12)+'...' : r.품명);
  Plotly.newPlot(el, [
    { x:names, y:data.map(r=>Math.round(r.PPM)), type:'bar', name:'PPM',
      marker:{color:data.map(r => r.PPM > tgtPPM*2 ? '#DC2626' : r.PPM > tgtPPM ? '#F59E0B' : '#2563EB'), opacity:.85},
      text:data.map(r=>fmt(Math.round(r.PPM))), textposition:'outside', textfont:{size:mb?9:11} },
    { x:names, y:cumPct, type:'scatter', mode:'lines+markers'+(mb?'':'+text'), name:'누적 비율',
      marker:{size:mb?5:7,symbol:'diamond'}, line:{color:'#DC2626',width:2.5},
      text:cumPct.map(v=>pct(v,1)), textposition:'top center',
      textfont:{size:mb?8:10,color:'#DC2626'}, yaxis:'y2' }
  ], {
    title:mb?'':'품목별 PPM 파레토 (상위 20개)',
    yaxis:{title:mb?'':'PPM'},
    yaxis2:{title:mb?'':'누적 비율(%)', overlaying:'y', side:'right', range:[0,110]},
    shapes:[{type:'line',yref:'y2',y0:80,y1:80,x0:0,x1:1,xref:'paper',line:{dash:'dash',color:'#F59E0B',width:1.5}}],
    legend:{orientation:'h',y:mb?1.18:1.12,font:{size:mb?9:12}},
    height:chartHeight(420,320),
    margin:mb?{t:30,b:70,l:40,r:40}:{t:60,b:90,l:60,r:60}
  }, getPlotCfg());
}

/* ③ 월별 PPM 목표 달성 차트 */
function chartMonthlyPPM(byMonth, el) {
  if (!byMonth || !byMonth.length) { el.innerHTML='<p style="color:var(--text-light);padding:20px">월별 데이터가 부족합니다 (2개월 이상 필요).</p>'; return; }
  const tgtPPM = Math.round(targetDefectRate / 100 * 1000000);
  const labels = byMonth.map(r => dateKRMonth(r.생산일자));
  const ppms   = byMonth.map(r => Math.round(r.PPM));
  let cp = 0, cb = 0;
  const cumPPMs = byMonth.map(r => { cp += r.생산수량; cb += r.불량수량; return cp > 0 ? Math.round(cb/cp*1000000) : 0; });
  const mb = isMobile();
  Plotly.newPlot(el, [
    { x:labels, y:ppms, type:'bar', name:'월별 PPM',
      marker:{color:ppms.map(v => v > tgtPPM ? '#DC2626' : '#2563EB'), opacity:.8},
      text:ppms.map(v=>fmt(v)), textposition:'outside', textfont:{size:mb?9:11} },
    { x:labels, y:cumPPMs, type:'scatter', mode:'lines+markers', name:'누적 PPM',
      line:{color:'#7C3AED',width:2.5}, marker:{size:mb?6:8} },
    { x:[labels[0],labels[labels.length-1]], y:[tgtPPM,tgtPPM], type:'scatter', mode:'lines',
      name:'목표 PPM ('+fmt(tgtPPM)+')',
      line:{color:'#16A34A',width:2,dash:'dash'} }
  ], {
    title:mb?'':'월별 PPM 현황 및 누적 추이',
    yaxis:{title:mb?'':'PPM'},
    legend:{orientation:'h',y:mb?1.18:1.12,font:{size:mb?9:12}},
    height:chartHeight(380,280),
    margin:mb?{t:30,b:40,l:50,r:20}:{t:30,b:50,l:70,r:40}
  }, getPlotCfg());
}

/* ④ 주간 경영 보고서 HTML 생성 */
function generateWeeklyReport(kpi, byDate, byItem, byWeek) {
  const now = new Date();
  const todayLabel = now.getFullYear()+'년 '+(now.getMonth()+1)+'월 '+now.getDate()+'일';
  const tgtPPM   = Math.round(targetDefectRate / 100 * 1000000);
  const tgtRate  = targetDefectRate;
  const curRate  = kpi.불량률;   // calcKPI가 이미 ×100한 퍼센트값
  const curPPM   = Math.round(kpi.PPM || 0);
  const yldPct   = kpi.총생산수량 > 0 ? kpi.총양품수량 / kpi.총생산수량 * 100 : 100;
  const sigma    = calcSigmaLevel(yldPct);
  const isOk     = curRate <= tgtRate;

  // 최근 주 / 전주
  const wCur  = byWeek.length >= 1 ? byWeek[byWeek.length-1] : null;
  const wPrev = byWeek.length >= 2 ? byWeek[byWeek.length-2] : null;
  const wChg  = (wCur && wPrev) ? (wCur.불량률 - wPrev.불량률) * 100 : null;

  // 위험 품목 TOP3
  const top3 = [...byItem].filter(r => r.생산수량 >= 50)
    .sort((a,b) => b.불량률 - a.불량률).slice(0, 3);

  // 목표 초과 일수
  const overDays = byDate.filter(r => r.불량률 * 100 > tgtRate).length;

  // 핵심 메시지 생성
  let headline, headlineColor;
  if (isOk) {
    headline = `불량률 ${curRate.toFixed(2)}%로 목표(${tgtRate.toFixed(1)}%)를 달성하고 있습니다.` +
      (wChg !== null && wChg < -0.02 ? ` 전주 대비 ${Math.abs(wChg).toFixed(2)}%p 개선 중입니다.` : '');
    headlineColor = '#16A34A';
  } else {
    const over = (curRate - tgtRate).toFixed(2);
    headline = `불량률 ${curRate.toFixed(2)}%로 목표(${tgtRate.toFixed(1)}%) 대비 ${over}%p 초과 중입니다. 집중 관리가 필요합니다.`;
    headlineColor = '#DC2626';
  }

  // 트렌드 방향
  const trendLabel = wChg === null ? '데이터 부족' : wChg < -0.05 ? '개선' : wChg > 0.05 ? '악화' : '유지';
  const trendColor = trendLabel === '개선' ? '#16A34A' : trendLabel === '악화' ? '#DC2626' : '#6B7280';
  const trendArrow = trendLabel === '개선' ? '▼' : trendLabel === '악화' ? '▲' : '─';

  // 기간 레이블
  const periodLabel = byDate.length >= 2
    ? dateKRFull(dateStr(byDate[0].생산일자)) + ' ~ ' + dateKRFull(dateStr(byDate[byDate.length-1].생산일자))
    : '-';

  // ──── 대표자 경영 브리핑 계산 ────
  const overRatio   = byDate.length ? overDays / byDate.length : 0;
  // 신호등: 목표 초과이면 적, 초과일 30%↑이면 황, 그 외 녹
  const sigLight    = !isOk ? 'red' : overRatio > 0.3 ? 'yellow' : 'green';
  const sigEmoji    = sigLight === 'green' ? '🟢' : sigLight === 'yellow' ? '🟡' : '🔴';
  const sigLabel    = sigLight === 'green' ? '정상' : sigLight === 'yellow' ? '주의' : '위험';
  const sigBg       = sigLight === 'green' ? '#F0FDF4' : sigLight === 'yellow' ? '#FEFCE8' : '#FFF1F2';
  const sigBorder   = sigLight === 'green' ? '#86EFAC' : sigLight === 'yellow' ? '#FDE047' : '#FECACA';
  const sigColor    = sigLight === 'green' ? '#15803D' : sigLight === 'yellow' ? '#854D0E' : '#991B1B';

  // 핵심 키워드 태그
  const kwTags = [];
  if (isOk) kwTags.push({t:'✅ 목표 달성',          c:'#15803D', bg:'#D1FAE5'});
  else       kwTags.push({t:'⚠️ 목표 초과',           c:'#991B1B', bg:'#FEE2E2'});
  if      (trendLabel === '개선') kwTags.push({t:'📉 불량 개선세', c:'#1D4ED8', bg:'#DBEAFE'});
  else if (trendLabel === '악화') kwTags.push({t:'📈 불량 악화세', c:'#991B1B', bg:'#FEE2E2'});
  if (overDays === 0)        kwTags.push({t:'🎯 전일 달성',        c:'#15803D', bg:'#D1FAE5'});
  else if (overRatio > 0.5)  kwTags.push({t:'🚨 과반 초과',        c:'#991B1B', bg:'#FEE2E2'});
  const dangerItems = [...byItem].filter(r => r.생산수량 >= 50 && r.불량률 * 100 > tgtRate * 2);
  if (dangerItems.length) kwTags.push({t:`🔴 위험품목 ${dangerItems.length}개`, c:'#991B1B', bg:'#FEE2E2'});
  kwTags.push(sigma >= 5
    ? {t:`${sigma.toFixed(1)}σ 우수`, c:'#15803D', bg:'#D1FAE5'}
    : sigma >= 4
      ? {t:`${sigma.toFixed(1)}σ 양호`, c:'#1D4ED8', bg:'#DBEAFE'}
      : sigma >= 3
        ? {t:`${sigma.toFixed(1)}σ 주의`, c:'#854D0E', bg:'#FEF9C3'}
        : {t:`${sigma.toFixed(1)}σ 위험`, c:'#991B1B', bg:'#FEE2E2'});

  // 경영 인사이트 불릿 (3~5개, 자동 생성)
  const execInsights = [];
  if (isOk) {
    execInsights.push(`불량률 <b>${curRate.toFixed(2)}%</b>로 목표 대비 <b style="color:#15803D">${(tgtRate - curRate).toFixed(2)}%p 여유</b> — 현 수준 유지 권고`);
  } else {
    execInsights.push(`불량률 <b style="color:#DC2626">${curRate.toFixed(2)}%</b>로 목표 대비 <b style="color:#DC2626">+${(curRate - tgtRate).toFixed(2)}%p 초과</b> — 즉각 개선 조치 필요`);
  }
  if (wChg !== null) {
    if (wChg < -0.05)
      execInsights.push(`전주 대비 <b style="color:#15803D">${Math.abs(wChg).toFixed(2)}%p 개선</b> — 개선 활동 지속 효과 확인됨`);
    else if (wChg > 0.05)
      execInsights.push(`전주 대비 <b style="color:#DC2626">+${wChg.toFixed(2)}%p 악화</b> — 이번 주 변동 원인 긴급 점검 필요`);
    else
      execInsights.push(`전주 대비 ±${Math.abs(wChg).toFixed(2)}%p 유사 수준 <b>유지 중</b> — 추이 지속 관찰`);
  }
  if (overDays === 0) {
    execInsights.push(`분석 기간 <b style="color:#15803D">전 ${byDate.length}일 목표 달성</b> — 공정 안정 상태`);
  } else if (overRatio > 0.5) {
    execInsights.push(`${byDate.length}일 중 <b style="color:#DC2626">${overDays}일(${Math.round(overRatio * 100)}%) 목표 초과</b> — 구조적 공정 불안정, 근본 원인 분석 필요`);
  } else {
    execInsights.push(`${byDate.length}일 중 <b style="color:#D97706">${overDays}일 목표 초과</b> — 해당 일자 특이 요인 파악 후 재발 방지 조치 필요`);
  }
  if (top3.length) {
    const w = top3[0];
    execInsights.push(`최고 위험 품목 <b>「${w.품명}」</b> — 불량률 <b style="color:#DC2626">${pct(w.불량률 * 100)}</b>, 즉시 공정 점검 및 집중 관리 대상`);
  }
  if (sigma < 4) {
    execInsights.push(`시그마 수준 <b style="color:${sigma < 3 ? '#DC2626' : '#D97706'}">${sigma.toFixed(1)}σ</b> — ${sigma < 3 ? '긴급 공정 표준화 및 설비 점검 필요' : '품질 개선 활동 강화 권고'}`);
  }

  const wRow = (label, cur, prev, target, goodFn) => {
    const isGood = goodFn ? goodFn(cur) : true;
    const chg = prev !== null ? cur - prev : null;
    const chgStr = chg !== null ? (chg > 0 ? '+' : '') + chg.toFixed(chg > 100 ? 0 : 2) : '-';
    const chgColor = chg === null ? '#6B7280' : goodFn(cur - chg) !== goodFn(cur) ? (isGood ? '#16A34A' : '#DC2626') : '#6B7280';
    return `<tr style="background:${isGood?'transparent':'#FEF2F2'}">
      <td style="padding:8px 12px;font-weight:600;color:var(--text)">${label}</td>
      <td style="padding:8px 12px;font-weight:700;color:${isGood?'#16A34A':'#DC2626'};text-align:center">
        ${typeof cur==='number'?cur.toFixed(cur>100?0:2):cur}
        ${isGood ? '' : '<span style="font-size:10px;background:#FEE2E2;color:#DC2626;border-radius:4px;padding:1px 5px;margin-left:4px;font-weight:700">▲ 초과</span>'}
      </td>
      <td style="padding:8px 12px;text-align:center;color:var(--text-light)">${prev !== null ? (typeof prev==='number'?prev.toFixed(prev>100?0:2):prev) : '-'}</td>
      <td style="padding:8px 12px;text-align:center;color:${chgColor}">${chgStr}</td>
      <td style="padding:8px 12px;text-align:center;font-weight:600;color:#16A34A">${target}</td>
    </tr>`;
  };

  return `
  <div style="width:100%;font-family:inherit">
    <!-- 헤더 -->
    <div style="background:var(--primary);color:#fff;border-radius:12px;padding:20px 24px;margin-bottom:16px">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;flex-wrap:wrap;gap:8px">
        <div>
          <div style="font-size:11px;opacity:.8;margin-bottom:4px">남도금속 품질경영</div>
          <div style="font-size:20px;font-weight:800">주간 품질 경영 보고서</div>
          <div style="font-size:12px;opacity:.85;margin-top:4px">분석 기간: ${periodLabel}</div>
        </div>
        <div style="text-align:right">
          <div style="font-size:11px;opacity:.8">작성일</div>
          <div style="font-size:14px;font-weight:700">${todayLabel}</div>
        </div>
      </div>
    </div>

    <!-- 대표자 경영 브리핑 -->
    <div style="background:${sigBg};border:1.5px solid ${sigBorder};border-radius:12px;padding:18px 22px;margin-bottom:16px">
      <!-- 타이틀 행 -->
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
        <span style="font-size:26px;line-height:1">${sigEmoji}</span>
        <div>
          <div style="font-size:10px;font-weight:700;color:${sigColor};letter-spacing:.06em;text-transform:uppercase;margin-bottom:2px">대표자 경영 브리핑</div>
          <div style="font-size:17px;font-weight:800;color:${sigColor}">종합 품질 상태 — ${sigLabel}</div>
        </div>
      </div>
      <!-- 키워드 태그 -->
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:14px">
        ${kwTags.map(k => `<span style="background:${k.bg};color:${k.c};font-size:12px;font-weight:700;padding:5px 13px;border-radius:20px;border:1px solid ${k.c}40;white-space:nowrap">${k.t}</span>`).join('')}
      </div>
      <!-- 인사이트 -->
      <div style="background:rgba(255,255,255,0.75);border-radius:8px;padding:14px 18px">
        <div style="font-size:11px;font-weight:700;color:${sigColor};letter-spacing:.04em;margin-bottom:10px">📋 핵심 인사이트</div>
        <ul style="margin:0;padding-left:20px;display:flex;flex-direction:column;gap:7px">
          ${execInsights.map(i => `<li style="font-size:13px;color:#1F2937;line-height:1.6">${i}</li>`).join('')}
        </ul>
      </div>
    </div>

    <!-- 핵심 KPI 카드 -->
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-bottom:16px">
      ${[
        {label:'불량률', val:curRate.toFixed(2)+'%', sub:'목표 '+tgtRate.toFixed(1)+'%', ok:isOk},
        {label:'PPM (백만개당 불량)', val:fmt(curPPM), sub:'목표 '+fmt(tgtPPM), ok:curPPM<=tgtPPM},
        {label:'시그마(σ) 수준', val:sigma.toFixed(1)+'σ',
          sub:sigma>=5?'우수':sigma>=4?'양호':sigma>=3?'주의':'위험', ok:sigma>=4,
          note:sigma>=5?'6σ 세계최고 수준':sigma>=4?'양호 – 일반 산업 기준':sigma>=3?'3σ – 공정 개선 필요':'3σ 미만 – 긴급 개선',
          tip:'시그마 수준 해설\n6σ = 불량 3.4 PPM (세계 최우수)\n5σ = 불량 233 PPM (우수)\n4σ = 불량 6,210 PPM (양호, 일반 산업 목표)\n3σ = 불량 66,807 PPM (주의, 개선 필요)\n3σ 미만 = 공정 불안정, 긴급 대응 필요'},
        {label:'총 생산수량', val:fmt(kpi.총생산수량)+'개', sub:byDate.length+'일간', ok:true},
        {label:'목표 초과 일수', val:overDays+'일', sub:'전체 '+byDate.length+'일 중', ok:overDays===0},
      ].map(c=>`<div style="background:var(--white);border:1px solid ${c.ok?'#D1FAE5':'#FEE2E2'};border-radius:10px;padding:14px 16px;text-align:center;cursor:${c.tip?'help':'default'}" ${c.tip?`title="${c.tip}"`:''}}>
        <div style="font-size:11px;color:var(--text-light);margin-bottom:4px">${c.label}${c.tip?' ℹ️':''}</div>
        <div style="font-size:18px;font-weight:800;color:${c.ok?'#16A34A':'#DC2626'}">${c.val}</div>
        <div style="font-size:11px;color:var(--text-light);margin-top:2px">${c.sub}</div>
        ${c.note?`<div style="font-size:10px;color:${c.ok?'#16A34A':'#DC2626'};margin-top:4px;font-weight:600">${c.note}</div>`:''}
      </div>`).join('')}
    </div>

    <!-- 주별/월별 추이 차트 -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
      <div style="background:var(--white);border:1px solid var(--border);border-radius:10px;padding:14px 16px">
        <div style="font-size:13px;font-weight:700;color:var(--text);margin-bottom:8px">주별 불량률 추이</div>
        <div id="chartWeeklyDefect" style="height:400px"></div>
      </div>
      <div style="background:var(--white);border:1px solid var(--border);border-radius:10px;padding:14px 16px">
        <div style="font-size:13px;font-weight:700;color:var(--text);margin-bottom:8px">월별 생산 실적</div>
        <div id="chartMonthlyPerf" style="height:400px"></div>
      </div>
    </div>

    <!-- 주간 비교 테이블 -->
    ${wCur ? `<div style="background:var(--white);border:1px solid var(--border);border-radius:10px;margin-bottom:16px;overflow:hidden">
      <div style="padding:12px 16px;font-weight:700;font-size:14px;border-bottom:1px solid var(--border);background:var(--bg)">
        주간 비교 (최근 주 vs 전주)
      </div>
      <div style="overflow-x:auto">
        <table style="width:100%;border-collapse:collapse;font-size:13px">
          <thead>
            <tr style="background:var(--bg)">
              <th style="padding:8px 12px;text-align:left;color:var(--text-light);font-weight:600">지표</th>
              <th style="padding:8px 12px;text-align:center;color:var(--text-light);font-weight:600">이번 주<br><small>${wCur.생산일자}</small></th>
              <th style="padding:8px 12px;text-align:center;color:var(--text-light);font-weight:600">전주<br><small>${wPrev?wPrev.생산일자:'-'}</small></th>
              <th style="padding:8px 12px;text-align:center;color:var(--text-light);font-weight:600">전주 대비</th>
              <th style="padding:8px 12px;text-align:center;color:var(--text-light);font-weight:600">목표</th>
            </tr>
          </thead>
          <tbody>
            ${wRow('불량률(%)', wCur.불량률*100, wPrev?wPrev.불량률*100:null, tgtRate.toFixed(1)+'%', v=>v<=tgtRate)}
            ${wRow('PPM', wCur.PPM, wPrev?wPrev.PPM:null, fmt(tgtPPM), v=>v<=tgtPPM)}
            ${wRow('생산수량(개)', wCur.생산수량, wPrev?wPrev.생산수량:null, '-', ()=>true)}
            ${wRow('불량수량(개)', wCur.불량수량, wPrev?wPrev.불량수량:null, '-', v=>v<=(wPrev?wPrev.불량수량:v))}
          </tbody>
        </table>
      </div>
    </div>` : '<div style="background:var(--bg);border-radius:8px;padding:12px;margin-bottom:16px;font-size:13px;color:var(--text-light)">주간 비교를 위한 2주 이상의 데이터가 필요합니다.</div>'}

    <!-- 일별 실적 현황 -->
    ${byDate.length ? `<div style="background:var(--white);border:1px solid var(--border);border-radius:10px;margin-bottom:16px;overflow:hidden">
      <div style="padding:12px 16px;border-bottom:1px solid var(--border);background:var(--bg);display:flex;justify-content:space-between;align-items:center">
        <span style="font-weight:700;font-size:14px">일별 실적 현황</span>
        <span style="font-size:12px;color:var(--text-light)">
          목표 달성 <span style="color:#16A34A;font-weight:700">${byDate.filter(r=>r.불량률*100<=tgtRate).length}일</span>
          / 초과 <span style="color:#DC2626;font-weight:700">${overDays}일</span>
          (전체 ${byDate.length}일)
        </span>
      </div>
      <div style="overflow-x:auto">
        <table style="width:100%;border-collapse:collapse;font-size:13px">
          <thead>
            <tr style="background:var(--bg)">
              <th style="padding:8px 12px;text-align:left;color:var(--text-light);font-weight:600">날짜</th>
              <th style="padding:8px 12px;text-align:right;color:var(--text-light);font-weight:600">생산수량</th>
              <th style="padding:8px 12px;text-align:right;color:var(--text-light);font-weight:600">양품수량</th>
              <th style="padding:8px 12px;text-align:right;color:var(--text-light);font-weight:600">불량수량</th>
              <th style="padding:8px 12px;text-align:right;color:var(--text-light);font-weight:600">불량률</th>
              <th style="padding:8px 12px;text-align:right;color:var(--text-light);font-weight:600">PPM</th>
              <th style="padding:8px 12px;text-align:center;color:var(--text-light);font-weight:600">목표대비</th>
              <th style="padding:8px 12px;text-align:center;color:var(--text-light);font-weight:600">상태</th>
            </tr>
          </thead>
          <tbody>
            ${byDate.map(r=>{
              const rate=r.불량률*100, over=rate>tgtRate, diff=rate-tgtRate;
              return `<tr style="background:${over?'#FEF2F2':'transparent'};border-bottom:1px solid var(--border)">
                <td style="padding:8px 12px;font-weight:600">${dateKRFull(dateStr(r.생산일자))}</td>
                <td style="padding:8px 12px;text-align:right">${fmt(r.생산수량)}</td>
                <td style="padding:8px 12px;text-align:right">${fmt(r.양품수량)}</td>
                <td style="padding:8px 12px;text-align:right;color:${over?'#DC2626':'inherit'}">${fmt(r.불량수량)}</td>
                <td style="padding:8px 12px;text-align:right;font-weight:700;color:${over?'#DC2626':'#16A34A'}">${pct(rate)}</td>
                <td style="padding:8px 12px;text-align:right">${fmt(Math.round(r.PPM||0))}</td>
                <td style="padding:8px 12px;text-align:center;font-weight:600;color:${over?'#DC2626':'#16A34A'}">${diff>=0?'+':''}${diff.toFixed(2)}%p</td>
                <td style="padding:8px 12px;text-align:center;white-space:nowrap;width:60px">
                  <span style="background:${over?'#FEE2E2':'#D1FAE5'};color:${over?'#DC2626':'#16A34A'};font-size:11px;font-weight:700;padding:3px 10px;border-radius:4px;white-space:nowrap;display:inline-block">${over?'▲ 초과':'✓ 달성'}</span>
                </td>
              </tr>`;
            }).join('')}
          </tbody>
          <tfoot>
            <tr style="background:var(--bg);font-weight:700;border-top:2px solid var(--border)">
              <td style="padding:8px 12px">합 계</td>
              <td style="padding:8px 12px;text-align:right">${fmt(byDate.reduce((s,r)=>s+r.생산수량,0))}</td>
              <td style="padding:8px 12px;text-align:right">${fmt(byDate.reduce((s,r)=>s+r.양품수량,0))}</td>
              <td style="padding:8px 12px;text-align:right">${fmt(byDate.reduce((s,r)=>s+r.불량수량,0))}</td>
              <td style="padding:8px 12px;text-align:right;color:${isOk?'#16A34A':'#DC2626'}">${curRate.toFixed(2)}%</td>
              <td style="padding:8px 12px;text-align:right">${fmt(curPPM)}</td>
              <td colspan="2"></td>
            </tr>
          </tfoot>
        </table>
      </div>
    </div>` : ''}

    <!-- 품목별 워스트5 / 베스트5 -->
    ${(()=>{
      const items = [...byItem].filter(r=>r.생산수량>=50).sort((a,b)=>b.불량률-a.불량률);
      const worst5 = items.slice(0,5);
      const best5  = items.slice(-5).reverse();
      const overCnt = items.filter(r=>r.불량률*100>tgtRate).length;
      const itemRow = (r, i, rankColor, isWorst) => {
        const rate=r.불량률*100, over=rate>tgtRate, diff=rate-tgtRate;
        const badge=rate>tgtRate*2?{t:'위험',c:'#DC2626',bg:'#FEE2E2'}:rate>tgtRate?{t:'주의',c:'#D97706',bg:'#FEF3C7'}:{t:'달성',c:'#16A34A',bg:'#D1FAE5'};
        return `<tr style="background:${over?'#FEF2F2':isWorst?'transparent':'#F0FDF4'};border-bottom:1px solid var(--border)">
          <td style="padding:8px 10px;text-align:center;font-weight:700;color:${rankColor}">${i+1}</td>
          <td style="padding:8px 12px;font-weight:600;max-width:220px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${r.품명}</td>
          <td style="padding:8px 12px;text-align:right">${fmt(r.생산수량)}</td>
          <td style="padding:8px 12px;text-align:right;color:${over?'#DC2626':'inherit'}">${fmt(r.불량수량)}</td>
          <td style="padding:8px 12px;text-align:right;font-weight:700;color:${over?'#DC2626':'#16A34A'}">${pct(rate)}</td>
          <td style="padding:8px 12px;text-align:right">${fmt(Math.round(r.PPM))}</td>
          <td style="padding:8px 12px;text-align:center;font-weight:600;color:${over?'#DC2626':'#16A34A'}">${diff>=0?'+':''}${diff.toFixed(2)}%p</td>
          <td style="padding:8px 12px;text-align:center;white-space:nowrap;width:52px"><span style="background:${badge.bg};color:${badge.c};font-size:11px;font-weight:700;padding:3px 10px;border-radius:4px;white-space:nowrap;display:inline-block">${badge.t}</span></td>
        </tr>`;
      };
      const thStyle = `padding:8px 12px;color:var(--text-light);font-weight:600`;
      const thead = `<thead><tr style="background:var(--bg)">
        <th style="${thStyle};text-align:center;width:36px">순위</th>
        <th style="${thStyle};text-align:left">품명</th>
        <th style="${thStyle};text-align:right">생산수량</th>
        <th style="${thStyle};text-align:right">불량수량</th>
        <th style="${thStyle};text-align:right">불량률</th>
        <th style="${thStyle};text-align:right">PPM</th>
        <th style="${thStyle};text-align:center">목표대비</th>
        <th style="${thStyle};text-align:center">상태</th>
      </tr></thead>`;
      return `<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
        <!-- 워스트 5 -->
        <div style="background:var(--white);border:1px solid #FECACA;border-radius:10px;overflow:hidden">
          <div style="padding:10px 16px;border-bottom:1px solid #FECACA;background:#FEF2F2;display:flex;justify-content:space-between;align-items:center">
            <span style="font-weight:700;font-size:14px;color:#DC2626">🔴 워스트 5 (불량률 상위)</span>
            <span style="font-size:12px;color:#DC2626;font-weight:600">목표 초과 ${overCnt}개 품목</span>
          </div>
          <div style="overflow-x:auto">
            <table style="width:100%;border-collapse:collapse;font-size:13px">
              ${thead}
              <tbody>${worst5.map((r,i)=>itemRow(r,i,['#DC2626','#F59E0B','#D97706','#6B7280','#6B7280'][i],true)).join('')}</tbody>
            </table>
          </div>
        </div>
        <!-- 베스트 5 -->
        <div style="background:var(--white);border:1px solid #BBF7D0;border-radius:10px;overflow:hidden">
          <div style="padding:10px 16px;border-bottom:1px solid #BBF7D0;background:#F0FDF4;display:flex;justify-content:space-between;align-items:center">
            <span style="font-weight:700;font-size:14px;color:#15803D">🟢 베스트 5 (불량률 하위)</span>
            <span style="font-size:12px;color:#15803D;font-weight:600">생산 50개 이상 ${items.length}개 품목</span>
          </div>
          <div style="overflow-x:auto">
            <table style="width:100%;border-collapse:collapse;font-size:13px">
              ${thead}
              <tbody>${best5.map((r,i)=>itemRow(r,i,'#16A34A',false)).join('')}</tbody>
            </table>
          </div>
        </div>
      </div>`;
    })()}

    <!-- 트렌드 & 총평 -->
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
      <div style="background:var(--white);border:1px solid var(--border);border-radius:10px;padding:16px">
        <div style="font-size:11px;font-weight:700;color:var(--text-light);margin-bottom:8px">트렌드 분석</div>
        <div style="font-size:22px;font-weight:800;color:${trendColor}">${trendArrow} ${trendLabel}</div>
        ${wChg !== null ? `<div style="font-size:12px;color:var(--text-light);margin-top:4px">전주 대비 ${wChg>0?'+':''}${wChg.toFixed(2)}%p</div>` : ''}
        <div style="font-size:12px;color:var(--text-light);margin-top:4px">목표 초과 ${overDays}일 / 전체 ${byDate.length}일</div>
      </div>
      <div style="background:var(--white);border:1px solid var(--border);border-radius:10px;padding:16px">
        <div style="font-size:11px;font-weight:700;color:var(--text-light);margin-bottom:8px">시그마(σ) 품질 수준</div>
        <div style="font-size:22px;font-weight:800;color:${sigma>=5?'#16A34A':sigma>=4?'#2563EB':sigma>=3?'#F59E0B':'#DC2626'}">${sigma.toFixed(1)}σ &nbsp;<span style="font-size:14px">${sigma>=5?'우수':sigma>=4?'양호':sigma>=3?'주의':'위험'}</span></div>
        <div style="font-size:11px;color:var(--text-light);margin-top:8px;line-height:1.7">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span style="color:${sigma>=6?'#16A34A':'var(--text-light)'}">6σ 세계최고</span><span style="color:#16A34A">≤ 3.4 PPM</span>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span style="color:${sigma>=5&&sigma<6?'#16A34A':'var(--text-light)'}">5σ 우수</span><span style="color:#16A34A">≤ 233 PPM</span>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span style="color:${sigma>=4&&sigma<5?'#2563EB':'var(--text-light)'}">4σ 양호</span><span style="color:#2563EB">≤ 6,210 PPM</span>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span style="color:${sigma>=3&&sigma<4?'#F59E0B':'var(--text-light)'}">3σ 주의</span><span style="color:#F59E0B">≤ 66,807 PPM</span>
          </div>
        </div>
        <div style="font-size:12px;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);font-weight:700;color:${sigma>=4?'#2563EB':'#DC2626'}">현재 PPM: ${fmt(curPPM)}</div>
      </div>
    </div>

    <!-- 출력/복사 버튼 -->
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button class="btn btn-sm" style="background:var(--gray);color:#fff"
        onclick="navigator.clipboard.writeText(document.getElementById('weeklyReportText').innerText).then(()=>showToast('클립보드에 복사되었습니다','success'))">
        텍스트 복사
      </button>
      <button class="btn btn-sm btn-primary" onclick="
        ['chartWeeklyDefect','chartMonthlyPerf'].forEach(id=>{
          const el=document.getElementById(id);
          if(el&&el._fullLayout) try{Plotly.Plots.resize(el);}catch(e){}
        });
        setTimeout(()=>window.print(),300);
      ">인쇄</button>
    </div>
  </div>
  <!-- 클립보드용 텍스트 (숨김) -->
  <div id="weeklyReportText" style="display:none">
[주간 품질 경영 보고서] ${todayLabel}
분석 기간: ${periodLabel}

[대표자 경영 브리핑] 종합 상태: ${sigEmoji} ${sigLabel}
키워드: ${kwTags.map(k=>k.t).join(' · ')}

[핵심 인사이트]
${execInsights.map((ins,i)=>`${i+1}. ${ins.replace(/<[^>]+>/g,'')}`).join('\n')}

[핵심 지표]
- 불량률: ${curRate.toFixed(2)}% (목표: ${tgtRate.toFixed(1)}%) → ${isOk?'목표 달성':'목표 초과'}
- PPM: ${fmt(curPPM)} (목표: ${fmt(tgtPPM)}) → ${curPPM<=tgtPPM?'목표 달성':'목표 초과'}
- 시그마 수준: ${sigma.toFixed(1)}σ
- 총 생산수량: ${fmt(kpi.총생산수량)}개 / ${byDate.length}일간
- 목표 초과 일수: ${overDays}일

[즉시 조치 품목 TOP3]
${top3.map((r,i)=>`${i+1}. ${r.품명} - 불량률 ${pct(r.불량률*100)}, PPM ${fmt(Math.round(r.PPM))}`).join('\n')}

[트렌드] ${trendArrow} ${trendLabel}${wChg!==null?' (전주 대비 '+(wChg>0?'+':'')+wChg.toFixed(2)+'%p)':''}
  </div>`;
}

/* 대시보드 렌더링
   ================================================================ */
/* ================================================================
   탭 서브필터 헬퍼
   ================================================================ */
function makeTabSubFilterHtml(prefix, applyFn, resetFn) {
  return `<div class="tab-subfilter" id="${prefix}SubFilter">
    <span class="tab-subfilter-label">📅 기간</span>
    <input type="date" id="${prefix}SubStart">
    <span style="color:var(--text-light);flex-shrink:0">~</span>
    <input type="date" id="${prefix}SubEnd">
    <button class="btn btn-sm btn-primary" style="flex-shrink:0;padding:3px 10px;font-size:12px" onclick="${applyFn}()">적용</button>
    <button class="btn btn-sm" style="background:var(--gray);color:#fff;flex-shrink:0;padding:3px 10px;font-size:12px" onclick="${resetFn}()">초기화</button>
    <span id="${prefix}SubInfo" class="tab-subfilter-info"></span>
  </div>`;
}
function initSubFilterDates(prefix) {
  const raw = window._rawFiltered;
  if (!raw || !raw.length) return;
  const dates = raw.map(r => dateStr(r.생산일자)).sort();
  const s = $(prefix + 'SubStart'), e = $(prefix + 'SubEnd');
  if (!s || !e) return;
  s.min = e.min = dates[0];
  s.max = e.max = dates[dates.length - 1];
  s.value = dates[0];
  e.value = dates[dates.length - 1];
}
function setSubFilterInfo(prefix, sub) {
  const el = $(prefix + 'SubInfo');
  if (!el) return;
  const days = [...new Set(sub.map(r => dateStr(r.생산일자)))].length;
  el.textContent = `(${days}일 · ${fmt(sub.length)}건)`;
}
function buildSPCKpiHtml(bd) {
  const totalBad  = bd.reduce((s, r) => s + r.불량수량, 0);
  const totalProd = bd.reduce((s, r) => s + r.생산수량, 0);
  const pbar   = totalProd ? totalBad / totalProd : 0;
  const pbarPct = pbar * 100;
  const avgN   = bd.length ? Math.round(totalProd / bd.length) : 1;
  const UCLavg = (pbar + 3 * Math.sqrt(pbar * (1 - pbar) / Math.max(avgN, 1))) * 100;
  const LCLavg = Math.max(0, (pbar - 3 * Math.sqrt(pbar * (1 - pbar) / Math.max(avgN, 1)))) * 100;
  const outCnt = bd.filter(r => {
    const pi = r.불량률 * 100, ni = Math.max(r.생산수량, 1);
    const ucli = (pbar + 3 * Math.sqrt(pbar * (1 - pbar) / ni)) * 100;
    const lcli = Math.max(0, (pbar - 3 * Math.sqrt(pbar * (1 - pbar) / ni)) * 100);
    return pi > ucli || pi < lcli;
  }).length;
  return `<div class="kpi-grid" style="grid-template-columns:repeat(3,1fr)">
    <div class="kpi-card"><div class="value" style="color:var(--primary)">${pct(pbarPct)}</div><div class="label">p̄ (중심선)</div></div>
    <div class="kpi-card"><div class="value" style="color:var(--danger)">${pct(UCLavg)}</div><div class="label">UCL (평균 nᵢ 기준)</div></div>
    <div class="kpi-card"><div class="value" style="color:var(--warning)">${pct(LCLavg)}</div><div class="label">LCL (평균 nᵢ 기준)</div></div>
  </div>
  <div class="kpi-grid" style="grid-template-columns:repeat(3,1fr);margin-top:10px">
    <div class="kpi-card"><div class="value" style="color:var(--gray)">${fmt(avgN)}</div><div class="label">평균 서브그룹 크기</div></div>
    <div class="kpi-card"><div class="value" style="color:${outCnt > 0 ? 'var(--danger)' : 'var(--success)'}">${outCnt}건</div><div class="label">관리이탈 횟수</div></div>
    <div class="kpi-card"><div class="value" style="color:${outCnt === 0 ? 'var(--success)' : 'var(--danger)'}">${outCnt === 0 ? '안정' : '불안정'}</div><div class="label">공정 상태</div></div>
  </div>`;
}

// ── 주간 보고 전역 헬퍼 (사이드바 필터 재적용 시에도 안정적으로 참조) ──
function shortWeekLabel(wLabel) {
  const m = wLabel.match(/(\d+)\/(\d+)\s*주/);
  return m ? m[1] + '/' + m[2] + ' 주' : wLabel;
}
function buildWeekBtnsHtml(weeks, selected) {
  let html = `<div id="weekBtnArea" style="overflow-x:auto;margin-bottom:16px;padding-bottom:4px">
    <div style="display:flex;gap:6px;min-width:max-content">`;
  const allActive = selected === '전체';
  html += `<button class="btn btn-sm ${allActive?'btn-primary':''}" style="${allActive?'':'background:var(--gray);color:#fff'}"
    data-week="전체" onclick="selectWeekReport('전체')">전체</button>`;
  weeks.forEach(w => {
    const active = selected === w.생산일자;
    html += `<button class="btn btn-sm ${active?'btn-primary':''}" style="${active?'':'background:var(--gray);color:#fff'}"
      data-week="${w.생산일자}" onclick="selectWeekReport('${w.생산일자}')">${shortWeekLabel(w.생산일자)}</button>`;
  });
  html += `</div></div>`;
  return html;
}
function selectWeekReport(wLabel) {
  window._selectedWeek = wLabel;
  const d = window._weeklyReportData;
  if (!d) return;
  const container = $('weekBtnContainer');
  if (container) container.innerHTML = buildWeekBtnsHtml(d.byWeek, wLabel);
  const area = $('weeklyReportArea');
  if (!area) return;
  if (wLabel === '전체') {
    area.innerHTML = generateWeeklyReport(d.kpi, d.byDate, d.byItem, d.byWeek);
    renderWeeklyCharts(d.byWeek, d.byMonth || [], '전체');
    return;
  }
  const sub = (window._rawFiltered || []).filter(r => weekLabel(dateStr(r.생산일자)) === wLabel);
  if (!sub.length) { showToast('해당 주 데이터가 없습니다.', 'warn', 3000); return; }
  const kpiW    = calcKPI(sub);
  const byDateW = aggByDate(sub);
  const byItemW = aggByItem(sub);
  const idx = d.byWeek.findIndex(w => w.생산일자 === wLabel);
  const byWeekCtx = idx > 0 ? [d.byWeek[idx - 1], d.byWeek[idx]] : [d.byWeek[idx]];
  area.innerHTML = generateWeeklyReport(kpiW, byDateW, byItemW, byWeekCtx);
  renderWeeklyCharts(d.byWeek, d.byMonth || [], wLabel);
}
function refreshWeeklyReport() {
  const d = window._weeklyReportData;
  if (!d) return;
  const sel = window._selectedWeek || '전체';
  const container = $('weekBtnContainer');
  if (container) container.innerHTML = buildWeekBtnsHtml(d.byWeek, sel);
  selectWeekReport(sel);
}

// ── 주간 보고: 주별/월별 Plotly 차트 렌더링 ──
function renderWeeklyCharts(allByWeek, allByMonth, selectedWeek) {
  const wEl = $('chartWeeklyDefect');
  const mEl = $('chartMonthlyPerf');
  const tgt  = (typeof targetDefectRate !== 'undefined') ? targetDefectRate : 0.8;

  // ── 주별 불량률 추이 차트 ──
  if (wEl && allByWeek && allByWeek.length) {
    const labels = allByWeek.map(w => shortWeekLabel(w.생산일자));
    const rates  = allByWeek.map(w => +(w.불량률 * 100).toFixed(3));
    const n = rates.length;

    // 선형 추세선
    let trend = rates.slice();
    if (n >= 2) {
      const mx = (n - 1) / 2, my = rates.reduce((a, b) => a + b, 0) / n;
      const b  = rates.reduce((s, v, i) => s + (i - mx) * (v - my), 0)
               / rates.reduce((s, _, i) => s + (i - mx) ** 2, 0);
      const a  = my - b * mx;
      trend = rates.map((_, i) => Math.max(0, +(a + b * i).toFixed(3)));
    }

    // Y축 범위: 데이터 근처로 줌인하여 차이를 명확히
    const rMin = Math.min(...rates, tgt);
    const rMax = Math.max(...rates, tgt);
    const pad  = (rMax - rMin) * 0.6 || 0.3;
    const yMin = Math.max(0, rMin - pad);
    const yMax = rMax + pad * 1.2;

    // 막대 색상
    const colors = allByWeek.map(w => {
      const over = w.불량률 * 100 > tgt;
      const sel  = selectedWeek && selectedWeek !== '전체' && w.생산일자 === selectedWeek;
      if (sel) return over ? '#B91C1C' : '#15803D';
      return over ? '#EF4444' : '#22C55E';
    });

    Plotly.newPlot(wEl, [
      // 막대
      { type: 'bar', x: labels, y: rates,
        marker: { color: colors, line: { color: 'rgba(255,255,255,0.4)', width: 1 } },
        text: rates.map(v => '<b>' + v.toFixed(2) + '%</b>'),
        textposition: 'outside', textfont: { size: 13, color: '#1e293b' },
        name: '불량률', cliponaxis: false },
      // 목표선: 굵은 주황 실선 + 끝 레이블
      { type: 'scatter', mode: 'lines',
        x: labels, y: Array(n).fill(tgt),
        line: { color: '#F97316', width: 3, dash: 'solid' },
        name: '목표 ' + tgt.toFixed(1) + '%', hoverinfo: 'skip' },
      // 추세선: 진한 남색 파선 (막대색과 완전히 다른 계열)
      { type: 'scatter', mode: 'lines+markers',
        x: labels, y: trend,
        line: { color: '#1e3a5f', width: 2.5, dash: 'dashdot' },
        marker: { color: '#1e3a5f', size: 7, symbol: 'diamond' },
        name: '추세선', hoverinfo: 'skip' }
    ], {
      margin: { t: 35, r: 68, b: 65, l: 52 },
      xaxis: { tickfont: { size: 13 }, tickangle: labels.length > 6 ? -30 : 0,
               showgrid: false },
      yaxis: { tickformat: '.2f', ticksuffix: '%', range: [yMin, yMax],
               tickfont: { size: 12 }, gridcolor: 'rgba(0,0,0,0.06)' },
      // 목표 구역 (목표 이하 = 연초록 음영)
      shapes: [{
        type: 'rect', xref: 'paper', yref: 'y',
        x0: 0, x1: 1, y0: yMin, y1: tgt,
        fillcolor: 'rgba(34,197,94,0.08)',
        line: { width: 0 }, layer: 'below'
      }],
      // 목표선 우측 라벨
      annotations: [{
        xref: 'paper', yref: 'y', x: 1.01, y: tgt,
        text: '<b>목표<br>' + tgt.toFixed(1) + '%</b>',
        showarrow: false, xanchor: 'left', yanchor: 'middle',
        font: { size: 11, color: '#F97316' },
        bgcolor: '#FFF7ED', bordercolor: '#F97316',
        borderwidth: 1, borderpad: 3
      }],
      legend: { orientation: 'h', y: -0.4, x: 0, font: { size: 12 },
                traceorder: 'normal' },
      bargap: 0.2,
      paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
      font: { size: 13 }
    }, { responsive: true, displayModeBar: false });
  }

  // ── 월별 생산 실적 차트 (전체 연도) ──
  if (mEl && allByMonth && allByMonth.length) {
    const yCnt = {};
    allByMonth.forEach(r => { const y = r.생산일자.slice(0, 4); yCnt[y] = (yCnt[y] || 0) + r.생산수량; });
    const dataYear = Object.entries(yCnt).sort((a, b) => b[1] - a[1])[0][0];
    const months = Array.from({ length: 12 }, (_, i) => i + 1);
    const getRow  = m => allByMonth.find(r => r.생산일자 === `${dataYear}-${String(m).padStart(2, '0')}`);
    const mProds  = months.map(m => { const r = getRow(m); return r ? r.생산수량 : null; });
    const mRates  = months.map(m => { const r = getRow(m); return r ? +(r.불량률 * 100).toFixed(3) : null; });

    // 추세선
    const vi = months.map((_, i) => i).filter(i => mRates[i] !== null);
    let mTrend = Array(12).fill(null);
    if (vi.length >= 2) {
      const xs = vi, ys = vi.map(i => mRates[i]);
      const mx = xs.reduce((a, b) => a + b, 0) / xs.length;
      const my = ys.reduce((a, b) => a + b, 0) / ys.length;
      const b  = xs.reduce((s, x, i) => s + (x - mx) * (ys[i] - my), 0)
               / xs.reduce((s, x) => s + (x - mx) ** 2, 0);
      const a  = my - b * mx;
      for (let i = vi[0]; i <= vi[vi.length - 1]; i++) mTrend[i] = Math.max(0, +(a + b * i).toFixed(3));
    }

    const prodMax = Math.max(...mProds.filter(v => v !== null), 1);
    const rVals   = mRates.filter(v => v !== null);
    const rMin2   = Math.min(...rVals, tgt);
    const rMax2   = Math.max(...rVals, tgt);
    const rPad    = (rMax2 - rMin2) * 0.6 || 0.3;
    const rAxisMax = rMax2 + rPad * 1.2;

    // 1~12월 전체 표시: null 인 달은 bar 없음, 선은 연결 안 함
    const mBarColors = months.map(m => mRates[m-1] !== null && mRates[m-1] > tgt ? '#EF4444' : '#22C55E');
    const rateX  = months.filter((_, i) => mRates[i] !== null);
    const trendX = months.filter((_, i) => mTrend[i] !== null);
    const mDotColors = rateX.map(m => mRates[m-1] > tgt ? '#DC2626' : '#16A34A');

    Plotly.newPlot(mEl, [
      // 생산수량 막대 (1~12월, null인 달은 자동 생략)
      { type: 'bar', x: months, y: mProds,
        marker: { color: mBarColors, line: { color: 'rgba(255,255,255,0.4)', width: 1 } },
        text: mProds.map(v => v !== null ? fmt(v) : ''),
        textposition: 'outside', textfont: { size: 12, color: '#1e293b' },
        name: '생산수량', cliponaxis: false },
      // 목표 불량률선: 1~12월 전체 수평선
      { type: 'scatter', mode: 'lines',
        x: [1, 12], y: [tgt, tgt],
        line: { color: '#F97316', width: 2.5, dash: 'dot' },
        name: '목표 ' + tgt.toFixed(1) + '%', yaxis: 'y2', hoverinfo: 'skip' },
      // 불량률선: 데이터 있는 달만 연결
      { type: 'scatter', mode: 'lines+markers+text',
        x: rateX, y: rateX.map(m => mRates[m-1]),
        line: { color: '#7C3AED', width: 3 },
        marker: { color: mDotColors, size: 11,
                  symbol: 'circle', line: { color: '#fff', width: 2 } },
        text: rateX.map(m => '<b>' + mRates[m-1].toFixed(2) + '%</b>'),
        textposition: 'top center', textfont: { size: 12 },
        name: '불량률', yaxis: 'y2' },
      // 추세선
      { type: 'scatter', mode: 'lines',
        x: trendX, y: trendX.map(m => mTrend[m-1]),
        line: { color: '#1e3a5f', dash: 'dashdot', width: 2.5 },
        name: '추세선', yaxis: 'y2', hoverinfo: 'skip' }
    ], {
      title: { text: '<b>' + dataYear + '년 실적</b>', font: { size: 14 }, x: 0.5 },
      margin: { t: 78, r: 70, b: 55, l: 58 },
      xaxis: { tickvals: months, ticktext: months.map(m => m + '월'),
               range: [0.5, 12.5],   // 1~12월 강제 표시
               tickfont: { size: 13 }, showgrid: false },
      yaxis: { tickformat: ',', range: [0, prodMax * 1.55], title: '',
               tickfont: { size: 12 }, gridcolor: 'rgba(0,0,0,0.06)' },
      yaxis2: { tickformat: '.2f', ticksuffix: '%', overlaying: 'y', side: 'right',
                range: [0, rAxisMax * 1.35], title: '', tickfont: { size: 12 },
                showgrid: false },
      legend: { orientation: 'h', y: -0.3, x: 0, font: { size: 12 } },
      bargap: 0.25,
      paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
      font: { size: 13 }
    }, { responsive: true, displayModeBar: false });
  }
}

function renderDashboard(kpi, byDate, byItem, totals, alerts, filtered) {
  // 기존 Plotly 차트 메모리 정리 (모바일 성능 개선)
  document.querySelectorAll('#dashboard .js-plotly-plot').forEach(p => {
    try { Plotly.purge(p); } catch(e) {}
  });

  $('placeholder').style.display = 'none';
  $('dashboard').style.display = '';
  window._rawFiltered = filtered || [];

  // 분석 시각 표시
  const now = new Date();
  const nowLabel = now.getFullYear()+'년 '+(now.getMonth()+1)+'월 '+now.getDate()+'일 '
    +String(now.getHours()).padStart(2,'0')+':'+String(now.getMinutes()).padStart(2,'0');
  $('lastAnalysisDate').textContent = '최근 분석: ' + nowLabel;

  // 이전 저장 데이터(구버전) 호환: 불량률/PPM이 없으면 즉시 보정
  if (!Number.isFinite(kpi.PPM)) {
    kpi.PPM = calcPPM(kpi.총불량수량, kpi.총생산수량);
  }
  byDate.forEach(r => {
    if (!Number.isFinite(r.불량률)) r.불량률 = calcDefectRate(r.불량수량, r.생산수량);
    if (!Number.isFinite(r.PPM)) r.PPM = calcPPM(r.불량수량, r.생산수량);
  });
  byItem.forEach(r => {
    if (!Number.isFinite(r.불량률)) r.불량률 = calcDefectRate(r.불량수량, r.생산수량);
    if (!Number.isFinite(r.PPM)) r.PPM = calcPPM(r.불량수량, r.생산수량);
  });

  // ── 탭1: 전체 요약 (HTML 먼저 구성 후 차트 생성) ──
  const t1 = $('tab1');
  const weekChg = calcWeekChange(filtered);
  const arrow = weekChg.변화 > 0 ? '▲' : weekChg.변화 < 0 ? '▼' : '─';
  const arrowColor = weekChg.변화 > 0 ? 'var(--danger)' : weekChg.변화 < 0 ? 'var(--success)' : 'var(--gray)';
  const chgLabel = weekChg.변화 > 0 ? '악화' : weekChg.변화 < 0 ? '개선' : '변동없음';

  // 전주 대비 생산/불량 변화 계산
  const t1Trends = analyzeTrends(byDate, filtered);
  const t1Anomalies = detectAnomalies(byDate);
  const t1RiskScores = calcItemRiskScores(byItem, filtered, aiRiskSettings);
  const t1Diagnosis = generateDiagnosisText(kpi, t1Trends, t1Anomalies, analyzeDefectTypes(byDate), t1RiskScores, byDate, targetDefectRate);
  const t1Stats = t1Diagnosis.stats;
  const t1QS = calcQualityScore(kpi, t1Trends, t1Anomalies, t1RiskScores, t1Stats, targetDefectRate);
  const t1BannerClass = t1QS.score >= 75 ? 'safe' : t1QS.score >= 45 ? 'warn' : 'danger';
  const t1BannerEmoji = t1QS.score >= 75 ? '🟢' : t1QS.score >= 45 ? '🟡' : '🔴';

  let t1Html = '';

  // [1] 품질 상태 배너
  const t1TargetOver = kpi.불량률 > targetDefectRate;
  const t1TargetBadge = t1TargetOver
    ? `<span style="display:inline-block;padding:2px 8px;border-radius:6px;font-size:11px;font-weight:700;background:#FEE2E2;color:#DC2626;margin-left:6px">목표 초과 +${(kpi.불량률 - targetDefectRate).toFixed(2)}%p</span>`
    : `<span style="display:inline-block;padding:2px 8px;border-radius:6px;font-size:11px;font-weight:700;background:#D1FAE5;color:#16A34A;margin-left:6px">목표 달성</span>`;
  t1Html += `<div class="t1-status-banner ${t1BannerClass}">
    <span class="t1-sb-score">${t1BannerEmoji} ${t1QS.letterGrade}</span>
    <div class="t1-sb-text">
      품질 종합 점수 <b>${t1QS.score}점</b> — ${t1QS.verdict}
      <div class="t1-sb-sub">불량률 ${pct(kpi.불량률)} (목표 ${targetDefectRate.toFixed(1)}%) ${t1TargetBadge} | PPM ${fmt(Math.round(kpi.PPM))} | 양품률 ${pct(kpi.총생산수량 ? kpi.총양품수량/kpi.총생산수량*100 : 100)} | ${kpi.품목수}개 품목 / ${kpi.생산일수}일간 분석</div>
    </div>
  </div>`;

  // [2] KPI 카드 (8개)
  const t1YieldRate = kpi.총생산수량 ? (kpi.총양품수량/kpi.총생산수량*100) : 100;
  const t1DailyProd = kpi.생산일수 ? Math.round(kpi.총생산수량/kpi.생산일수) : 0;
  t1Html += '<div id="kpiCards"></div>';

  // [3] 전주 비교 카드
  t1Html += '<div class="kpi-grid week-compare-grid" style="grid-template-columns:repeat(3,1fr);margin-bottom:16px">';
  t1Html += `<div class="kpi-card"><div class="value" style="color:var(--primary)">${pct(weekChg.금주)}</div><div class="label">금주 불량률</div></div>`;
  t1Html += `<div class="kpi-card"><div class="value" style="color:var(--gray)">${pct(weekChg.전주)}</div><div class="label">전주 불량률</div></div>`;
  t1Html += `<div class="kpi-card"><div class="value" style="color:${arrowColor}">${arrow} ${pct(Math.abs(weekChg.변화))}</div><div class="label">전주 대비 (${chgLabel})</div></div>`;
  t1Html += '</div>';

  // [4] 불량률 TOP 5 품목
  const t1Top5 = [...byItem].sort((a,b) => b.불량률 - a.불량률).slice(0, 5);
  const t1MaxRate = t1Top5.length ? t1Top5[0].불량률 * 100 : 1;
  t1Html += '<div class="chart-box"><h3>🔴 불량률 TOP 5 품목</h3>';
  t1Top5.forEach((r, i) => {
    const rate = r.불량률 * 100;
    const barColor = rate >= 5 ? '#DC2626' : rate >= 3 ? '#F59E0B' : '#2563EB';
    const rankColor = i === 0 ? '#DC2626' : i === 1 ? '#F59E0B' : '#6B7280';
    const barW = Math.max(rate / t1MaxRate * 100, 4);
    t1Html += `<div class="t1-top5-bar">
      <div class="t1-top5-rank" style="background:${rankColor}">${i+1}</div>
      <div class="t1-top5-name" title="${r.품명}">${r.품명}</div>
      <div class="t1-top5-barwrap"><div class="t1-top5-fill" style="width:${barW}%;background:${barColor}"></div></div>
      <div class="t1-top5-rate" style="color:${barColor}">${pct(rate)}</div>
    </div>`;
  });
  t1Html += '</div>';

  // [5] 차트 2열: 이동평균 + 도넛(또는 파레토)
  t1Html += '<div class="t1-chart-row">';
  t1Html += '<div class="chart-box"><h3>📈 불량률 추세 (이동평균)</h3><div id="chartTrendMA"></div></div>';
  if (defectCols.length) {
    t1Html += '<div class="chart-box"><h3>🍩 불량유형 비율</h3><div id="chartDefectDonut"></div></div>';
  }
  t1Html += '</div>';
  if (defectCols.length) {
    t1Html += '<div class="chart-box"><h3>📊 불량 유형 파레토 분석</h3><div id="chartPareto"></div></div>';
  }

  // [6] 최근 7일 미니 카드
  const t1Last7 = byDate.slice(-7);
  if (t1Last7.length > 1) {
    t1Html += '<div class="chart-box"><h3>📅 최근 7일 현황</h3>';
    t1Html += '<div class="t1-mini-scroll">';
    t1Last7.forEach((r, i) => {
      const rate = r.불량률 * 100;
      const barColor = rate > targetDefectRate ? '#DC2626' : '#16A34A';
      let chg = '';
      if (i > 0) {
        const prev = t1Last7[i-1].불량률 * 100;
        const diff = rate - prev;
        if (Math.abs(diff) > 0.001) {
          chg = `<div class="t1-mc-change" style="color:${diff > 0 ? '#DC2626' : '#16A34A'}">${diff > 0 ? '▲' : '▼'} ${pct(Math.abs(diff))}</div>`;
        } else {
          chg = '<div class="t1-mc-change" style="color:#6B7280">─ 변동없음</div>';
        }
      }
      t1Html += `<div class="t1-mini-card">
        <div class="t1-mc-date">${dateKR(r.생산일자)}</div>
        <div class="t1-mc-rate" style="color:${barColor}">${pct(rate)}</div>
        ${chg}
        <div class="t1-mc-detail">생산 ${fmt(r.생산수량)} / 불량 ${fmt(r.불량수량)}</div>
        <div class="t1-mc-bar" style="background:${barColor}"></div>
      </div>`;
    });
    t1Html += '</div></div>';
  }

  // [7] 핵심 인사이트 박스
  const t1Insights = [];
  // 목표 불량률 달성/초과
  if (t1TargetOver) {
    const overDays = byDate.filter(r => r.불량률 * 100 > targetDefectRate).length;
    t1Insights.push(`<span style="color:#DC2626">현재 불량률 <b>${pct(kpi.불량률)}</b>로 목표(${targetDefectRate.toFixed(1)}%)를 <b>${(kpi.불량률 - targetDefectRate).toFixed(2)}%p 초과</b>하고 있습니다. (${overDays}/${byDate.length}일 초과)</span>`);
  } else {
    t1Insights.push(`<span style="color:#16A34A">현재 불량률 <b>${pct(kpi.불량률)}</b>로 목표(${targetDefectRate.toFixed(1)}%)를 <b>달성</b>하고 있습니다.</span>`);
  }
  // 전주 대비
  if (weekChg.변화 !== 0) {
    t1Insights.push(`최근 7일 불량률이 전주 대비 <b style="color:${weekChg.변화>0?'#DC2626':'#16A34A'}">${pct(Math.abs(weekChg.변화))} ${weekChg.변화>0?'악화':'개선'}</b>되었습니다.`);
  }
  // TOP 불량 품목
  if (t1Top5.length > 0) {
    t1Insights.push(`불량이 가장 많은 품목은 <b>${t1Top5[0].품명}</b> (불량률 ${pct(t1Top5[0].불량률*100)})입니다.`);
  }
  // 주요 불량유형
  if (totals.length > 0) {
    const topDefect = totals[0];
    const totalBad = totals.reduce((s,t)=>s+t.건수,0) || 1;
    t1Insights.push(`주요 불량유형은 <b>${topDefect.불량유형}</b>으로 전체의 <b>${(topDefect.건수/totalBad*100).toFixed(1)}%</b>를 차지합니다.`);
  }
  // 연속 추세
  if (t1Trends.consecutiveWorsen >= 3) {
    t1Insights.push(`<span style="color:#DC2626"><b>${t1Trends.consecutiveWorsen}일 연속</b> 불량률이 상승 중입니다. 원인 파악이 필요합니다.</span>`);
  } else if (t1Trends.consecutiveImprove >= 3) {
    t1Insights.push(`<span style="color:#16A34A"><b>${t1Trends.consecutiveImprove}일 연속</b> 불량률이 개선되고 있습니다.</span>`);
  }
  // 양품률
  t1Insights.push(`전체 양품률은 <b>${pct(t1YieldRate)}</b>이며, 일평균 <b>${fmt(t1DailyProd)}개</b>를 생산하고 있습니다.`);

  if (t1Insights.length) {
    t1Html += '<div class="chart-box"><h3>💡 핵심 인사이트</h3>';
    t1Html += '<div class="t1-insight-box">';
    t1Insights.forEach(ins => { t1Html += `<div class="t1-ins-item">${ins}</div>`; });
    t1Html += '</div></div>';
  }

  t1.innerHTML = t1Html;

  // KPI 카드 렌더링 (양품률, 일평균생산 추가)
  const t1KpiEl = $('kpiCards');
  t1KpiEl.innerHTML = '';
  const t1DailyBad = kpi.생산일수 ? Math.round(kpi.총불량수량 / kpi.생산일수) : 0;
  const t1OverDays = byDate.filter(r => r.불량률 * 100 > targetDefectRate).length;
  const t1CardGroups = [
    {
      title: '생산 지표',
      cards: [
        { label:'총 생산수량', value: fmt(kpi.총생산수량), color:'var(--primary)' },
        { label:'총 양품수량', value: fmt(kpi.총양품수량), color:'var(--success)' },
        { label:'총 불량수량', value: fmt(kpi.총불량수량), color:'var(--danger)' },
      ]
    },
    {
      title: '품질 지표',
      cards: [
        { label:'불량률', value: pct(kpi.불량률), color: t1TargetOver ? 'var(--danger)' : 'var(--warning)' },
        { label:'PPM', value: fmt(Math.round(kpi.PPM)), color: t1TargetOver ? 'var(--danger)' : 'var(--warning)' },
        { label:'양품률', value: pct(t1YieldRate), color:'var(--success)' },
      ]
    },
    {
      title: '목표/관리 지표',
      cards: [
        { label:'목표 불량률', value: targetDefectRate.toFixed(1) + '%', color: t1TargetOver ? 'var(--danger)' : 'var(--success)', sub: t1TargetOver ? '초과' : '달성' },
        { label:'목표 초과 일수', value: t1OverDays + '/' + byDate.length + '일', color: t1OverDays > 0 ? 'var(--danger)' : 'var(--success)' },
        { label:'시그마 수준', value: t1Stats.sigmaLevel.toFixed(1) + 'σ', color:'var(--primary)' },
      ]
    },
    {
      title: '운영 지표',
      cards: [
        { label:'일평균 생산', value: fmt(t1DailyProd) + '개', color:'var(--primary)' },
        { label:'일평균 불량', value: fmt(t1DailyBad) + '개', color:'var(--danger)' },
      ]
    },
    {
      title: '기준 정보',
      cards: [
        { label:'품목수', value: kpi.품목수 + '개', color:'var(--gray)' },
        { label:'생산일수', value: kpi.생산일수 + '일', color:'var(--gray)' },
      ]
    },
  ];
  const t1Groups = document.createElement('div');
  t1Groups.className = 't1-kpi-groups';
  for (const group of t1CardGroups) {
    const groupWrap = document.createElement('div');
    groupWrap.className = 't1-kpi-group';
    groupWrap.innerHTML = `<div class="t1-kpi-group-title">${group.title}</div>`;
    const row = document.createElement('div');
    row.className = 'kpi-grid' + (group.cards.length === 2 ? ' kpi-grid-2' : '');
    for (const c of group.cards) {
      row.innerHTML += `<div class="kpi-card"><div class="value" style="color:${c.color}">${c.value}</div><div class="label">${c.label}${c.sub ? ' <span style="font-size:10px;font-weight:700;color:'+c.color+'">(' + c.sub + ')</span>' : ''}</div></div>`;
    }
    groupWrap.appendChild(row);
    t1Groups.appendChild(groupWrap);
  }
  t1KpiEl.appendChild(t1Groups);

  // 차트 렌더링
  chartTrendMA(byDate, $('chartTrendMA'));
  if (defectCols.length) {
    chartPareto(totals, $('chartPareto'));
    // 도넛 차트
    const donutEl = $('chartDefectDonut');
    if (donutEl && totals.length) {
      const top5d = totals.slice(0, 5);
      const otherSum = totals.slice(5).reduce((s,t)=>s+t.건수,0);
      const labels = top5d.map(t=>t.불량유형);
      const values = top5d.map(t=>t.건수);
      if (otherSum > 0) { labels.push('기타'); values.push(otherSum); }
      Plotly.newPlot(donutEl, [{
        labels, values, type: 'pie', hole: 0.5,
        textinfo: 'label+percent', textposition: 'outside',
        textfont: { size: isMobile() ? 9 : 11 },
        marker: { colors: ['#DC2626','#F59E0B','#2563EB','#8B5CF6','#16A34A','#6B7280'] }
      }], {
        showlegend: false,
        height: chartHeight(350, 280),
        margin: isMobile() ? {t:10,b:10,l:10,r:10} : {t:20,b:20,l:20,r:20},
        annotations: [{ text: fmt(values.reduce((a,b)=>a+b,0)) + '건', x:0.5, y:0.5, font:{size: isMobile() ? 14 : 18, weight:800}, showarrow:false }]
      }, getPlotCfg());
    }
  }

  // ── 탭2: 일자별 분석 (HTML 먼저 구성 후 차트 생성) ──
  const t2 = $('tab2');
  const byWeek = (filtered && filtered.length) ? aggByWeek(filtered) : [];
  const byMonth = (filtered && filtered.length) ? aggByMonth(filtered) : [];
  const dateHeaders = ['생산일자','생산수량','양품수량','불량수량',...defectCols,'불량률','PPM'];
  let t2Html = makeTabSubFilterHtml('t2', 'applyT2SubFilter', 'resetT2SubFilter')
    + `<div class="chart-box">
    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:4px">
      <h3 id="titleDailyTrend" style="margin:0">일별 생산수량 및 불량률 추이</h3>
      <div style="display:flex;gap:6px">
        <button class="btn btn-sm btn-primary" id="btnTrendDaily" onclick="switchTrendPeriod('daily')">일별</button>
        <button class="btn btn-sm" id="btnTrendWeekly" onclick="switchTrendPeriod('weekly')" style="background:var(--gray);color:#fff">주별</button>
        <button class="btn btn-sm" id="btnTrendMonthly" onclick="switchTrendPeriod('monthly')" style="background:var(--gray);color:#fff">월별</button>
      </div>
    </div>
    <div id="chartDailyTrend"></div>
  </div>`;
  if (defectCols.length) {
    t2Html += `<div class="chart-box">
      <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:4px">
        <h3 id="titleDailyStack" style="margin:0">일별 불량유형 구성</h3>
        <div style="display:flex;gap:6px">
          <button class="btn btn-sm btn-primary" id="btnStackDaily" onclick="switchStackPeriod('daily')">일별</button>
          <button class="btn btn-sm" id="btnStackWeekly" onclick="switchStackPeriod('weekly')" style="background:var(--gray);color:#fff">주별</button>
          <button class="btn btn-sm" id="btnStackMonthly" onclick="switchStackPeriod('monthly')" style="background:var(--gray);color:#fff">월별</button>
        </div>
      </div>
      <div id="chartDailyStack"></div>
    </div>`;
  }
  // 요일별 패턴 + 생산량 vs 불량률 산점도
  t2Html += '<div class="chart-box"><h3>📊 요일별 평균 불량률 패턴</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:4px">어떤 요일에 불량이 많은지 패턴을 확인하세요</p><div class="weekday-chart-box"><div id="chartWeekday"></div><div id="chartProdVsDefect"></div></div></div>';
  t2Html += `<div class="chart-box"><h3>집계 단위 변환</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:8px">일별/주별/월별 불량률과 PPM을 함께 비교합니다</p>
    <div style="display:flex;gap:8px;margin-bottom:12px">
      <button class="btn btn-sm btn-primary" id="btnAggDaily" onclick="showAggTable('daily')">일별</button>
      <button class="btn btn-sm" id="btnAggWeekly" onclick="showAggTable('weekly')" style="background:var(--gray);color:#fff">주간</button>
      <button class="btn btn-sm" id="btnAggMonthly" onclick="showAggTable('monthly')" style="background:var(--gray);color:#fff">월간</button>
    </div>
    <div id="aggTableArea"></div></div>`;
  t2.innerHTML = t2Html;
  chartDailyTrend(byDate, $('chartDailyTrend'));
  if (defectCols.length) chartDailyStack(byDate, $('chartDailyStack'));
  chartWeekdayPattern(byDate, $('chartWeekday'));
  chartWeekdayScatter(byDate, $('chartProdVsDefect'));
  window._aggData = {daily:byDate, weekly:byWeek, monthly:byMonth, headers:dateHeaders};
  $('aggTableArea').innerHTML = makeTableEnhanced(dateHeaders, byDate, 'tblDate');
  initSubFilterDates('t2');
  window.showAggTable = function(mode) {
    window._t2AggMode = mode;
    const d = window._aggData;
    $('aggTableArea').innerHTML = makeTableEnhanced(d.headers, d[mode], 'tblDate');
    ['Daily','Weekly','Monthly'].forEach(m => {
      const btn = $('btnAgg' + m);
      if (!btn) return;
      if (mode === m.toLowerCase()) { btn.className='btn btn-sm btn-primary'; btn.style.background=''; btn.style.color=''; }
      else { btn.className='btn btn-sm'; btn.style.background='var(--gray)'; btn.style.color='#fff'; }
    });
  };

  // ── 기간 단위 전환 공통 헬퍼 ──
  function periodLabels(data, mode) {
    return data.map(r =>
      mode === 'daily'   ? dateKR(r.생산일자) :
      mode === 'weekly'  ? r.생산일자 :
      dateKRMonth(r.생산일자)
    );
  }
  function setPeriodBtns(prefix, mode) {
    ['Daily','Weekly','Monthly'].forEach(m => {
      const btn = $('btn' + prefix + m);
      if (!btn) return;
      if (mode === m.toLowerCase()) { btn.className='btn btn-sm btn-primary'; btn.style.background=''; btn.style.color=''; }
      else { btn.className='btn btn-sm'; btn.style.background='var(--gray)'; btn.style.color='#fff'; }
    });
  }
  const periodTitles = { daily:'일별', weekly:'주별', monthly:'월별' };

  window.switchTrendPeriod = function(mode) {
    window._t2TrendMode = mode;
    const d = window._aggData;
    if (!d || !d[mode] || !d[mode].length) return;
    const data = d[mode];
    const labels = periodLabels(data, mode);
    const mb = isMobile();
    setPeriodBtns('Trend', mode);
    $('titleDailyTrend').textContent = periodTitles[mode] + ' 생산수량 및 불량률 추이';
    Plotly.react($('chartDailyTrend'), [
      { x:labels, y:data.map(r=>r.생산수량), type:'bar', name:'생산수량',
        marker:{color:'#2563EB',opacity:.75}, yaxis:'y' },
      { x:labels, y:data.map(r=>r.불량률*100), type:'scatter',
        mode:'lines+markers'+(mb?'':'+text'), name:'불량률(%)',
        line:{color:'#DC2626',width:2.5}, marker:{size:mb?6:8},
        text:data.map(r=>pct(r.불량률*100)), textposition:'top center',
        textfont:{size:mb?8:10,color:'#DC2626'}, yaxis:'y2' },
      { x:[labels[0],labels[labels.length-1]], y:[targetDefectRate,targetDefectRate],
        type:'scatter', mode:'lines',
        name:'목표 불량률('+targetDefectRate.toFixed(1)+'%)',
        line:{color:'#16A34A',width:1.5,dash:'dash'}, yaxis:'y2' }
    ], {
      yaxis:{title:mb?'':'생산수량'},
      yaxis2:{title:mb?'':'불량률 (%)',overlaying:'y',side:'right'},
      legend:{orientation:'h',y:mb?1.15:1.12,font:{size:mb?10:12}},
      height:chartHeight(420,300), margin:mb?{t:30,b:40,l:40,r:40}:{t:30,b:50,l:60,r:60}
    }, getPlotCfg());
  };

  window.switchStackPeriod = function(mode) {
    const d = window._aggData;
    if (!d || !d[mode] || !d[mode].length || !defectCols.length) return;
    const data = d[mode];
    const labels = periodLabels(data, mode);
    const mb = isMobile();
    setPeriodBtns('Stack', mode);
    $('titleDailyStack').textContent = periodTitles[mode] + ' 불량유형 구성';
    const active = defectCols.filter(dc => data.some(r => r[dc] > 0));
    Plotly.react($('chartDailyStack'),
      active.map((dc,i) => ({
        x:labels, y:data.map(r=>r[dc]||0), type:'bar', name:dc,
        marker:{color:PALETTE[i%PALETTE.length]}
      })),
      { barmode:'stack',
        xaxis:{title:mb?'':'생산일자'}, yaxis:{title:mb?'':'불량 건수'},
        legend:{orientation:'h',y:mb?1.2:1.12,font:{size:mb?9:12}},
        height:chartHeight(420,300), margin:mb?{t:30,b:40,l:35,r:10}:{t:30,b:50,l:60,r:40}
      }, getPlotCfg());
  };

  window.applyT2SubFilter = function() {
    const start = $('t2SubStart').value, end = $('t2SubEnd').value;
    if (!start || !end) return;
    const sub = (window._rawFiltered || []).filter(r => { const d = dateStr(r.생산일자); return d >= start && d <= end; });
    if (!sub.length) { showToast('해당 기간 데이터가 없습니다.', 'warn', 3000); return; }
    const bd = aggByDate(sub), bw = aggByWeek(sub), bm = aggByMonth(sub);
    window._aggData = { ...window._aggData, daily: bd, weekly: bw, monthly: bm };
    const mode = window._t2TrendMode || 'daily';
    switchTrendPeriod(mode);
    if (defectCols.length) switchStackPeriod(mode);
    chartWeekdayPattern(bd, $('chartWeekday'));
    chartWeekdayScatter(bd, $('chartProdVsDefect'));
    showAggTable(window._t2AggMode || 'daily');
    setSubFilterInfo('t2', sub);
  };
  window.resetT2SubFilter = function() {
    initSubFilterDates('t2');
    applyT2SubFilter();
    const el = $('t2SubInfo'); if (el) el.textContent = '';
  };

  window.switchYieldPeriod = function(mode) {
    window._t6YieldMode = mode;
    const d = window._t6Data || window._aggData;
    if (!d || !d[mode] || !d[mode].length) return;
    const data = d[mode];
    const labels = periodLabels(data, mode);
    const mb = isMobile();
    setPeriodBtns('Yield', mode);
    $('titleYieldTrend').textContent = periodTitles[mode] + ' 수율 추이';
    const yields = data.map(r => r.생산수량 ? r.양품수량/r.생산수량*100 : 0);
    const yieldMin = yields.length ? Math.min(...yields) : 0;
    const targetYield = 100 - targetDefectRate;
    Plotly.react($('chartYieldTrend'), [
      { x:labels, y:yields, type:'scatter', mode:'lines+markers',
        name:periodTitles[mode]+' 수율', line:{color:'#16A34A',width:2}, marker:{size:mb?4:6} },
      { x:[labels[0],labels[labels.length-1]], y:[98,98], type:'scatter', mode:'lines',
        name:'목표 98%', line:{color:'#DC2626',width:2,dash:'dash'} },
      { x:[labels[0],labels[labels.length-1]], y:[targetYield,targetYield], type:'scatter', mode:'lines',
        name:'목표 수율('+targetYield.toFixed(1)+'%)',
        line:{color:'#16A34A',width:1.5,dash:'dash'} }
    ], {
      yaxis:{title:mb?'':'수율 (%)',range:[Math.max(0,Math.min(yieldMin,targetYield)-3),101]},
      legend:{orientation:'h',y:mb?1.15:1.12,font:{size:mb?10:12}},
      height:chartHeight(380,280), margin:mb?{t:30,b:40,l:40,r:20}:{t:30,b:50,l:60,r:40}
    }, getPlotCfg());
  };

  // ── 탭3: 품목별 분석 ── (HTML을 먼저 한번에 구성 후 차트 생성)
  const t3 = $('tab3');
  const itemHeaders = ['품명','생산수량','양품수량','불량수량','불량률','PPM'];
  // 품목별 추세 배지 (전반부 vs 후반부 비교)
  const t3Top = [...byItem].sort((a,b) => b.불량률 - a.불량률).slice(0, 15);
  let t3TrendHtml = '<div class="chart-box"><h3>📈 품목별 추세 방향 (불량률 TOP 15)</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:8px">전반부 vs 후반부 불량률 비교. ▲악화(+0.5%p 이상), ▼개선(-0.5%p 이상), ─안정</p>';
  t3TrendHtml += '<div style="display:flex;flex-wrap:wrap;gap:8px">';
  t3Top.forEach(r => {
    const badge = getItemTrendBadge(r.품명, filtered);
    const shortName = r.품명.length > 20 ? r.품명.slice(0,20) + '...' : r.품명;
    t3TrendHtml += `<div style="background:var(--white);border:1px solid var(--border);border-radius:8px;padding:8px 12px;min-width:180px;flex:1;max-width:280px">
      <div style="font-weight:600;font-size:13px;margin-bottom:2px">${shortName}</div>
      <div style="font-size:12px;color:var(--text-light)">불량률 ${pct(r.불량률*100,1)}</div>
      <span class="trend-badge ${badge.cls}">${badge.text}</span>
    </div>`;
  });
  t3TrendHtml += '</div></div>';
  let t3Html = t3TrendHtml;
  t3Html += '<div class="chart-box"><h3>품목별 불량률 TOP 15</h3><div id="chartTop15"></div></div>';
  if (defectCols.length) {
    t3Html += '<div class="chart-box"><h3>품목 x 불량유형 히트맵 (색상: 불량률 / 셀: 건수+비율)</h3><div id="chartHeatmap"></div></div>';
  }
  t3Html += '<div class="chart-box"><h3>생산수량 vs 불량률 (4사분면 분석)</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:4px">버블 크기 = 불량수량 / 점선 = 중앙값 기준선 / X축: 로그 스케일</p><div id="chartScatter"></div></div>';
  t3Html += '<div class="chart-box"><h3>날짜별 누적 버블 애니메이션</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:4px">재생 버튼을 누르면 날짜가 흐르며 품목별 생산/불량이 누적됩니다</p><div id="chartScatterAnim"></div></div>';
  t3Html += '<div class="chart-box"><h3>품목별 집계 데이터</h3>' + makeTableEnhanced(itemHeaders, byItem, 'tblItem') + '</div>';
  t3.innerHTML = t3Html;

  // HTML 구성 완료 후 차트 생성
  chartItemTop15(byItem, $('chartTop15'));
  if (defectCols.length) chartHeatmap(byItem, $('chartHeatmap'));
  chartScatter(byItem, $('chartScatter'));
  if (filtered && filtered.length) {
    chartScatterAnimated(filtered, byDate, $('chartScatterAnim'));
  } else {
    $('chartScatterAnim').innerHTML = '<div class="info-box warn">애니메이션은 새로 분석할 때 사용 가능합니다. (이전 저장 데이터에서는 지원되지 않음)</div>';
  }

  // ── 탭4: 알림 & 리포트 ──
  const t4 = $('tab4');

  // 자동 요약 텍스트 (상단 배치)
  const summaryText = `분석 기간 ${byDate.length > 0 ? dateKRFull(byDate[0].생산일자) + ' ~ ' + dateKRFull(byDate[byDate.length-1].생산일자) : ''} 기준, 총 생산수량 ${fmt(kpi.총생산수량)}개 중 불량 ${fmt(kpi.총불량수량)}개 (불량률 ${pct(kpi.불량률)}, PPM ${fmt(Math.round(kpi.PPM))})가 발생하였습니다.${weekChg.변화 !== 0 ? ' 전주 대비 불량률이 ' + pct(Math.abs(weekChg.변화)) + (weekChg.변화 > 0 ? ' 악화' : ' 개선') + '되었습니다.' : ''}${alerts.length > 0 ? ' 목표 불량률 ' + targetDefectRate.toFixed(1) + '% 초과 품목은 ' + alerts.length + '건입니다.' : ''}`;
  let alertHtml = `<div class="chart-box"><h3>자동 요약</h3><div class="info-box info" style="line-height:1.6">${summaryText}</div></div>`;

  alertHtml += `<div class="chart-box"><h3>목표 불량률 ${targetDefectRate.toFixed(1)}% 초과 품목</h3>`;
  if (!alerts.length) {
    alertHtml += `<div class="info-box success">목표 불량률 ${targetDefectRate.toFixed(1)}%를 초과하는 품목이 없습니다.</div>`;
  } else {
    alertHtml += `<div class="info-box warn" style="margin-bottom:12px">초과 품목: ${alerts.length}건</div>`;
    const alertHeaders = ['품명','생산수량','양품수량','불량수량','불량률'];
    alertHtml += makeTableEnhanced(alertHeaders, alerts, 'tblAlerts');
  }
  alertHtml += '</div>';

  alertHtml += `<div class="chart-box"><h3>리포트 다운로드</h3>
    <div class="export-bar">
      <button class="btn btn-success" id="btnExportExcel" style="flex:1;min-width:150px">
        Excel 리포트 다운로드
      </button>
      <button class="btn btn-danger" id="btnExportPDF" style="flex:1;min-width:150px">
        PDF 리포트 다운로드
      </button>
    </div>
  </div>`;

  t4.innerHTML = alertHtml;

  if ($('btnExportExcel')) $('btnExportExcel').addEventListener('click', () => {
    exportExcel(kpi, byDate, byItem, totals);
  });
  if ($('btnExportPDF')) $('btnExportPDF').addEventListener('click', openPdfModal);

  // ── 탭5: p 관리도 (HTML 먼저 구성) ──
  const t5 = $('tab5');

  let t5Html = makeTabSubFilterHtml('t5', 'applyT5SubFilter', 'resetT5SubFilter')
    + `<div class="chart-box">
    <h3>p 관리도 (불량률 관리)</h3>
    <p style="font-size:12px;color:var(--text-light);margin-bottom:4px">
      <span style="color:#DC2626;font-weight:700">● 빨간점</span> 관리한계 이탈 &nbsp;|&nbsp;
      <span style="color:#F59E0B;font-weight:700">● 노란점</span> 연속 규칙 위반 &nbsp;|&nbsp;
      <span style="color:#2563EB;font-weight:700">● 파란점</span> 정상
    </p>
    <p style="font-size:11px;color:var(--text-light);margin-bottom:8px">
      UCLᵢ = p̄ + 3√(p̄(1−p̄)/nᵢ) &nbsp; LCLᵢ = p̄ − 3√(p̄(1−p̄)/nᵢ) &nbsp; ※ 검사수(nᵢ)에 따라 관리한계 변동
    </p>
    <div id="chartSPC"></div>
  </div>`;
  t5Html += `<div class="chart-box"><h3>p 관리도 요약</h3><div id="spcKpiArea"></div></div>`;
  t5.innerHTML = t5Html;
  chartSPC(byDate, $('chartSPC'));
  $('spcKpiArea').innerHTML = buildSPCKpiHtml(byDate);
  initSubFilterDates('t5');
  window.applyT5SubFilter = function() {
    const start = $('t5SubStart').value, end = $('t5SubEnd').value;
    if (!start || !end) return;
    const sub = (window._rawFiltered || []).filter(r => { const d = dateStr(r.생산일자); return d >= start && d <= end; });
    if (!sub.length) { showToast('해당 기간 데이터가 없습니다.', 'warn', 3000); return; }
    const bd = aggByDate(sub);
    chartSPC(bd, $('chartSPC'));
    $('spcKpiArea').innerHTML = buildSPCKpiHtml(bd);
    setSubFilterInfo('t5', sub);
  };
  window.resetT5SubFilter = function() {
    initSubFilterDates('t5');
    applyT5SubFilter();
    const el = $('t5SubInfo'); if (el) el.textContent = '';
  };

  // ── 탭6: 수율 분석 (HTML 먼저 구성) ──
  const t6 = $('tab6');
  t6.innerHTML = makeTabSubFilterHtml('t6', 'applyT6SubFilter', 'resetT6SubFilter')
    + '<div class="chart-box"><h3>🎯 수율 목표 달성 현황 (목표: 98%)</h3><div id="yieldTargetArea"></div></div>'
    + '<div class="chart-box"><h3>전체 수율 (양품률)</h3><div id="chartYieldGauge"></div></div>'
    + '<div class="chart-box"><h3>📊 수율 구간별 품목 분포</h3><p style="font-size:11px;color:var(--text-light);margin-top:-8px;margin-bottom:4px">품목들의 수율이 어떤 구간에 분포하는지 확인하세요</p><div id="chartYieldDist"></div></div>'
    + `<div class="chart-box">
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px;margin-bottom:4px">
          <h3 id="titleYieldTrend" style="margin:0">일별 수율 추이</h3>
          <div style="display:flex;gap:6px">
            <button class="btn btn-sm btn-primary" id="btnYieldDaily" onclick="switchYieldPeriod('daily')">일별</button>
            <button class="btn btn-sm" id="btnYieldWeekly" onclick="switchYieldPeriod('weekly')" style="background:var(--gray);color:#fff">주별</button>
            <button class="btn btn-sm" id="btnYieldMonthly" onclick="switchYieldPeriod('monthly')" style="background:var(--gray);color:#fff">월별</button>
          </div>
        </div>
        <div id="chartYieldTrend"></div>
      </div>`
    + '<div class="chart-box"><h3>품목별 수율 하위 20 (목표선: 98%)</h3><div id="chartYieldItem"></div></div>';
  renderYieldTarget(byItem, kpi, $('yieldTargetArea'));
  chartYieldGauge(kpi, $('chartYieldGauge'));
  chartYieldDistribution(byItem, $('chartYieldDist'));
  chartYieldTrend(byDate, $('chartYieldTrend'));
  chartYieldByItem(byItem, $('chartYieldItem'));
  window._t6Data = { daily: byDate, weekly: byWeek, monthly: byMonth, headers: dateHeaders };
  initSubFilterDates('t6');
  window.applyT6SubFilter = function() {
    const start = $('t6SubStart').value, end = $('t6SubEnd').value;
    if (!start || !end) return;
    const sub = (window._rawFiltered || []).filter(r => { const d = dateStr(r.생산일자); return d >= start && d <= end; });
    if (!sub.length) { showToast('해당 기간 데이터가 없습니다.', 'warn', 3000); return; }
    const bd = aggByDate(sub), bw = aggByWeek(sub), bm = aggByMonth(sub), bi = aggByItem(sub);
    const kpiSub = calcKPI(sub);
    window._t6Data = { ...window._t6Data, daily: bd, weekly: bw, monthly: bm };
    renderYieldTarget(bi, kpiSub, $('yieldTargetArea'));
    chartYieldGauge(kpiSub, $('chartYieldGauge'));
    chartYieldDistribution(bi, $('chartYieldDist'));
    switchYieldPeriod(window._t6YieldMode || 'daily');
    chartYieldByItem(bi, $('chartYieldItem'));
    setSubFilterInfo('t6', sub);
  };
  window.resetT6SubFilter = function() {
    initSubFilterDates('t6');
    applyT6SubFilter();
    const el = $('t6SubInfo'); if (el) el.textContent = '';
  };

  // ── 주별/월별 버튼: 데이터 부족 시 비활성화 ──
  [['btnTrendWeekly','btnTrendMonthly'],
   ['btnStackWeekly','btnStackMonthly'],
   ['btnYieldWeekly','btnYieldMonthly']].forEach(([bwId, bmId]) => {
    const bw = $(bwId), bm = $(bmId);
    if (bw && byWeek.length <= 1)  { bw.disabled=true; bw.style.opacity='0.4'; bw.title='2주 이상 데이터 필요'; }
    if (bm && byMonth.length <= 1) { bm.disabled=true; bm.style.opacity='0.4'; bm.title='2개월 이상 데이터 필요'; }
  });

  // ── 탭7: 기간 비교 ──
  renderPeriodComparison(filtered, $('tab7'));

  // ── 탭8: 품목 심층분석 ──
  renderDrilldown(filtered, byItem, $('tab8'));

  // ── 탭9: AI 품질진단 ──
  renderAIDiagnosis(kpi, byDate, byItem, filtered);

  // ── 탭11: 주간 보고 ──
  const t11 = $('tab11');
  t11.innerHTML = `
    <div class="chart-box" style="padding:24px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px">
        <h3 style="margin:0">주간 품질 경영 보고서</h3>
        <button class="btn btn-sm btn-primary" onclick="refreshWeeklyReport()">새로고침</button>
      </div>
      <div id="weekBtnContainer">${buildWeekBtnsHtml(byWeek, '전체')}</div>
      <div id="weeklyReportArea">${generateWeeklyReport(kpi, byDate, byItem, byWeek)}</div>
    </div>`;
  window._weeklyReportData = {kpi, byDate, byItem, byWeek, byMonth};
  window._selectedWeek = '전체';
  requestAnimationFrame(() => renderWeeklyCharts(byWeek, byMonth, '전체'));

  // 차트 리사이즈 (초기 렌더 후 + 모바일 지연 대응)
  requestAnimationFrame(() => {
    window.dispatchEvent(new Event('resize'));
    // 모바일에서 추가 지연 리사이즈 (브라우저 레이아웃 완료 대기)
    if (isMobile()) {
      setTimeout(() => {
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
          activeTab.querySelectorAll('.js-plotly-plot').forEach(p => {
            try { Plotly.Plots.resize(p); } catch(e) {}
          });
        }
      }, 500);
    }
  });
}

/* ================================================================
   화면 리사이즈 시 차트 재조정
   ================================================================ */
/* ================================================================
   PDF 리포트 내보내기
   ================================================================ */
/* ── PDF 내보내기 ── */
const _PDF_TABS = [
  { id:'tab1',  icon:'📊', name:'전체 요약' },
  { id:'tab2',  icon:'📅', name:'일자별 분석' },
  { id:'tab3',  icon:'📦', name:'품목별 분석' },
  { id:'tab4',  icon:'🔔', name:'알림 & 리포트' },
  { id:'tab5',  icon:'📈', name:'SPC 관리도' },
  { id:'tab6',  icon:'✅', name:'수율 분석' },
  { id:'tab7',  icon:'🔄', name:'기간 비교' },
  { id:'tab8',  icon:'🔍', name:'품목 심층분석' },
  { id:'tab9',  icon:'🤖', name:'AI 품질진단' },
  { id:'tab11', icon:'📋', name:'주간 보고' },
];

function openPdfModal() {
  if (!window._rawFiltered || !window._rawFiltered.length) {
    showToast('먼저 데이터를 업로드하고 분석을 실행해주세요.', 'warn', 3000); return;
  }
  const list = $('pdfTabList');
  list.innerHTML = _PDF_TABS.map(t =>
    `<label style="display:flex;align-items:center;gap:8px;padding:9px 12px;border:1px solid #e5e7eb;border-radius:8px;cursor:pointer;font-size:13px;font-weight:600;transition:background .15s" onmouseenter="this.style.background='#f1f5f9'" onmouseleave="this.style.background='#fff'">
      <input type="checkbox" id="pdfChk_${t.id}" checked style="width:15px;height:15px;cursor:pointer">
      ${t.icon} ${t.name}
    </label>`
  ).join('');
  $('pdfExportProgress').style.display = 'none';
  $('btnStartPdfExport').disabled = false;
  $('btnStartPdfExport').textContent = '📥 내보내기';
  $('pdfExportModal').style.display = 'flex';
}

async function startPdfExport() {
  const selected = _PDF_TABS.filter(t => document.getElementById('pdfChk_' + t.id)?.checked);
  if (!selected.length) { showToast('탭을 1개 이상 선택하세요.', 'warn', 2000); return; }

  const origTabId = document.querySelector('.tab-content.active')?.id || 'tab1';
  const progWrap  = $('pdfExportProgress');
  const progBar   = $('pdfProgressBar');
  const progText  = $('pdfProgressText');
  const startBtn  = $('btnStartPdfExport');

  progWrap.style.display = 'block';
  startBtn.disabled = true;
  startBtn.textContent = '생성 중...';

  const isDark = document.body.classList.contains('dark');
  const BG     = isDark ? '#111827' : '#ffffff';
  const MARGIN = 10;          // mm
  const PW     = 190;         // A4 printable width mm  (210 - 2×10)
  const PH     = 272;         // A4 printable height mm (297 - 2×12.5)

  try {
    const { jsPDF } = window.jspdf;
    const pdf  = new jsPDF('p', 'mm', 'a4');
    let first  = true;

    for (let i = 0; i < selected.length; i++) {
      const tab = selected[i];
      const pct = Math.round(i / selected.length * 100);
      progBar.style.width  = pct + '%';
      progText.textContent = `(${i + 1}/${selected.length}) ${tab.icon} ${tab.name} 처리 중...`;

      // 탭 전환 후 차트 안정화 대기
      switchTab(tab.id);
      await new Promise(r => setTimeout(r, 700));
      const tabEl = $(tab.id);
      tabEl.querySelectorAll('.js-plotly-plot').forEach(p => { try { Plotly.Plots.resize(p); } catch(e) {} });
      await new Promise(r => setTimeout(r, 500));

      // 캡처 (scale:2 → 고해상도)
      const canvas = await html2canvas(tabEl, {
        scale: 2, useCORS: true, backgroundColor: BG,
        logging: false, allowTaint: true
      });

      // 자동 배율: 가로를 A4 폭에 맞추고, 필요하면 여러 페이지로 분할
      const mmPerPx = PW / canvas.width;   // mm per canvas pixel
      const imgH_mm = canvas.height * mmPerPx;

      if (!first) pdf.addPage();
      first = false;

      // 탭 헤더
      pdf.setFontSize(10);
      pdf.setTextColor(80, 80, 80);
      pdf.text(`남도금속 품질경영 · ${tab.icon} ${tab.name}`, MARGIN, MARGIN - 1);
      pdf.setDrawColor(180, 180, 180);
      pdf.line(MARGIN, MARGIN + 0.5, 200, MARGIN + 0.5);

      const contentTop = MARGIN + 4;
      const pageContentH = PH - 4;   // 헤더 공간 제외

      if (imgH_mm <= pageContentH) {
        // 한 페이지에 들어가는 경우: 배율 그대로
        pdf.addImage(canvas.toDataURL('image/jpeg', 0.92), 'JPEG',
          MARGIN, contentTop, PW, imgH_mm);
      } else {
        // 콘텐츠가 넘치는 경우: 세로를 잘라 여러 페이지에 분배
        const pageHeightPx = Math.floor(pageContentH / mmPerPx);
        let sliceY = 0;
        let pageNum = 0;
        while (sliceY < canvas.height) {
          if (pageNum > 0) {
            pdf.addPage();
            pdf.setFontSize(9);
            pdf.setTextColor(150, 150, 150);
            pdf.text(`${tab.name} (${pageNum + 1}페이지)`, MARGIN, MARGIN - 1);
          }
          const sliceH = Math.min(pageHeightPx, canvas.height - sliceY);
          const slice  = document.createElement('canvas');
          slice.width  = canvas.width;
          slice.height = sliceH;
          slice.getContext('2d').drawImage(canvas,
            0, sliceY, canvas.width, sliceH,
            0, 0,      canvas.width, sliceH);
          const sliceH_mm = sliceH * mmPerPx;
          pdf.addImage(slice.toDataURL('image/jpeg', 0.92), 'JPEG',
            MARGIN, pageNum === 0 ? contentTop : MARGIN,
            PW, sliceH_mm);
          sliceY  += pageHeightPx;
          pageNum++;
        }
      }
    }

    // 원래 탭으로 복귀
    switchTab(origTabId);

    const now = new Date();
    const ds  = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}`;
    pdf.save(`남도금속_품질경영_${ds}.pdf`);

    progBar.style.width  = '100%';
    progText.textContent = '✅ PDF 저장 완료!';
    showToast('PDF 저장 완료', 'success', 3000);
    setTimeout(() => { $('pdfExportModal').style.display = 'none'; }, 1800);
  } catch (e) {
    showToast('PDF 생성 오류: ' + e.message, 'error', 5000);
    console.error(e);
  } finally {
    startBtn.disabled    = false;
    startBtn.textContent = '📥 내보내기';
  }
}

// 기존 호환용 alias
function exportPDF() { openPdfModal(); }

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    document.querySelectorAll('.js-plotly-plot').forEach(p => Plotly.Plots.resize(p));
    // 화면 크기 변경 시 FAB 표시/숨김 처리
    const fab = $('mobileAnalyzeFab');
    if (!isMobile()) {
      fab.classList.remove('show');
    } else if ($('analyzeArea').style.display !== 'none' && $('dashboard').style.display === 'none') {
      fab.classList.add('show');
    }
  }, 200);
});

/* ================================================================
   GitHub 엑셀 자동 로드 (접속 시 최신 데이터 자동 표시)
   ================================================================ */
(async function autoLoadFromGitHub() {
  const EXCEL_URL = 'https://raw.githubusercontent.com/99805106aa-web/namdogeum-dashboard/main/data.xlsx';
  try {
    const response = await fetch(EXCEL_URL);
    if (!response.ok) return;
    const arrayBuffer = await response.arrayBuffer();
    workbook = XLSX.read(new Uint8Array(arrayBuffer), { type: 'array', cellDates: true });
    const fd = document.getElementById('fileDrop');
    if (fd) fd.innerHTML = '<div style="color:var(--primary);font-weight:600;font-size:13px">✅ 최신 데이터 자동 로드됨 (GitHub)</div>';
    populateSheets();
    await new Promise(r => setTimeout(r, 300));
    $('btnAnalyze').click();
  } catch(e) { /* 실패 시 무시, 아래 localStorage 복원으로 fallback */ }
})();

/* ================================================================
   페이지 로드 시 마지막 분석 결과 복원
   ================================================================ */
(function restoreLastAnalysis() {
  try {
    const saved = localStorage.getItem('ndm_lastAnalysis');
    if (!saved) return;
    const d = JSON.parse(saved);
    const ts = new Date(d.timestamp);
    const dateLabel = ts.getFullYear() + '년 ' + (ts.getMonth()+1) + '월 ' + ts.getDate() + '일 '
      + String(ts.getHours()).padStart(2,'0') + ':' + String(ts.getMinutes()).padStart(2,'0');
    $('lastAnalysisDate').textContent = '최근 분석: ' + dateLabel;

    // 저장된 defectCols 복원
    if (d.defectColsSaved) defectCols = d.defectColsSaved;

    // filtered 원본 데이터 복원 (품목 심층분석, 기간비교, 애니메이션 등에 필요)
    const filteredData = d.filtered && d.filtered.length ? d.filtered : [];

    // cleanedData 복원 → 필터 적용/분석 시작이 동작하도록
    if (filteredData.length) {
      cleanedData = filteredData;
      // 날짜를 Date 객체로 복원 (JSON 직렬화 시 문자열로 변환됨)
      cleanedData.forEach(r => {
        if (r.생산일자 && !(r.생산일자 instanceof Date)) r.생산일자 = new Date(r.생산일자);
      });
    }

    // 필터 날짜/품목 복원
    const dates = cleanedData.length ? cleanedData.map(r => dateStr(r.생산일자)).sort() : [];
    if (dates.length) {
      $('filterStart').value = dates[0];
      $('filterEnd').value = dates[dates.length-1];
      $('filterStart').min = dates[0];
      $('filterStart').max = dates[dates.length-1];
      $('filterEnd').min = dates[0];
      $('filterEnd').max = dates[dates.length-1];
      $('filterDateRange').textContent = `데이터 범위: ${dates[0]} ~ ${dates[dates.length-1]} (${[...new Set(dates)].length}일)`;
      // 품목 필터 설정
      const items = [...new Set(cleanedData.map(r => r.품명))].sort();
      setupItemFilter(items);
    } else if (d.filterStart && d.filterEnd) {
      $('filterStart').value = d.filterStart;
      $('filterEnd').value = d.filterEnd;
      $('filterDateRange').textContent = `데이터 범위: ${d.filterStart} ~ ${d.filterEnd}`;
    }

    // 대시보드 렌더링
    const restoredAlerts = (d.byItem || []).filter(r => r.불량률 > targetDefectRate/100).sort((a,b) => b.불량률 - a.불량률);
    renderDashboard(d.kpi, d.byDate, d.byItem, d.totals, restoredAlerts, filteredData);

    // 안내 메시지
    const notice = document.createElement('div');
    notice.className = 'info-box info';
    notice.style.cssText = 'margin-bottom:16px;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px';
    const noticeText = filteredData.length > 0
      ? `이전 분석 결과를 불러왔습니다 (${dateLabel}). 필터 적용 및 재분석이 가능합니다.`
      : `이전 분석 결과를 표시 중입니다 (${dateLabel}). 새 파일을 업로드하면 전체 기능이 활성화됩니다.`;
    notice.innerHTML = `<span>${noticeText}</span>
      <button class="btn btn-sm" style="background:var(--gray);color:#fff" onclick="this.parentElement.remove()">닫기</button>`;
    $('dashboard').insertBefore(notice, $('dashboard').firstChild);
  } catch(e) { /* 복원 실패 시 무시 */ }
})();

</script>
</body>
</html>
